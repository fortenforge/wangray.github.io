{"meta":{"title":"Lifelong Learning","subtitle":null,"description":"Where I keep all the stuff I've been learning and doing","author":"Ray Wang","url":"http://wangray.github.io"},"pages":[{"title":"About Me","date":"2017-03-09T09:34:05.000Z","updated":"2017-03-10T09:26:16.000Z","comments":true,"path":"about/index.html","permalink":"http://wangray.github.io/about/index.html","excerpt":"","text":"I’m a student studying computer science at the Massachusetts Institute of Technology. I’m interested in security, competing with my team, TechSec, in Capture the Flags year round. Get in touch with me at raywang@mit.edu!"},{"title":"categories","date":"2017-03-10T05:56:35.000Z","updated":"2017-03-10T05:58:29.000Z","comments":true,"path":"categories/index.html","permalink":"http://wangray.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-10T05:37:46.000Z","updated":"2017-03-10T05:58:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://wangray.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flex and Bison for a simple language, MITScript","slug":"Flex-and-Bison-for-a-simple-language-MITScript","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-10T08:58:11.000Z","comments":true,"path":"2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","link":"","permalink":"http://wangray.github.io/2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","excerpt":"","text":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below. 12345678910111213141516171819202122Program ::= Statement*Statement ::= Assignment | CallStatement | Global | IfStatement | WhileLoop | ReturnGlobal ::= &apos;global&apos; name &apos;;&apos;Assignment ::= LHS &apos;=&apos; Expression &apos;;&apos;CallStatement ::= Call &apos;;&apos;Block ::= &apos;&#123;&apos; Statement* &apos;&#125;&apos;IfStatement ::= &apos;if&apos; &apos;(&apos; Expression &apos;)&apos; Block ( &apos;else&apos; Block )?WhileLoop ::= &apos;while&apos; &apos;(&apos; Expression &apos;)&apos; BlockReturn ::= &apos;return&apos; Expression &apos;;&apos;Expression ::= Function | Boolean | RecordFunction ::= &apos;fun&apos; &apos;(&apos; Name* &apos;)&apos; BlockBoolean ::= Conjunction ( &apos;|&apos; Conjunction )*Conjunction ::= BoolUnit (&apos;&amp;&apos; BoolUnit)*BoolUnit ::= &apos;!&apos;? PredicatePredicate ::= Arithmetic ( (&apos;&lt;&apos; | &apos;&gt;&apos; | &apos;&lt;=&apos; | &apos;&gt;=&apos;| &apos;==&apos;) Arithmetic)?Arithmetic ::= Product ( (&apos;+&apos; | &apos;-&apos;) Product)*Product ::= Unit ( (&apos;*&apos; | &apos;/&apos;) Unit)*Unit ::= &apos;-&apos;? (LHS | Constant | Call | &apos;(&apos; Boolean &apos;)&apos; )LHS ::= Name (&apos;.&apos; Name | &apos;[&apos; Expression &apos;]&apos; )*Call ::= LHS &apos;(&apos; (Expression (&apos;,&apos; Expression)*)? &apos;)&apos;Record ::= &apos;&#123;&apos; (Name &apos;:&apos; Expression &apos;;&apos;)* &apos;&#125;&apos;Constant ::= integer_constant | string_constant The goal is to construct an Abstract Syntax Tree (AST) for any MITScript program and pretty-print it. 123456789101112131415161718Your parser must produce an AST with nodes for the following program constructs:Block ::= [Statement]Global ::= nameAssignment ::= LHS ExpressionExpressionStatement ::= Expression &apos;;&apos;IfStatement ::= Condition ThenPart ElsePartWhileLoop ::= Condition BodyReturn ::= ExpressionFunctionDeclaration ::= [Arguments] BodyBinaryExpression ::= LeftOperand Operator RightOperandUnaryExpression ::= Operand OperatorFieldDereference ::= BaseExpression FieldIndexExpression ::= BaseExpression IndexCall ::= TargetExpression [Arguments]Record ::= Map[String, Expression]IntegerConstantStringConstantNoneConstant FlexHow do Flex and Bison work? Much of the lab was reading documentation about these two old utilities. Flex takes a .lex file, which simply lists the regular expressions, tokens, and keywords that will be matched in a program. When Flex works with Bison, every time it matches a token/keyword, it tells Bison about it. It can return the type of token/keyword to Bison, and it can also return an entire matched string or int in a Bison object it has access to, called yylval. Here are examples of both: 1234567&#123;string_const&#125; &#123; //Rule for string constant yylval-&gt;strType = new string(yytext); return T_STRINGCONST;&#125;&quot;while&quot; &#123;return T_WHILE;&#125; For us, the lab specifies that: Your lexer must be able to recognize the following kinds of tokens in addition to all the keywords and operators listed above: integer constants consisting of one or more digits 1int_const [0-9][0-9]* string constants wrapped in double quotes and supporting the following escaped characters: \\ \\” \\n \\t 1string_const (\\&quot;(\\\\.|[^&quot;])*\\&quot;) None constant, equivalent to “NULL” in Java ‘true’ and ‘false’ 123&quot;None&quot; &#123;return T_NONE;&#125;&quot;true&quot; &#123;return T_TRUE;&#125;&quot;false&quot; &#123;return T_FALSE;&#125; Name identifiers that start with a letter or underscore, followed by sequence of letters, underscores and numbers. so x0 is a valid variable name, but 0x is not 12345678identifier ([a-zA-Z_][a-zA-Z_0-9]*)...&#123;identifier&#125; &#123; yylval-&gt;strType = new string(yytext); return IDENTIFIER;&#125; The file is compiled in our Makefile with flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex. BisonIn the Bison .yy file, we must define several things. First, we must define the union, types, and tokens that Flex and our grammar know about. Then, we need to define our grammar (the most important part!). The grammar section of the .yy file contains rules created simply by converting our MITScript to Bison syntax (more on this soon). Each rule is associated with an action, which contains C++ code to be executed when the rule is matched. How does this fit into everything else? Well, we have a main.cpp file that will call yyparse on stdin, which will match all the tokens and Bison rules, executing their actions. These actions will construct node objects of an AST, which are defined in AST.h. Then, the main.cpp file will call the pretty print function on the root node, which will recursively print the tree. As an example of a rule + action,1234returnStmt: T_RETURN expr T_SEMICOLON &#123; $$ = new ReturnStatement(*$2); &#125;; Above, the T_RETURN and T_SEMICOLON are tokens that correspond to “return” and “;” in our lex file. The components matched by the rule can be accessed by $n, which stands for the value of the nth component. The semantic value for the grouping being constructed is $$. The ReturnStatement object is an AST node class defined in another file, AST.h, which we’ll get to. But let me go back to the union. “The %union declaration specifies the entire collection of possible data types for semantic values.” Lexer can access these union fields in yylval. 12345678910111213%union &#123; int intconst; string *strType; // goes with string_const in lex Block* blockType; Statement* statementType; Expression* expressionType; vector&lt;Expression*&gt; *exprListType; vector&lt;Statement*&gt; *stmtListType; vector&lt;string*&gt; *stringListType; //maybe don&apos;t need for function declaration list map&lt;string, Expression*&gt; *recordMapType;&#125; You can see that in my union, I have a bunch of pointers of node types in my AST. I can now define %tokens, which are terminals in my grammar (strings, keywords and ints), and %types, which are nonterminals in my grammar. All the tokens are matched and returned in the .lex file. 123456%token&lt;intconst&gt; T_INT%token&lt;strType&gt; T_SEMICOLON T_LBRACKET T_RBRACKET T_LPAREN T_RPAREN T_AND T_OR T_EXCLAM T_LESS_THAN T_GREATER_THAN T_LEQ T_GEQ T_EQEQ T_PLUS T_MINUS T_TIMES T_DIV T_DOT T_EQUALS T_COLON T_LBRACE T_RBRACE T_COMMA%token &lt;strType&gt; T_FUNCTION T_GLOBAL T_IF T_ELSE T_WHILE T_RETURN T_NONE T_TRUE T_FALSE%token &lt;strType&gt; IDENTIFIER T_STRINGCONST And nonterminals: 1234567891011%type &lt;statementType&gt; stmt assignment callStmt ifStmt whileLoop returnStmt global Program%type &lt;blockType&gt; block%type&lt;stmtListType&gt; stmts%type &lt;expressionType&gt; expr call boolean function conjunction boolunit predicate arithmetic product unit lhs record constant subunit%type&lt;exprListType&gt; argument_expr_list func_declaration_list%type&lt;recordMapType&gt; record_init_list To enforce left-associativity, I add12%left PLUS MINUS%left TIMES DIV Now for the fun stuff! With all the types I’ve defined, I need to write grammar rules for all of them. 12345678Program: %empty &#123; // printf(\"Empty program\\n\"); &#125; | stmts &#123; $$ = new Program(*$1); out = $$; &#125;; The highest level, the start Program, can be empty. We assign the Program node to out, which is passed to main.cpp through an argument of yyparse. Note that the skeleton code added some extra stuff to make this necessary/possible; namely, it is needed to make the parser reentrant. The skeleton code constructs are explained in this great post. Much of the translation from BNF grammar to Bison is straightforward. But, when creating variable-length lists, such as function arguments(fun(a b c){}), we have to use a C++ vector and recursively push objects into it. 1234567891011argument_expr_list: %empty &#123; $$ = new ExpressionList(); &#125; | expr &#123; $$ = new ExpressionList(); $$-&gt;push_back($1); &#125; | argument_expr_list T_COMMA expr &#123; $1-&gt;push_back($3); &#125;; In the third rule above, the $3 matches the expr, and $1 matches the argument_expr_list, which you recall is of type vector&lt;Expression*&gt;. The same goes for record rules, which are like Python dicts, and are of type map&lt;string, Expression*&gt;:123456789101112131415record: T_LBRACE record_init_list T_RBRACE &#123; // printf(&quot;Parsing\\n &quot;); $$ = new Record(*$2); &#125;;record_init_list: %empty &#123; // printf(&quot;Parsing empty record\\n &quot;); $$ = new RecordMap(); &#125; | record_init_list IDENTIFIER T_COLON expr T_SEMICOLON &#123; // printf(&quot;Parsing record recursive\\n &quot;); $1-&gt;insert(make_pair(*$2, $4)); &#125;; Note that the default action for a rule is $$ = $1;. Running bison with bison --output=parser.cpp --defines=parser.h -v parser.yy will produce several files, including a parser.output file that contains valuable debugging info about our parser, such as the state transition tables. AST Nodes, Visitor pattern pretty-printing, and main (Or, putting it all together)Here’s the main.cpp file12345678910111213int main(int argc, char** argv)&#123; void* scanner; yylex_init(&amp;scanner); yyset_in(stdin, scanner); Statement* output; int rvalue = yyparse(scanner, output); if(rvalue == 1)&#123; cout&lt;&lt;&quot;Parsing failed&quot;&lt;&lt;endl; return 1; &#125; PrettyPrinter printer; output-&gt;accept(printer);&#125; Each class in my AST.h inherits from Expression or Statement. 123456789class Call: public Expression &#123;public: Expression&amp; targetExpr; ExpressionList&amp; argumentsList; Call( Expression&amp; targetExpr, ExpressionList&amp; argumentsList): targetExpr(targetExpr), argumentsList(argumentsList)&#123;&#125;; void accept(Visitor&amp; v) override &#123; v.visit(*this); &#125;&#125;; The accept function that overrides a virtual method is part of the Visitor Pattern. Instead of defining a pretty-print method in each of my classes in AST.h, I define a PrettyPrinter class that contains visit(Object&amp; obj) methods for all my nodes. We also need an interface with all our virtual methods in Visitor.h. This diagram explains the Visitor pattern well. My PrettyPrinter.h file has recursive calls to each node’s accept() method. For example, for a Block, which contains a list of Statements, 123456789101112void visit(Block&amp; blk) override &#123; PrettyPrinter printer; printf(\"&#123;\"); TABLEVEL++; for ( auto statement = blk.statements.begin(); statement != blk.statements.end(); statement++ ) &#123; printf(\"\\n\"); (*statement)-&gt;accept(printer); &#125; printf(\"\\n%s&#125;\", string(TABLEVEL-1,'\\t').c_str()); TABLEVEL--;&#125;; I use a global variable TABLEVEL and printf(&quot;\\n%s}&quot;, string(TABLEVEL-1,&#39;\\t&#39;).c_str()); to get the correct indentation for the body elements of the block. When I print, I wrap all BinaryExpressions and UnaryExpressions in parentheses. We can now understand the rest of our Makefile,123456789all: parser.cpp lexer.cpp main.cpp PrettyPrinter.h Visitor.h g++ -g -std=gnu++11 main.cpp parser.cpp lexer.cppparser.cpp: parser.yy bison --output=parser.cpp --defines=parser.h -v parser.yylexer.cpp: lexer.lex flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex The compiled binary, a.out, will take in a file through a redirect ./a.out &lt; tests/good1.mit and pretty-print! Other referencesHere is a complete compiler tutorial that is closer to a real language than most things. Most other Flex/Bison examples are stupid calculators x.x. This tutorial is very very thorough. The ANSI C Lex spec and Yacc (old version of Bison) file are helpful in constructing our own grammar and lex rules.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://wangray.github.io/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://wangray.github.io/tags/6-035/"}]}]}