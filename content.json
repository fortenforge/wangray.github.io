{"meta":{"title":"Lifelong Learning","subtitle":null,"description":"Where I keep all the stuff that doesn't fit in my head","author":"Ray Wang","url":"http://wangray.github.io"},"pages":[{"title":"About Me","date":"2017-03-09T09:34:05.000Z","updated":"2017-03-10T10:45:49.000Z","comments":true,"path":"about/index.html","permalink":"http://wangray.github.io/about/index.html","excerpt":"","text":"I’m a student studying computer science at the Massachusetts Institute of Technology. I’m interested in computer security, and I compete with my team, TechSec, in Capture the Flag competitions year-round. This humble blog is mostly a reference for my forgetful future self. I’ll be posting CTF writeups, projects I’m working on, things I’m currently learning. I hope that other curious netizens may wean something useful from my blog as well. – 3/10/17 Get in touch with me at raywang@mit.edu!"},{"title":"categories","date":"2017-03-10T05:56:35.000Z","updated":"2017-03-10T05:58:29.000Z","comments":true,"path":"categories/index.html","permalink":"http://wangray.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-10T05:37:46.000Z","updated":"2017-03-10T05:58:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://wangray.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flex and Bison for a simple language, MITScript","slug":"Flex-and-Bison-for-a-simple-language-MITScript","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-11T07:30:49.000Z","comments":true,"path":"2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","link":"","permalink":"http://wangray.github.io/2017/03/07/Flex-and-Bison-for-a-simple-language-MITScript/","excerpt":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below.","text":"For the first lab in 6.035, Computer Language Engineering, in Spring 2017, we use Flex, a lexical analyzer library, and Bison, a parser generator, to create a parser for a simple scripting language. The grammar for the language is shown below. 12345678910111213141516171819202122Program ::= Statement*Statement ::= Assignment | CallStatement | Global | IfStatement | WhileLoop | ReturnGlobal ::= 'global' name ';'Assignment ::= LHS '=' Expression ';'CallStatement ::= Call ';'Block ::= '&#123;' Statement* '&#125;'IfStatement ::= 'if' '(' Expression ')' Block ( 'else' Block )?WhileLoop ::= 'while' '(' Expression ')' BlockReturn ::= 'return' Expression ';'Expression ::= Function | Boolean | RecordFunction ::= 'fun' '(' Name* ')' BlockBoolean ::= Conjunction ( '|' Conjunction )*Conjunction ::= BoolUnit ('&amp;' BoolUnit)*BoolUnit ::= '!'? PredicatePredicate ::= Arithmetic ( ('&lt;' | '&gt;' | '&lt;=' | '&gt;='| '==') Arithmetic)?Arithmetic ::= Product ( ('+' | '-') Product)*Product ::= Unit ( ('*' | '/') Unit)*Unit ::= '-'? (LHS | Constant | Call | '(' Boolean ')' )LHS ::= Name ('.' Name | '[' Expression ']' )*Call ::= LHS '(' (Expression (',' Expression)*)? ')'Record ::= '&#123;' (Name ':' Expression ';')* '&#125;'Constant ::= integer_constant | string_constant The goal is to construct an Abstract Syntax Tree (AST) for any MITScript program and pretty-print it. 123456789101112131415161718Your parser must produce an AST with nodes for the following program constructs:Block ::= [Statement]Global ::= nameAssignment ::= LHS ExpressionExpressionStatement ::= Expression ';'IfStatement ::= Condition ThenPart ElsePartWhileLoop ::= Condition BodyReturn ::= ExpressionFunctionDeclaration ::= [Arguments] BodyBinaryExpression ::= LeftOperand Operator RightOperandUnaryExpression ::= Operand OperatorFieldDereference ::= BaseExpression FieldIndexExpression ::= BaseExpression IndexCall ::= TargetExpression [Arguments]Record ::= Map[String, Expression]IntegerConstantStringConstantNoneConstant FlexHow do Flex and Bison work? Much of the lab was reading documentation about these two old utilities. Flex takes a .lex file, which simply lists the regular expressions, tokens, and keywords that will be matched in a program. When Flex works with Bison, every time it matches a token/keyword, it tells Bison about it. It can return the type of token/keyword to Bison, and it can also return an entire matched string or int in a Bison object it has access to, called yylval. Here are examples of both: 1234567&#123;string_const&#125; &#123; //Rule for string constant yylval-&gt;strType = new string(yytext); return T_STRINGCONST;&#125;\"while\" &#123;return T_WHILE;&#125; For us, the lab specifies that: Your lexer must be able to recognize the following kinds of tokens in addition to all the keywords and operators listed above: integer constants consisting of one or more digits 1int_const [0-9][0-9]* string constants wrapped in double quotes and supporting the following escaped characters: \\ \\” \\n \\t 1string_const (\\&quot;(\\\\.|[^&quot;])*\\&quot;) None constant, equivalent to “NULL” in Java ‘true’ and ‘false’ 123&quot;None&quot; &#123;return T_NONE;&#125;&quot;true&quot; &#123;return T_TRUE;&#125;&quot;false&quot; &#123;return T_FALSE;&#125; Name identifiers that start with a letter or underscore, followed by sequence of letters, underscores and numbers. so x0 is a valid variable name, but 0x is not 12345678identifier ([a-zA-Z_][a-zA-Z_0-9]*)...&#123;identifier&#125; &#123; yylval-&gt;strType = new string(yytext); return IDENTIFIER;&#125; The file is compiled in our Makefile with flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex. BisonIn the Bison .yy file, we must define several things. First, we must define the union, types, and tokens that Flex and our grammar know about. Then, we need to define our grammar (the most important part!). The grammar section of the .yy file contains rules created simply by converting our MITScript to Bison syntax (more on this soon). Each rule is associated with an action, which contains C++ code to be executed when the rule is matched. How does this fit into everything else? Well, we have a main.cpp file that will call yyparse on stdin, which will match all the tokens and Bison rules, executing their actions. These actions will construct node objects of an AST, which are defined in AST.h. Then, the main.cpp file will call the pretty print function on the root node, which will recursively print the tree. As an example of a rule + action,1234returnStmt: T_RETURN expr T_SEMICOLON &#123; $$ = new ReturnStatement(*$2); &#125;; Above, the T_RETURN and T_SEMICOLON are tokens that correspond to “return” and “;” in our lex file. The components matched by the rule can be accessed by $n, which stands for the value of the nth component. The semantic value for the grouping being constructed is $$. The ReturnStatement object is an AST node class defined in another file, AST.h, which we’ll get to. But let me go back to the union. “The %union declaration specifies the entire collection of possible data types for semantic values.” Lexer can access these union fields in yylval. 12345678910111213%union &#123; int intconst; string *strType; // goes with string_const in lex Block* blockType; Statement* statementType; Expression* expressionType; vector&lt;Expression*&gt; *exprListType; vector&lt;Statement*&gt; *stmtListType; vector&lt;string*&gt; *stringListType; //maybe don't need for function declaration list map&lt;string, Expression*&gt; *recordMapType;&#125; You can see that in my union, I have a bunch of pointers of node types in my AST. I can now define %tokens, which are terminals in my grammar (strings, keywords and ints), and %types, which are nonterminals in my grammar. All the tokens are matched and returned in the .lex file. 123456%token&lt;intconst&gt; T_INT%token&lt;strType&gt; T_SEMICOLON T_LBRACKET T_RBRACKET T_LPAREN T_RPAREN T_AND T_OR T_EXCLAM T_LESS_THAN T_GREATER_THAN T_LEQ T_GEQ T_EQEQ T_PLUS T_MINUS T_TIMES T_DIV T_DOT T_EQUALS T_COLON T_LBRACE T_RBRACE T_COMMA%token &lt;strType&gt; T_FUNCTION T_GLOBAL T_IF T_ELSE T_WHILE T_RETURN T_NONE T_TRUE T_FALSE%token &lt;strType&gt; IDENTIFIER T_STRINGCONST And nonterminals: 1234567891011%type &lt;statementType&gt; stmt assignment callStmt ifStmt whileLoop returnStmt global Program%type &lt;blockType&gt; block%type&lt;stmtListType&gt; stmts%type &lt;expressionType&gt; expr call boolean function conjunction boolunit predicate arithmetic product unit lhs record constant subunit%type&lt;exprListType&gt; argument_expr_list func_declaration_list%type&lt;recordMapType&gt; record_init_list To enforce left-associativity, I add12%left PLUS MINUS%left TIMES DIV Now for the fun stuff! With all the types I’ve defined, I need to write grammar rules for all of them. 12345678Program: %empty &#123; // printf(\"Empty program\\n\"); &#125; | stmts &#123; $$ = new Program(*$1); out = $$; &#125;; The highest level, the start Program, can be empty. We assign the Program node to out, which is passed to main.cpp through an argument of yyparse. Note that the skeleton code added some extra stuff to make this necessary/possible; namely, it is needed to make the parser reentrant. The skeleton code constructs are explained in this great post. Much of the translation from BNF grammar to Bison is straightforward. But, when creating variable-length lists, such as function arguments(fun(a b c){}), we have to use a C++ vector and recursively push objects into it. 1234567891011argument_expr_list: %empty &#123; $$ = new ExpressionList(); &#125; | expr &#123; $$ = new ExpressionList(); $$-&gt;push_back($1); &#125; | argument_expr_list T_COMMA expr &#123; $1-&gt;push_back($3); &#125;; In the third rule above, the $3 matches the expr, and $1 matches the argument_expr_list, which you recall is of type vector&lt;Expression*&gt;. The same goes for record rules, which are like Python dicts, and are of type map&lt;string, Expression*&gt;:123456789101112131415record: T_LBRACE record_init_list T_RBRACE &#123; // printf(&quot;Parsing\\n &quot;); $$ = new Record(*$2); &#125;;record_init_list: %empty &#123; // printf(&quot;Parsing empty record\\n &quot;); $$ = new RecordMap(); &#125; | record_init_list IDENTIFIER T_COLON expr T_SEMICOLON &#123; // printf(&quot;Parsing record recursive\\n &quot;); $1-&gt;insert(make_pair(*$2, $4)); &#125;; Note that the default action for a rule is $$ = $1;. Running bison with bison --output=parser.cpp --defines=parser.h -v parser.yy will produce several files, including a parser.output file that contains valuable debugging info about our parser, such as the state transition tables. AST Nodes, Visitor pattern pretty-printing, and main (Or, putting it all together)Here’s the main.cpp file12345678910111213int main(int argc, char** argv)&#123; void* scanner; yylex_init(&amp;scanner); yyset_in(stdin, scanner); Statement* output; int rvalue = yyparse(scanner, output); if(rvalue == 1)&#123; cout&lt;&lt;\"Parsing failed\"&lt;&lt;endl; return 1; &#125; PrettyPrinter printer; output-&gt;accept(printer);&#125; Each class in my AST.h inherits from Expression or Statement. 123456789class Call: public Expression &#123;public: Expression&amp; targetExpr; ExpressionList&amp; argumentsList; Call( Expression&amp; targetExpr, ExpressionList&amp; argumentsList): targetExpr(targetExpr), argumentsList(argumentsList)&#123;&#125;; void accept(Visitor&amp; v) override &#123; v.visit(*this); &#125;&#125;; The accept function that overrides a virtual method is part of the Visitor Pattern. Instead of defining a pretty-print method in each of my classes in AST.h, I define a PrettyPrinter class that contains visit(Object&amp; obj) methods for all my nodes. We also need an interface with all our virtual methods in Visitor.h. This diagram explains the Visitor pattern well. My PrettyPrinter.h file has recursive calls to each node’s accept() method. For example, for a Block, which contains a list of Statements, 123456789101112void visit(Block&amp; blk) override &#123; PrettyPrinter printer; printf(\"&#123;\"); TABLEVEL++; for ( auto statement = blk.statements.begin(); statement != blk.statements.end(); statement++ ) &#123; printf(\"\\n\"); (*statement)-&gt;accept(printer); &#125; printf(\"\\n%s&#125;\", string(TABLEVEL-1,'\\t').c_str()); TABLEVEL--;&#125;; I use a global variable TABLEVEL and printf(&quot;\\n%s}&quot;, string(TABLEVEL-1,&#39;\\t&#39;).c_str()); to get the correct indentation for the body elements of the block. When I print, I wrap all BinaryExpressions and UnaryExpressions in parentheses. We can now understand the rest of our Makefile,123456789all: parser.cpp lexer.cpp main.cpp PrettyPrinter.h Visitor.h g++ -g -std=gnu++11 main.cpp parser.cpp lexer.cppparser.cpp: parser.yy bison --output=parser.cpp --defines=parser.h -v parser.yylexer.cpp: lexer.lex flex --outfile=lexer.cpp --header-file=lexer.h lexer.lex The compiled binary, a.out, will take in a file through a redirect ./a.out &lt; tests/good1.mit and pretty-print! Other referencesHere is a complete compiler tutorial that is closer to a real language than most things. Most other Flex/Bison examples are stupid calculators x.x. This tutorial is very very thorough. The ANSI C Lex spec and Yacc (old version of Bison) file are helpful in constructing our own grammar and lex rules.","categories":[{"name":"Languages","slug":"Languages","permalink":"http://wangray.github.io/categories/Languages/"}],"tags":[{"name":"6.035","slug":"6-035","permalink":"http://wangray.github.io/tags/6-035/"}]},{"title":"Matasano Crypto Challenges, Set 1","slug":"set1_writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-11T07:37:34.000Z","comments":true,"path":"2017/03/07/set1_writeup/","link":"","permalink":"http://wangray.github.io/2017/03/07/set1_writeup/","excerpt":"Challenge 1.1 Convert hex to base64The first challenge is pretty straightforward, using python’s built-in functions or pwntools, as I use heavily in these challenges. The functions a2b_hex, unhexlify, and &#39;&#39;.decode(&quot;hex&quot;) all do the same thing. They take in an ascii string of the form “[0-9a-f]*“ and decode it. The string decodes toI&#39;m killing your brain like a poisonous mushroom. We can then use binascii.b2a_base64() to convert the byte string to a base64 representation.","text":"Challenge 1.1 Convert hex to base64The first challenge is pretty straightforward, using python’s built-in functions or pwntools, as I use heavily in these challenges. The functions a2b_hex, unhexlify, and &#39;&#39;.decode(&quot;hex&quot;) all do the same thing. They take in an ascii string of the form “[0-9a-f]*“ and decode it. The string decodes toI&#39;m killing your brain like a poisonous mushroom. We can then use binascii.b2a_base64() to convert the byte string to a base64 representation. Challenge 1.2 Fixed XORThis challenge uses iterators to do a fixed-length xor. The chr() function takes an ASCII integer code in the range 0-255 and returns a character string. The ord() function does the inverse, taking a character and returning its integer. We want to xor these integers. Thus, &#39;&#39;.join([chr(ord(i)^ord(j)) for i, j in zip(s1, s2)]) will first xor the integers of each character of the input strings with ord(). Then it will convert back into a character string with chr(). Challenge 1.3 Single-byte XOR cipherExtending the last challenge, we can create a variable-length input xor function. Or, we can use pwntools xor(). I iterate through all 255 possible single character xor keys, scoring each decrypted word based on character frequency.123456for c in result: c = c.lower() if c in character_frequency: word_score += character_frequency[c]cand_words.append((result, word_score, char)) Challenge 1.4 Detect single-character XORThis challenge asks us to find which of the 60-character strings in the file has been encrypted by single-character XOR. Using the find_singlechar_key_xor utility function created in the last challenge, I can iterate through all the file strings and find the possible single-character xor key and word score of each line. The line turns out to decode to ‘Now that the party is jumping\\n’, xored against the byte 5. Challenge 1.5 Implement repeating-key XORThis is a cop-out. Pwntools implements repeating-key xor in its utils.fiddling library. We can use python itertools for this as well,1return ''.join([chr(ord(i)^ord(j)) for i, j in it.izip(s1, it.cycle(s2))]) Challenge 1.6 Break repeating-key XORThis challenge asks us to solve repeating-key xor, aka the Vigenere cipher. There are several steps to doing this. First, we need to find the xor key length. the period of the cipher. Next, we need to find the key character-by-character, using the single-byte xor cipher we made in Challenge 1.3. In the first step I calculate the Hamming distance (number of diff bits between two strings) of two consecutive ciphertext blocks (of some guessed length). The correct keylength will create blocks of minimum Hamming distance. The challenge tells us to try values from 2 to 40 for the guessed key length. I calculate the hamming distance of all combinations of 4 blocks.12pairs = list(it.combinations(blocks, 2))hamsum = it.starmap(hamming, pairs) it.starmap computes the hamming function using arguments obtained from the iterable pairs.I then normalize the Hamming distance for keysize.1normalized = float(reduce(lambda x, y: x+y, hamsum))/keysize and find the keylength with the minimum normalized hamming distance is 29. The second step is to find the key, character-by-character. I split the ciphertext into blocks of len(keysize) and transpose them, so that I have a list of all the 1st, 2nd, etc… chars of each block. Each of these transposed messages has been single-char xored, so I can just find each single-char key and concatenate the chars to get the full xor key. 12345678blocks = [x[i:i+keysize] for i in range(0, len(x), keysize)]blocks = it.izip_longest(*blocks, fillvalue='0')block_list = [''.join(msg) for msg in blocks]char_freqs = [find_singlechar_key_xor(''.join(msg))[2]for msg in block_list] I need to use izip_longest because the last block is shorter than the others, and izip_longest pads the shortest elements of the iterable. The key made by joining the single-char keys is Terminator X: Bring the noise. Challenge 1.7 AES in ECB modeThis challenge introduces the AES block cipher and the ECB mode. The ECB mode is problematic because it is stateless and deterministic — the same block of plaintext will encrypt to the same ciphertext. I use the cryptography module in Python because it’s being actively developed, although the PyCrypto library is more popular. You initialize AES, a symmetric cipher, with1cipher = Cipher(algorithm = algorithms.AES(\"YELLOW SUBMARINE\"), mode = modes.ECB(), backend=default_backend()) . To decrypt text, you use a decryptor object and the update() and finalize() methods. 12d = cipher.decryptor()decrypted_text = d.update(file) + d.finalize() Challenge 1.8 Detect AES in ECB modeBecause ECB is deterministic, I can detect which of the strings in 8.txt is encrypted using ECB. The properties of the plaintext, such as low Hamming distance, will remain in the ciphertext. Thus, I can use minimum Hamming distance to find the correct line, similar to Challenge 6. I create a scoring function, hamming_score_line(line), which will return the hamsum of a line of ciphertext. 1min_line_num = min(lines, key=hamming_score_line)[0] will be the correct answer, 133. References[1] pwntools","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://wangray.github.io/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://wangray.github.io/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 2","slug":"set2_writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-11T07:34:41.000Z","comments":true,"path":"2017/03/07/set2_writeup/","link":"","permalink":"http://wangray.github.io/2017/03/07/set2_writeup/","excerpt":"Challenge 9 Implement PKCS#7 paddingAs the challenge states, “A block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.” The PKCS#7 padding scheme will append the number of bytes of padding to the end of the block. I use the pwntools pack() function to pack the number of padding bytes.","text":"Challenge 9 Implement PKCS#7 paddingAs the challenge states, “A block cipher transforms a fixed-sized block (usually 8 or 16 bytes) of plaintext into ciphertext. But we almost never want to transform a single block; we encrypt irregularly-sized messages.” The PKCS#7 padding scheme will append the number of bytes of padding to the end of the block. I use the pwntools pack() function to pack the number of padding bytes. Challenge 10 Implement CBC modeThis challenge has us implement CBC mode of block encryption. In CBC mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. We need an IV for the first block of plaintext. In set2_utils, I create a CBC Cipher class that takes in a cipher and an IV. The encrypt() function will split the plaintext into blocks (usually size 16), and then do the encryption: 1234567# Xor with previous block. First prev_xor_block is the IV.pre_aes_block = xor(blocks[i], prev_xor_block)# Encrypt with cipher algorithmcurrent_cipher_block = e.update(pre_aes_block)prev_xor_block = current_cipher_blockciphertext += current_cipher_block The decryption takes each block of ciphertext, decrypts it, and XORs with the previous block of ciphertext to recover the plaintext. 12345for i in xrange(1, len(blocks)): decrypted_block = d.update(blocks[i]) # print decrypted_block plaintext += xor(decrypted_block, blocks[i-1]) # where blocks[i-1] is the previous ciphertext block I can verify I’ve done this correctly by decrypting 10.txt with a CBC Cipher with IV &#39;\\x00&#39;*16. Challenge 11 An ECB/CBC detection oracleThis challenge asks us to detect whether we’ve encrypted a text with ECB or CBC, chosen at random. Recall the properties of ECB vs CBC — ECB will take two identical plaintext blocks and produce two identical ciphertext blocks. This is as simple as asking the oracle to encrypt a string that contains at least two consecutive blocks of identical characters. If the oracle chooses ECB, the ciphertext will have two adjacent identical blocks as well. To ensure that we have at least two consecutive blocks of identical characters, we need to input at least 43 bytes. Why? Because the oracle pads the plaintext with 5-10 bytes, so we need to give some offset to ensure our identical plaintext blocks are properly aligned. R = random_nfix123|--------16-----||-5-| |---11----| |--------16----| |--------16----|RRRRR 00000000000 0000000000000000 0000000000000000 Challenge 12 Byte-at-a-time ECB decryption (Simple)I have an oracle that produces AES-128-ECB(your-string || unknown-string, random-key). I can find unknown-string with this oracle. The idea is that, First, I need to find the block size of the cipher. Then, assuming I know it’s using ECB, I can find the flag byte-by-byte. How? Since I control my-string, I can ensure each time that the oracle encrypts 15 bytes that I know + one unknown byte. I can then create a table of all possible ciphertexts of the 15 known bytes + 1 unknown byte, and compare the ciphertext the oracle returns to the ciphertexts in my table. To find the block size, I feed in incrementing offsets to the oracle, until the ciphertext length increases. The size of the increase will be block_size, because of the padding. Next, I need to get an offset of 15 known bytes to feed into the oracle. The first offset is just 15 filler variables, all A’s. 12345678U = unknown flag byteK = known flag byteInput to oracle, |-16-| bytes to be looked up in table: |----offset----| |--------16-----|plaintext: AAAAAAAAAAAAAAAU UUUU..... And I create a table of all possible ciphertexts of A…U. 1234for cand in candidates: # every candidate block of ciphertext is 16 bytes block_of_interest = oracle(offset+cand)[0:blocksize] cand_dict[block_of_interest] = cand I then feed the block with the unknown byte to the oracle, padding with the same filler variables as my offset. Perform the table lookup. 12345oracle_block = oracle('A'*offset_len)[block_of_interest : block_of_interest + blocksize]if oracle_block in cand_dict: next_byte = cand_dict[oracle_block] At the next iteration, I decrease the number of filler variables by 1, since I have a known byte and want the next byte. 123Input to oracle, |-16-| bytes to be looked up in table: |--------16-----|plaintext: AAAAAAAAAAAAAAKU UUUU..... When I have 16 known bytes in this manner, I no longer need filler variables in my offset; I can just use the previous 15 known bytes as my offset. Note that my lookup table can be populated with ciphertexts of 16 flag bytes. Since I have 16-byte ciphertexts in my lookup table, I need to first align, then get the index of, the 16-byte block-of-interest that I’ll look up in my table. 123456Input to oracle, |-16-| bytes to be looked up in table:block_num: 0 1 block_of_interest alignment bytes |--------16-----|plaintext: AAAAAAAAAAAAAAAK KKKKKKKKKKKKKKKU UUUU..... Stopping after I run out of bytes, I find the answer is1Rollin' in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 13 ECB cut-and-pasteChallenge 14 Byte-at-a-time ECB decryption with random prefixIn this challenge, a random-length prefix is added to the attacker-controlled string, AES-128-ECB(random-prefix || attacker-controlled || target-bytes, random-key). Thus, I need to know the length of the prefix to be able to conduct the same attack as Challenge 12. Finding this length is not so hard. First, I can find the block index of the last byte of the prefix with just two calls to the oracle. Then, I find the offset of the last byte of the prefix within the last block. 12ciphertext1 = prefix_oracle('')ciphertext2 = prefix_oracle('A') Because this is ECB mode, the first different block between ciphertext1 and ciphertext2 will be the last block of the prefix. 12345678910U = unknown flag byteR = random prefix byteplaintext1:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRUUUUUU....plaintext2:|--------16----||-enc to different value-|RRRRRRRRRRRRRRRRRRRRAUUUUUU.... Now that I know what block the last byte of the prefix is in, find_prefix_block_modulo_offset finds the offset of the last byte of the prefix. I want to align two blocks of identical plaintext, to encrypt to two blocks of identical ciphertext. The amount of offset I use to align will tell me the offset of the prefix. 123for i in xrange(0, blocksize): offset = 'A'*i + '\\x00'*32 ciphertext = prefix_oracle(offset) 123456789 |--offset-|RRRRR00000000000 0000000000000000 0000000000000000 UUUUUU....```pythonIn the above example, the two 16-byte-aligned blocks of \\x00's will encrypt to adjacent identical ciphertext, which I can detect.Finally, `find_next_byte_with_prefix` will do the work. The offset is now```pythonoffset = 'A'*(extra_offset_for_prefix + offset_len) , with offset_len always being 15 known bytes, as in Challenge 12. The keys in my lookup table are no longer a fixed-length of blocksize — they include all known bytes now. Here, the len(offset) is not always 15, as in Challenge 12. Also, the length of my lookup table keys is not always blocksize; rather, the length of my keys increases with the number of known bytes. I could have implemented this more similarly to Challenge 12, which would have been less computationally expensive. How do I produce ciphertext keys for my lookup table now? Here’s what I feed into the oracle:12for cand in candidates: table_key = oracle(offset + knownbytes + cand)[prefix_location: prefix_location + len(offset) + len(knownbytes) + 1] 12 |--lookup table key---------|RRRRRAAAAAAAAAAA AAAAAAAAAAAAAAAU UUUU..... 123456 |-------------------lookup table key---------| |---offset-------|extra_offset_for_prefix | |RRRRRAAAAAAAAAAA AAAAAKKKKKKKKKKK KKKKKKKKKKKKKKKU UUUU..... Calling find_next_byte_with_prefix byte-by-byte, I find the same flag as before.1Rollin' in my 5.0\\nWith my rag-top down so my hair can blow\\nThe girlies on standby waving just to say hi\\nDid you stop? No, I just drove by\\n Challenge 15 PKCS#7 padding validationHere’s an easy one. We need only validate that the PKCS7 padding is correct. 123456789101112131415byte = s[-1]pad_length = unpack(byte, 'all')if byte == 0 or s[-pad_length:] != byte * pad_length or byte == \"\":```pythonI check if the last `pad_length` bytes of `s` are equal to the string of `byte` repeated `pad_length` times, as it should be in a properly padded string. ## Challenge 16 CBC bitflipping attacksWe have a function that takes user input and url-encodes special characters, and we want to exploit the properties of CBC to allow us to insert the string \";admin=true;\" without the \";\" and \"=\" being validated out.Recall that CBC takes each block of ciphertext and XORs it with the next block of decrypted ciphertext to recover the plaintext.If I can modify at least two consecutive blocks of ciphertext, I can make the second block decrypt to whatever I want.I know that `\\x00 ^ \\x59 = ;` and `\\x00 ^ \\x61 = '='` from [ascii chart](http://www.nthelp.com/ascii.htm). user-controlled input: 0 1AAAAAAAAAAAAAAAA \\x00admin\\x00true\\x00 ciphertext:XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX modified ciphertext:\\x59XXXXX\\x61XXXX\\x59XXXX XXXXXXXXXXXXXXXX In XOR step of CBC decryption, the 2nd block would normally XOR to recover \\x00admin\\x00true\\x00, but now that I’ve done an additional XOR on three bytes by modifying ciphertext, the 2nd block XORs to a plaintext of \\x59admin\\x61true\\x59.``` Done with set2!","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://wangray.github.io/categories/Crypto/"}],"tags":[{"name":"cryptopals, matasano","slug":"cryptopals-matasano","permalink":"http://wangray.github.io/tags/cryptopals-matasano/"}]},{"title":"Matasano Crypto Challenges, Set 3","slug":"set3-writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-11T07:38:21.000Z","comments":true,"path":"2017/03/07/set3-writeup/","link":"","permalink":"http://wangray.github.io/2017/03/07/set3-writeup/","excerpt":"Challenge 17 The CBC padding oracle!!!!!The CBC padding oracle is a very famous attack. We have an oracle function that takes in a ciphertext and decrypts it, returning True if the plaintext is padded properly. The process behind the attack on each block is:","text":"Challenge 17 The CBC padding oracle!!!!!The CBC padding oracle is a very famous attack. We have an oracle function that takes in a ciphertext and decrypts it, returning True if the plaintext is padded properly. The process behind the attack on each block is: For each byte, starting at the last position, modify the ciphertext in the previous block, cycling through all 256 possibilities for the plaintext until I find the correct one. Here’s the explanation of how I make and check my guesses. For the currently examined block, remember that I can modify the previous block’s ciphertext, which will be XORed with this block’s intermediate state to get a modified plaintext. What is the goal for the modified plaintext? It’s to get the proper padding bytes at the end of it! So, to decrypt the last byte of the block, I first provide the correct offset 123new_ciphertext, C':block -2 -1AAAAAAAAAAAAAAAZ XXXXXXXXXXXXXXXU If I cleverly choose the value of Z, then the last byte of C’, U above, will XOR to the correct padding byte, \\x01. I XOR out the corresponding byte from the ciphertext, XOR out a guess for the flag byte character, and XOR in the desired padding byte (\\x01). 1pad_str = offset_pad + xor(prev_block[-desired_padding_byte], cand_ord, desired_padding_byte) I create the new_ciphertext C&#39; by inserting my crafted block C[-2]&#39; before the block I’m currently examining. 1new_ciphertext = ciphertext[:-32] + pad_str + ciphertext[-16:] If my guess is correct, then only \\x01 will be left, and padding_oracle(new_ciphertext) will return True. If I’m not examining the last character in the block, then the desired padding bytes will be something greater than \\x01. I modify the following ciphertext bytes I’ve already solved to XOR out the ciphertext byte, XOR out the known flag bytes, and XOR in the desired padding byte (\\x02 - \\xF). 1pad_str = pad_str + xor(prev_block[-desired_padding_byte+1:], known_last_bytes, desired_padding_byte) if len(known_last_bytes) &gt; 0 else pad_str As before, the correct guess will cause the byte of interest to XOR to the proper padding byte, and padding_oracle(new_ciphertext) will return True. 123new_ciphertext, C':block -2 -1AAAAAAAAAAAAAAZK XXXXXXXXXXXXXXUK Above, I want the plaintext bytes at positions UK to decrypt to \\x02\\x02. Modifying K to decrypt to \\x02 is simple because I already know the byte and can fully control what to XOR in or out. Note: The ‘previous ciphertext’ block for the first block is the IV, so we perform the XORs on it the same way we would modify any other block. The wrapper function, padding_oracle_attack(padding_oracle, ciphertext, blocksize), will loop through calls to decipher_block to find the last block, append the found bytes to the flag, and on the next iteration, slice out the blocks of ciphertext I’ve already solved. Challenge 18This challenge is to implement CTR (Counter) stream cipher mode. CTR mode does not encrypt the plaintext — rather, it encrypts a running stream of counter bytes, which is then XORed with the plaintext. One benefit of CTR mode is that it does not require padding. I define a CTR() class in set3_utils. Decryption is identical to encryption. In encrypt, I generate the keystream, in 128 byte chunks, for all of my plaintext, which looks like 12keyblock = e.update(p64(self.nonce, 'little') + p64(self.counter, 'little'))keystream += keyblock These are pwntools packing functions, packing the counter in little-endian format. The nonce is a random, secret value that composes the first 64 bytes of every keystream block. After XORing my keystream with the plaintext, I save the unused keystream bytes in self.carry_over_bytes. The next time I run decrypt() or encrypt(), I set keystream = self.carry_over_bytes so I use all the bytes of previously-generated keystreams. Challenge 19 Break fixed-nonce CTR mode using substitutionsChallenge 20 Break fixed-nonce CTR statisticallyIn this challenge, using a fixed-nonce for CTR will essentially boil down to solving repeating-key XOR, where the repeating-key is the reused ciphertext of the CTR keystream. I know that each encrypted text has been XORed with the same keystream. I first pad each encrypted text with 0’s to the same length (anything longer than the longest line). 1padded_encrypted_texts = [text.ljust(max_length, '0') for text in encrypted_texts] Then, I can simply concatenate all the ciphertexts into one long string, as if a repeating-xor-key of length max_length had been applied. 1keystream = breakRepeatingXor(\"\".join(padded_encrypted_texts), max_length) The result will be a keystream that, when XORed with each encrypted text, should produce mostly readable text. The accuracy towards the end of the longer strings will degrade, because there is not enough information to determine the correct key — there are simply not enough strings near the maximum length to determine the key based on letter frequency. Challenge 21 Implement the MT19937 Mersenne Twister RNGThe Mersenne Twister is by far the most common PRNG (pseudo-random number generator). The most common version is based on the Mersenne prime 219937−1, and has a known set of constants and magic values. There are three main components of MT19937, 32-bit values. Initialization of the first set of 624 values from a seed Outputting the next number from the RNG, after some tempering Generating a new set of 624 values (twisting) In step 1, we initialize the self.state array by setting the first value to be the seed, and then calculating the rest from the formula off Wikipedia, x[i] = f × (x[i-1] ⊕ (x[i-1] &gt;&gt; (w-2))) + i, where w is the word size, 32 bits. 12for i in xrange(1, 624): self.state[i] = self.int32(f * (self.state[i-1] ^ (self.state[i-1] &gt;&gt; 30)) + i) where f is a magic, 1812433253. In step 2, the RNG outputs a number by taking the next state value, indexed by self.index, and applying some temper transforms before returning it. Then, we increment self.index to use the next state value next time. When we have used up 624 values, we “twist” to generate more. For each state value, the RNG concats the MSB of the current state value and the other 31 bits from the next state value.1y = (self.state[i] &amp; 0x80000000) + (self.state[(i+1) % 624] &amp; 0x7fffffff) Then it does the A transform above: right-shifts by one, and XORing an additional magic if the current state value is odd. We also XOR with the 397th-next former state variable. 1self.state[i] = self.state[(i+397) % 624] ^ (y&gt;&gt;1) 123if y % 2 != 0: # if odd, xor with another magic number self.state[i] ^= 0x9908b0df Challenge 22 Crack an MT19937 seedChallenge 23 Clone an MT19937 RNG from its outputTO clone an MT19937 RNG, we need to find its 624-value internal state. We need to get 624 RNG outputs, and untemper each one. The untempering is very tricky — remember that we did this sequence of two right shifts and two left-shift ANDs:1234temp ^= (temp &gt;&gt; 11)temp ^= (temp &lt;&lt; 7) &amp; 2636928640temp ^= (temp &lt;&lt; 15) &amp; 4022730752temp ^= (temp &gt;&gt; 18) Let’s see how to undo that right shift: 123410110111010111110001000011001110 ^00000000000000000010110111010111 (&gt;&gt;18)=10110111010111110011110100011001 We iterate through all the bits of the output, starting from the leftmost bit 123456for i in xrange(32): output_bit = getBit(binary_str, i) recovered_bit = output_bit ^ getBit(orig_bits, i - shift) # set the bit at index i in the orig_bits to be the recovered bit orig_bits = setBit(orig_bits, i, recovered_bit) While i &lt; shift, getBit() will return 0 as the XOR bit, and recovered_bit will just be the same as the output bit. When i = shift, orig_bits will contain the first shift original bits. getBit(orig_bits, i - shift) will emulate the right-shifted original value, grabbing original bit values, starting from the left of orig_bits. Thus, the XOR of the output_bit and the corresponding index of orig_bits will recover the next original bit. 1234567891011121314When i = 18output: 18___ |10110111010111110011110100011001orig_bits:101101110101111100recovered_bit:output[18] ^ orig_bits[0] 1 ^ 1 = 0 Note that, if shift &lt; 16, at some point each recovered original bit is used immediately in the next iteration of the for loop to recover the next bit. To untemper the left shift + and + xor, we reconstruct the original from the right side, not the left. 1234567891011 24--- | \\/ 1011011101011111000100001 1001110 ^ (&lt;--orig_bits)1010111110001000011001110 0000000 (&lt;&lt; 7) =__________________________________0001100011010111011101111 1001110 &amp;1001110100101100010101101 0000000 (&lt;--2636928640 magic) =__________________________________0001100000000100010101101 0000000 output_bits 123456for i in reversed(xrange(32)): output_bit = getBit(binary_str, i) undo_xor_bit = getBit(orig_bits, i + shift) &amp; getBit(and_val, i) recovered_bit = output_bit ^ undo_xor_bit orig_bits = setBit(orig_bits, i, recovered_bit) While i + shift &gt; 31, the undo_xor_bit is 0, so the last shift bits of orig_bits are identical to the last shift output_bits. Once i &lt;= 31-shift, we begin using values from the right side of orig_bits, emulating the left-shifted value. We then &amp; in the magic bit, and XOR with the output bit to recover the next original bit. 123456789When i = 24undo_xor_bit:orig_bits[31] &amp; and_value[24] 0 1 = 0recovered_bit:output[24] ^ undo_xor_bit = 1 ^ 0 = 1 Our final untemper function is just reversing the 4 tempers,12345678def untemper(val): val = unRightShiftXor(val, 18) val = unLeftShiftXorAnd(val, 15, 4022730752) val = unLeftShiftXorAnd(val, 7, 2636928640) val = unRightShiftXor(val, 11) and we can easily clone an RNG’s 624-value state: 123for i in xrange(624): rand = mt.get_number() cloned_mt_state[i] = untemper(rand) We check that a MT with the cloned state does in fact generate the same numbers as the original MT. Done! 12cloned_mt = MT19937(arbitrary value)cloned_mt.state = cloned_mt_state Challenge 24 Create the MT19937 stream cipher and break itWe first need to create an MT19937 stream cipher, which operates much like CTR mode. The keystream, the RNG output, is simply XORed to decrypt or encrypt. We have an oracle that appends some random prefix to our plaintext before encrypting it using the MTR Stream cipher. We first find the prefix length, by simply subtracting the length of the plaintext from the len of oracle-returned ciphertext — the added length in the ciphertext must be due to the prefix, since there’s no padding in a stream cipher. 12345678910111213141516171819Step 1:plaintext:AAAAAAAAAAAAAAencrypted in oracle:|rand_prefix|| |RRRRRR AAAAAAAAAAAAAA|len(oracle_ciphertext)|Step 2:padded:|prefix_len|| |AAAAAA AAAAAAAAAAAAAA|len(oracle_ciphertext)| |-COMPARE ENC-| We then iterate through all possible seed values, 1…216. We create a MT Cipher with each seed, encrypting our padded data and seeing if it gives the same ciphertext as the oracle did. (Remember to slice out the random prefix when comparing!) If the ciphertexts match, we have found our seed! 1234for i in xrange(2**16): padded = 'A' * len(oracle_ciphertext) if MT19937Cipher(i).encrypt(padded)[prefix_len:] == oracle_ciphertext[prefix_len:]: return i","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://wangray.github.io/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://wangray.github.io/tags/cryptopals/"}]},{"title":"Matasano Crypto Challenges, Set 4","slug":"set4-writeup","date":"2017-03-07T15:38:11.000Z","updated":"2017-03-11T07:36:13.000Z","comments":true,"path":"2017/03/07/set4-writeup/","link":"","permalink":"http://wangray.github.io/2017/03/07/set4-writeup/","excerpt":"Challenge 25 Break “random access read/write” AES CTRBecause we can seek into the ciphertext and edit arbitrary characters, we we can simply guess each plaintext character. For each byte in the ciphertext, I can try all 256 characters by replacing the ciphertext byte with my encrypted guess using the provided edit() function. If the new ciphertext exactly matches the original ciphertext, then I know my guess for the plaintext character is correct, since it encrypted to the same byte. 123456for i in xrange(len(ciphertext)): for c in candidates: new_ciphertext = edit(ciphertext, i, c) if new_ciphertext[i] == ciphertext[i]: result += c","text":"Challenge 25 Break “random access read/write” AES CTRBecause we can seek into the ciphertext and edit arbitrary characters, we we can simply guess each plaintext character. For each byte in the ciphertext, I can try all 256 characters by replacing the ciphertext byte with my encrypted guess using the provided edit() function. If the new ciphertext exactly matches the original ciphertext, then I know my guess for the plaintext character is correct, since it encrypted to the same byte. 123456for i in xrange(len(ciphertext)): for c in candidates: new_ciphertext = edit(ciphertext, i, c) if new_ciphertext[i] == ciphertext[i]: result += c My main gripe is that this program is veryyy slow and I’m not sure where the slowdown comes from, but I’m not concerned with optimising right now. Challenge 26 CTR bitflippingCTR is susceptible to an even simpler bitflipping attack than CBC. I can simply send in the payload string as before &#39;\\x00admin\\x00true\\x00&#39;, which will be inserted between &quot;&quot;comment1=cooking%20MCs;userdata=&quot; &quot; and &quot;;comment2=%20like%20a%20pound%20of%20bacon&quot; and encrypted. I can modify the ciphertext for the block-of-interest directly — I don’t even need the previous ciphertext block as in CBC! 123ciphertext[32] = chr(ord(ciphertext[32]) ^ 59)ciphertext[38] = chr(ord(ciphertext[38]) ^ 61)ciphertext[43] = chr(ord(ciphertext[43]) ^ 59) will XOR in the ASCII codes for ; and =, so when CTR decryption XORs this ciphertext against the keystream, the desired characters will be left. Challenge 27 Recover the key from CBC with IV=KeyApparently, using the key as an IV is insecure, if an attacker can modify the ciphertext in-flight. The challenge instructs us to: 1234567891011Use your code to encrypt a message that is at least 3 blocks long:AES-CBC(P_1, P_2, P_3) -&gt; C_1, C_2, C_3Modify the message (you are now the attacker):C_1, C_2, C_3 -&gt; C_1, 0, C_1Decrypt the message (you are now the receiver) and raise the appropriate error if high-ASCII is found.As the attacker, recovering the plaintext from the error, extract the key:P'_1 XOR P'_3 Why does this work? Well, by inserting all \\x00‘s’ in block 2, when we CBC decrypt block 3 of C’, we recover the intermediate state of C_1, since we XOR with all \\x00. We also have the plaintext of C_1 in the first block. So, we can simply recover the IV by XORing the plaintext with the intermediate state. 123P'_3 ^ IV = P'_1IV = P'_1 ^ P'_3 Challenge 28 Implement a SHA-1 keyed MACThe way a MAC works is described in this diagram off wikipedia: We run the message through the HMAC algo, and send both the message and MAC digest to the receiver. The receiver must verify that the message he received has not been tampered by running it through the same MAC algo, and checking it against the MAC digest he received. In this case, our HMAC algo is just secret-prefix, SHA1(key || message). I borrow a SHA1 implementation from https://github.com/ajalt/python-sha1. The authsha1(key, data) function produces the MAC digest, and validate_oracle(key, message, digest) checks that the MAC digest of message matches digest. Challenge 29 Break a SHA-1 keyed MAC using length extensionThis is a cool attack. Here’s a general idea of how SHA-1 works: SHA1 operates on padded data. The RFC explains the padding scheme as follows:The purpose of message padding is to make the total length of a padded message a multiple of 512. SHA-1 sequentially processes blocks of 512 bits when computing the message digest. ‘1’ is appended to message. ‘0’s are appended, depending on the original length of the message. Leave space for two 4-byte words at the end, so bring up the message to 448 bits (56 bytes).We can do that with 1message += b'\\x00' * ((56 - (message_byte_length + 1) % 64) % 64) If the message is already &gt;56, Append the 2-word representation of len(message).If the message is 40 bytes long, The two-word representation of 40 is hex 00000000 00000028. There are five internal state variables, h0, h1, h2, h3, h4. These are concatenated to give the final digest. The h’s are initialized to123450x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0, Then, each chunk is processed and the h’s are updated as follows: Split the 64-byte chunk into 16 4-byte words Populate a word_array of size 80 with the 16 words, and then 64 more generated values. Let A = H0, B = H1, C = H2, D = H3, E = H4. Do 80 rounds of transformations on a, b, c, d, e. Finally, update the internal digestsH0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. So, when update() is called in authsha1, the internal states (the h’s) are updated for every full 64-byte block, leaving the leftovers in self._unprocessed. Then, digest() is called, to pad the leftovers to 64 or 128 bytes, and do the last 1 or 2 internal state updates, returning the concatenated h’s as the digest. The attackThe attack will mean I am able to successfully append some data to the message and create a forged digest, such that the receiver will think that I generated the digest by knowing the key and accept the message as untampered. The steps for forging a digest are: I need to guess the length of the key so that my message will have the correct padding. Split the SHA1 digest of the true message into 5 pieces, which will be passed as h0, h1, h2, h3, h4 to a new SHA1. For each guess for the keylength, prepend key padding to the original message and append SHA1 padding. 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... Pass in the internal state variables and the length of the padded message to a new SHA1, telling the algorithm how many bytes have been processed so far(message_byte_length) and the current state. Update the SHA1 with the extension data, getting a forged digest. We’re essentially forging the digest for: 12|keylen_guess|AAAAAAAAAAAAAA orig_message \\x01\\x00\\x00... ;admin=true Now, remove the key padding from the extended message, leaving the forged message: 1orig_message \\x01\\x00\\x00... ;admin=true . Send this and its forged digest to the receiver to be verified. The receiver will prepend the key to this message and calculate the digest. When we guess the correct keylen, the padding we’ve added to the orig_message block will be correct, and the SHA1 will continue by hashing the next block, ;admin=true, and find that the digest is the same as our forged one. 1234padded_plaintext_no_key = padded_plaintext_with_key_extension[keylen_guess:]if validate_oracle(key, padded_plaintext_no_key, forged_digest): print \"Found keylen_guess\", keylen_guess I successfully created a forged digest for the message comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x98;admin=true that the receiver validates! Challenge 30 Break an MD4 MD5 keyed MAC using length extensionI decided I like MD5 better than MD4, and there’s more implementations out there. MD5 is susceptible to the same length extension attack as above because it follows the MD construction, which includes padding and the fact that the output of the hash gives all the state needed to continue, or extend, the hash. Here’s how MD5 works: The padding scheme is very similar to SHA-1 — the only difference being that the length is added on as big-endian packed instead of little-endian packed. There are four internal state variables - A, B, C, D, each 32 bits. These are initialized to1234word A: 01 23 45 67word B: 89 ab cd efword C: fe dc ba 98word D: 76 54 32 10 We also use a table of 64 values generated from the sine function, self.k. For each chunk, which is 512 bits, we unpack into 16 words of 32-bits. Then, we do 64 transforms, split into four rounds. each transform taking: an incrementing-by-one index into the sin table, a function f specific to the round, a lrot value, and an index into our array of 16 words. At the end of each transform, the ABCD values are updated as follows: 1a, b, c, d = d, x &amp; 0xffffffff, b, c where x is the result of the transform. The message digest produced as output is the concat of A, B, C, D, 128 bits, or 16-bytes in length. I use the implementation at https://github.com/FiloSottile/crypto.py/blob/master/2/md5.py, but it needs to be extended in several ways for this challenge. The implementation must allow the caller to set the internal state variables so that I can continue the hash. I add12345678if state_array: self.A = state_array[0] self.B = state_array[1] self.C = state_array[2] self.D = state_array[3] else: #initial magic self.A, self.B, self.C, self.D = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) The implementation also must allow the caller to specify how many bytes have been processed so far, the message_byte_length option above. Challenge 31 Implement and break HMAC-SHA1 with an artificial timing leakI use Tornado as my web framework. I take in a file and signature URL param, and implement an insecure_compare function that converts the values to ascii, then byte-by-byte compares, adding a timing delay of 50ms. I iterate through all possible bytes, making a request with my known bytes + byte_guess + padding. I simply take the maximum delay each time, which would occur when I’ve guessed the byte correctly, causing another sleep of 50ms, for an added delay of 100ms. Challenge 32 Break HMAC-SHA1 with a slightly less artificial timing leakWhen I have such a small timing leak (5ms), network delays make the previous exploit unreliable. I need to normalize over multiple runs (I choose 10) to be able to tell whether the maximum is indeed the correct HMAC byte.","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://wangray.github.io/categories/Crypto/"}],"tags":[{"name":"cryptopals","slug":"cryptopals","permalink":"http://wangray.github.io/tags/cryptopals/"}]}]}